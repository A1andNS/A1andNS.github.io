{"title":"RE启动笔记","uid":"e9b793bf11c1914484b7555a66d461ba","slug":"RE启动笔记","date":"2021-05-03T03:24:23.000Z","updated":"2021-05-07T14:23:37.098Z","comments":true,"path":"api/articles/RE启动笔记.json","keywords":"A1andNS","cover":[],"content":"<h1 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h1><h2 id=\"常见的处理器架构\"><a href=\"#常见的处理器架构\" class=\"headerlink\" title=\"常见的处理器架构\"></a>常见的处理器架构</h2><p>常见的CPU架构有X86架构、AMD64架构、ARM架构、MIPS架构、IA64架构、X86-64架构。</p>\n<p>而这些架构又都会对应相应的指令集，指令集又分为**精简指令集(risv)<strong>和相对复杂的</strong>复杂指令集(cisv)**，其中ARM架构多用于手机等移动设备，例如我们手机的CPU基本都是基于ARM cortex内核的。MIPS架构多用于嵌入式路由器。</p>\n<h2 id=\"总线\"><a href=\"#总线\" class=\"headerlink\" title=\"总线\"></a>总线</h2><p>没有总线，cpu，内存、输入输出设备之间就无法进行沟通，总线的主要作用就是用来进行通讯。总线分为<strong>地址总线</strong>、<strong>数据总线</strong>和<strong>控制总线</strong>。</p>\n<p>并行：就是同时传输，串行就是队列排队传输。</p>\n<h2 id=\"编译过程\"><a href=\"#编译过程\" class=\"headerlink\" title=\"编译过程\"></a>编译过程</h2><p>文本文件编译成可执行程序的过程如下：</p>\n<p>预编译-&gt;编译-&gt;汇编-&gt;链接</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gcc -E xxx.c -o xxx.i <span class=\"token comment\">#预编译</span>\ngcc -S xxx.i -o xxx.s <span class=\"token comment\">#编译</span>\ngcc -C xxx.s -o xxx.o <span class=\"token comment\">#汇编</span>\ngcc --static xxx.o -o xxx <span class=\"token comment\">#连接</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>简单的helloword程序进行预编译后，原来的printf()函数被展开了</p>\n<p><img src=\"C:\\Users\\A1andNS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210503114456091.png\" alt=\"image-20210503114456091\"></p>\n<p>接着进行编译，得到了一个汇编的结果。</p>\n<p><img src=\"C:\\Users\\A1andNS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210503114604155.png\" alt=\"image-20210503114604155\"></p>\n<p>然后在汇编为机器码,使用readelf命令来读取符号表</p>\n<p><img src=\"C:\\Users\\A1andNS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210503115004806.png\" alt=\"image-20210503115004806\"></p>\n<h2 id=\"通用寄存器\"><a href=\"#通用寄存器\" class=\"headerlink\" title=\"通用寄存器\"></a>通用寄存器</h2><p>直接引用nep的图，师傅的总结。</p>\n<p><img src=\"C:\\Users\\A1andNS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210503120017430.png\" alt=\"image-20210503120017430\"></p>\n<p>al：低八位     ah：高八位   ax：高低合起来的16位   eax: 32位    rax：64位</p>\n<h2 id=\"段寄存器\"><a href=\"#段寄存器\" class=\"headerlink\" title=\"段寄存器\"></a>段寄存器</h2><p><img src=\"C:\\Users\\A1andNS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210504103444824.png\" alt=\"image-20210504103444824\"></p>\n<p>canary保护在栈里面存储一个值，然后再函数返回的时候，取出这个值，然后进行一个比较，来检测时候存在栈溢出。</p>\n<h3 id=\"标志寄存器\"><a href=\"#标志寄存器\" class=\"headerlink\" title=\"标志寄存器\"></a>标志寄存器</h3><p><img src=\"C:\\Users\\A1andNS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210504103918698.png\" alt=\"image-20210504103918698\"></p>\n<p>结合全名辅助记忆</p>\n<h2 id=\"运算指令\"><a href=\"#运算指令\" class=\"headerlink\" title=\"运算指令\"></a>运算指令</h2><p><img src=\"C:\\Users\\A1andNS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210504105202344.png\" alt=\"image-20210504105202344\"></p>\n<h2 id=\"赋值指令\"><a href=\"#赋值指令\" class=\"headerlink\" title=\"赋值指令\"></a>赋值指令</h2><p><img src=\"C:\\Users\\A1andNS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210504105542667.png\" alt=\"image-20210504105542667\"></p>\n<h2 id=\"栈相关指令\"><a href=\"#栈相关指令\" class=\"headerlink\" title=\"栈相关指令\"></a>栈相关指令</h2><p><img src=\"C:\\Users\\A1andNS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210504105944144.png\" alt=\"image-20210504105944144\"></p>\n<p>pusha和popa是逆过程，pushfd和popfd也是相逆的过程。</p>\n<h2 id=\"跳转指令\"><a href=\"#跳转指令\" class=\"headerlink\" title=\"跳转指令\"></a>跳转指令</h2><p><img src=\"C:\\Users\\A1andNS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210504110706025.png\" alt=\"image-20210504110706025\"></p>\n<p>cmp指令会把目标操作数-源操作数，然后再由又得到值来判断标志寄存器来跳转。</p>\n<p>a是大于，g也是大于，但是前者是无符号比较，后者是有符号比较。具体可以看图中的条件部分。</p>\n<h2 id=\"指令调用函数\"><a href=\"#指令调用函数\" class=\"headerlink\" title=\"指令调用函数\"></a>指令调用函数</h2><p><img src=\"C:\\Users\\A1andNS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210504111527021.png\" alt=\"image-20210504111527021\"></p>\n<p>call后跟需要调用的函数。ret返回函数，retf会影响段寄存器，可以让32位程序执行64位代码。</p>\n<h2 id=\"外部中断\"><a href=\"#外部中断\" class=\"headerlink\" title=\"外部中断\"></a>外部中断</h2><p>外部中断是指来自CPU外部的中断，而外部的中断源必须是某个硬件，所以外部中断又称为硬件中断<br>CPU提供统一的接口作为中断信号的公共线路，所有来自外设的中断信号都共享公共线路连接到CPU，外部硬件的中断通过两根信号线通知CPU的<br>两根信号线分别是INTR(INTeRrupt)和NMI(Non Maskable Interrupt)</p>\n<p><img src=\"C:\\Users\\A1andNS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210504141927250.png\" alt=\"image-20210504141927250\"></p>\n<p>从INTR引脚收到的中断都是不影响系统运行的，可以随时处理<br>从NMI引脚收到的中断，那基本上全是硬伤，CPU都没有运行下去的必要了</p>\n<h2 id=\"内中断\"><a href=\"#内中断\" class=\"headerlink\" title=\"内中断\"></a>内中断</h2><p><strong>除0错误</strong><br><strong>单步中断</strong><br>执行一条指令之后就会引起一次中断<br><strong>执行into指令</strong><br>into这是中断溢出指令，它所触发的中断向量号是 4。不过，能否引发 4 号中断是要看 eflags 标志寄存器中的 OF 位是否为 1，如果是 1 才会引发中断，否则该指令悄悄地什么都不做，低调得很<br><strong>执行int指令</strong><br>int 8位立即数 通过它进行系统调用，8 位立即数可表示 256种中断，这与处理器所支持的中断数是相吻合的<br><strong>异常</strong><br>fault：缺页发生</p>\n<p>trap (int3)    </p>\n<p>abort：终止程序运行</p>\n<h2 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h2><p>in指令一般用来从端口读数据，dx存端口号，读的数据存到al或者ax里面，具体是选择al还是ax是根据对应端口指代的寄存器位数来决定的<br>例如：<br>in al, dx<br>in ax, dx</p>\n<p>out指令一般用来往端口写数据，同样dx存端口号，与in指令不同的是out指令也可以使用立即数来指明端口号，然后要写入的数据使用al或者ax来存，同样具体是选择al还是ax是根据对应端口指代的寄存器位数来决定的</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">out dx, al\nout dx,ax\nout 立即数, al\nout 立即数, ax<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"内联汇编\"><a href=\"#内联汇编\" class=\"headerlink\" title=\"内联汇编\"></a>内联汇编</h2><p>基本内联汇编的格式如下：<br>asm [volatile] (“assembly code”)</p>\n<p><code>asm</code>和<code>__asm__</code>是一样的，<code>volatile</code>和<code>__volatile__</code>是一样的，volatile的功能是告诉gcc不要修改我写的汇编代码</p>\n<p>assembly code的规则</p>\n<ol>\n<li><p>指令必须用双引号引起来，无论双引号中是一条指令还是多条指令</p>\n</li>\n<li><p>一对双引号不能跨行，如果跨行需要在结尾用反斜杠’\\‘转移</p>\n</li>\n<li><p>指令之间用分号”;”、换行符”\\n”或换行符加制表符”\\n\\t”分隔</p>\n</li>\n</ol>\n<p>拓展内联汇编：</p>\n<p>格式如下</p>\n<p>asm [volatile] (“assembly code”:output : iuput : clobber/modify)</p>\n<p>output：用来指定汇编代码的数据如何输出给C代码使用</p>\n<p>input：用来指定C语言中数据如何输入给汇编使用</p>\n<p>clobber/modify：汇编代码执行后会破坏一些内存或寄存器资源，通过此项通知编译器，可能造成寄存器或内存数据的破坏，这样gcc就知道哪些寄存器或内存需要提前保护起来</p>\n<h3 id=\"寄存器约束\"><a href=\"#寄存器约束\" class=\"headerlink\" title=\"寄存器约束\"></a>寄存器约束</h3><p>寄存器约束就是要求 gcc 使用哪个寄存器，将 input 或 output 中变量约束在某个寄存器中。常见的寄存器约束有：</p>\n<ul>\n<li><p>-a：表示寄存器 eax/ax/al </p>\n</li>\n<li><p>-b：表示寄存器 ebx/bx/bl </p>\n</li>\n<li><p>-c：表示寄存器 ecx/cx/cl </p>\n</li>\n<li><p>-d：表示寄存器 edx/dx/dl </p>\n</li>\n<li><p>-D：表示寄存器 edi/di </p>\n</li>\n<li><p>-S：表示寄存器 esi/si</p>\n</li>\n<li><p>-q：表示任意这 4 个通用寄存器之一：eax/ebx/ecx/edx </p>\n</li>\n<li><p>-r：表示任意这 6 个通用寄存器之一：eax/ebx/ecx/edx/esi/edi</p>\n</li>\n<li><p>-g：表示可以存放到任意地点（寄存器和内存）。相当于除了同 q 一样外，还可以让 gcc 安排在内存中</p>\n</li>\n<li><p>-A：把 eax 和 edx 组合成 64 位整数</p>\n</li>\n<li><p>-f：表示浮点寄存器</p>\n</li>\n<li><p>-t：表示第 1 个浮点寄存器</p>\n</li>\n<li><p>-u：表示第 2 个浮点寄存器</p>\n</li>\n</ul>\n","text":"基本知识常见的处理器架构常见的CPU架构有X86架构、AMD64架构、ARM架构、MIPS架构、IA64架构、X86-64架构。 而这些架构又都会对应相应的指令集，指令集又分为**精简指令集(risv)和相对复杂的复杂指令集(cisv)**，其中ARM架构多用于手机等移动设备，例...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":31,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"RE","slug":"RE","count":1,"path":"api/tags/RE.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">基本知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">常见的处理器架构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BA%BF\"><span class=\"toc-text\">总线</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">编译过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">通用寄存器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">段寄存器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">标志寄存器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">运算指令</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%8B%E5%80%BC%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">赋值指令</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">栈相关指令</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">跳转指令</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">指令调用函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">外部中断</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">内中断</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AB%AF%E5%8F%A3\"><span class=\"toc-text\">端口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96\"><span class=\"toc-text\">内联汇编</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%84%E5%AD%98%E5%99%A8%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">寄存器约束</span></a></li></ol></li></ol></li></ol>","author":{"name":"沐子龍","slug":"blog-author","avatar":"/svg/head.png","link":"/","description":"爱你所爱，行你所行，听从你心，无问西东","socials":{"github":"https://github.com/A1andNS","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"强网杯2021-pop链","uid":"2f7fe6f4a9640694ceed20c9c2405618","slug":"强网杯2021-pop链","date":"2021-06-28T15:34:20.000Z","updated":"2021-06-28T15:37:27.723Z","comments":true,"path":"api/articles/强网杯2021-pop链.json","keywords":"A1andNS","cover":"https://gitee.com/A1andNS/blogimage/raw/master/img/20210628233657.png","text":"强网杯2021-pop链起初以为pop链是固定的，没有想到还是随机生成的，而且为了混淆16W行也是够狠的。 这题后来看了题解是使用一个工具来进行pop链的寻找的，这里我用来笨办法，手动看就是废时间，还需要运气，也算是拿了个八血。 http:&#x2F;&#x2F;eci-2ze6...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"CTF","slug":"CTF","count":42,"path":"api/categories/CTF.json"}],"tags":[{"name":"CTF","slug":"CTF","count":14,"path":"api/tags/CTF.json"}],"author":{"name":"沐子龍","slug":"blog-author","avatar":"/svg/head.png","link":"/","description":"爱你所爱，行你所行，听从你心，无问西东","socials":{"github":"https://github.com/A1andNS","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"记一次XSS漏洞挖掘","uid":"4b5caccf55bfe27d91d67615feb9c00b","slug":"记一次XSS漏洞挖掘","date":"2021-04-26T08:55:29.000Z","updated":"2021-07-21T12:58:42.786Z","comments":true,"path":"api/articles/记一次XSS漏洞挖掘.json","keywords":"A1andNS","cover":"https://gitee.com/A1andNS/blogimage/raw/master/img/20210721205645.png","text":" 627feb16c11f197ed5323e23f4e5670415c78bf165fbe82d6957e5d237fbefc291e49de66b51b6c7399f06d3c7448a3274671ab4bc75f93c9c4f6d7721eed4d122db0619985...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":2,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"XSS","slug":"XSS","count":4,"path":"api/tags/XSS.json"},{"name":"加密文章","slug":"加密文章","count":3,"path":"api/tags/加密文章.json"},{"name":"漏洞挖掘","slug":"漏洞挖掘","count":2,"path":"api/tags/漏洞挖掘.json"}],"author":{"name":"沐子龍","slug":"blog-author","avatar":"/svg/head.png","link":"/","description":"爱你所爱，行你所行，听从你心，无问西东","socials":{"github":"https://github.com/A1andNS","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}