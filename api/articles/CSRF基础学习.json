{"title":"CSRF基础学习","uid":"e5e3a6aac05f155097d5d514020d33d1","slug":"CSRF基础学习","date":"2020-03-09T07:48:04.000Z","updated":"2020-04-13T00:46:24.000Z","comments":true,"path":"api/articles/CSRF基础学习.json","keywords":"A1andNS","cover":[],"content":"<p>上一篇博客说的是XSS跨站脚本攻击，现在说的是另一种跨站攻击，CSRF（Cross-Site Request Forgery),跨站请求伪造。</p>\n<h2 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h2><p>正如其名，CSRF是伪造请求，就是冒充用户在站内进行正常操作。我们知道，绝大多数网站是通过Cookie等方式辨别用户身份（包括使用服务器端Session的网站，因为Session ID也是保存在Cookie里面），再予以授权。这就是为什么要保护好用户的Cookie。所以要想要伪造用户的正常操作，就是要偷Cookie了，那么可能就和上一篇里面说过的XSS优点关联了，利用XSS攻击获取被攻击者的Cookie，在或者就是使用链接欺骗等途径，让用户在本机发起用户所不知道的请求，这里说的本机是拥有Cookie的浏览器端。</p>\n<p>2008年时由多个国内外大型社区和交互网站爆出CSRF漏洞，也是让大家聚焦这个漏洞。其实这种攻击方式在2000年就已经被国外的安全人员提出，但是在国内，直到2006年才开始被关注。</p>\n<h2 id=\"2、分类\"><a href=\"#2、分类\" class=\"headerlink\" title=\"2、分类\"></a>2、分类</h2><p>CSRF漏洞的攻击一般分为站内和站外两种类型。</p>\n<p>CSRF站内类型的漏洞一般都是因为程序员滥用 $_REQUEST类变量造成的，一些敏感数据本来应该使用POST请求传参，但是因为使用了 $_REQUEST等变量，程序也可以接受GET类型请求传参，这样无形之中就给攻击者提供了使用CSRF的条件，一般攻击者只要把预测好的请求参数放入站内的一个帖子或者留言的图片链接里，受害者浏览了这样的页面就会被强制发起请求。</p>\n<p>CSRF站外类型的漏洞其实就是外部数据提交问题，一般程序员会考虑给一些留言评论等的表单加上水印防止SPAM问题，但是为了用户的体验性，一些操作可能没有做任何限制，这是很危险的做法，因此攻击者可以向预测好请求的参数，在站外的Web页面里编写JavaScript脚本伪造文件请求或和自动提交的表单来实现GET、POST请求，用户在会话状态下单击链接访问站外的Web页面，客户端就被强迫发起请求。</p>\n<h2 id=\"3、原理\"><a href=\"#3、原理\" class=\"headerlink\" title=\"3、原理\"></a>3、原理</h2><p>CSRF的原理如图</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20191216201449885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2MTM5MDQ1,size_16,color_FFFFFF,t_70\" alt=\"1\"></p>\n<p>这就相当于受害者需要在登录A网站之后，再去访问B网站，而B网站一般就是一些钓鱼或者诈骗网站了。</p>\n<h2 id=\"4、攻击场景\"><a href=\"#4、攻击场景\" class=\"headerlink\" title=\"4、攻击场景\"></a>4、攻击场景</h2><p>这里举一个例子说明：</p>\n<p>假设有一个银行A，它允许使用GET方式请求来转账操作，当然这就是个例子而已，现实生活中的银行当然不可能只用GET请求转账。大家就看看就好，别想太多。</p>\n<p>操作：<code>http://www.Abank.com/Transfer.php?tobankID=13&amp;money=1000</code></p>\n<p>这个时候危险的网站B的代码段中存在这样的一句代码：<code>&lt;img scr=&quot; http://www.Abank.com/Tranfer.php?tobankID=13&amp;money=1000&quot; /&gt;</code></p>\n<p>r.php?tobankID=13&amp;money=1000” /&gt;`</p>\n<p>那么当返回A银行时，就会发现账户上已经少了1000元。</p>\n","text":"上一篇博客说的是XSS跨站脚本攻击，现在说的是另一种跨站攻击，CSRF（Cross-Site Request Forgery),跨站请求伪造。 1、概述正如其名，CSRF是伪造请求，就是冒充用户在站内进行正常操作。我们知道，绝大多数网站是通过Cookie等方式辨别用户身份（包括使...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":34,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"网络安全","slug":"网络安全","count":32,"path":"api/tags/网络安全.json"},{"name":"WEB","slug":"WEB","count":39,"path":"api/tags/WEB.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1、概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">2、分类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">3、原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%94%BB%E5%87%BB%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">4、攻击场景</span></a></li></ol>","author":{"name":"A1andNS","slug":"blog-author","avatar":"/svg/head.png","link":"/","description":"爱你所爱，行你所行，听从你心，无问西东","socials":{"github":"https://github.com/A1andNS","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"XSS跨站入门基础知识","uid":"26ba6c78face14f329da4d0dd48531b1","slug":"XSS跨站入门基础知识","date":"2020-03-09T07:49:59.000Z","updated":"2020-04-13T00:46:22.000Z","comments":true,"path":"api/articles/XSS跨站入门基础知识.json","keywords":"A1andNS","cover":[],"text":"之前写的SQL主要时针对服务器端，通过构造SQL命令提交，以达到脱库或其他目的。今天要说的这个XSS也是一个非常著名的Web漏洞。XSS（Cross Site Scripting）的全称是跨站脚本攻击，之所以叫XSS，是想与Web中的另一个层叠样式表CSS区分。该攻击主要是在网页...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":34,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"网络安全","slug":"网络安全","count":32,"path":"api/tags/网络安全.json"},{"name":"WEB","slug":"WEB","count":39,"path":"api/tags/WEB.json"},{"name":"XSS","slug":"XSS","count":4,"path":"api/tags/XSS.json"}],"author":{"name":"A1andNS","slug":"blog-author","avatar":"/svg/head.png","link":"/","description":"爱你所爱，行你所行，听从你心，无问西东","socials":{"github":"https://github.com/A1andNS","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"一文简单入门文件上传","uid":"99138ec644b11a428edfab781d45e70d","slug":"一文简单入门文件上传","date":"2020-03-09T07:47:04.000Z","updated":"2020-04-13T00:46:40.000Z","comments":true,"path":"api/articles/一文简单入门文件上传.json","keywords":"A1andNS","cover":[],"text":"随着Web应用发展和广泛应用，很多的应用都允许用户上传自己的文件，以此提升用户体验。但是，这也就造成了一个web应用安全中很著名的漏洞，它就是文件上传漏洞。由于Web应用的上传功能的代码实现没有对用户上传文件的格式和后缀以及文件类型进行过滤，从而导致大家都可以任意上传文件到服务器...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":34,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"网络安全","slug":"网络安全","count":32,"path":"api/tags/网络安全.json"},{"name":"WEB","slug":"WEB","count":39,"path":"api/tags/WEB.json"},{"name":"文件上传","slug":"文件上传","count":2,"path":"api/tags/文件上传.json"}],"author":{"name":"A1andNS","slug":"blog-author","avatar":"/svg/head.png","link":"/","description":"爱你所爱，行你所行，听从你心，无问西东","socials":{"github":"https://github.com/A1andNS","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}