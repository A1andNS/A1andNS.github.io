{"title":"数组内元素循环右移k位","uid":"9cc4e1ca2693b071a7fc6321af0c5a32","slug":"数组内元素循环右移k位","date":"2020-08-31T10:33:07.000Z","updated":"2020-08-31T10:52:30.000Z","comments":true,"path":"api/articles/数组内元素循环右移k位.json","keywords":"A1andNS","cover":"https://www.runoob.com/wp-content/uploads/2015/01/cpp-mini-logo.png","content":"<h3 id=\"问题内容\"><a href=\"#问题内容\" class=\"headerlink\" title=\"问题内容\"></a>问题内容</h3><p>用来将数组a[n]的每个元素都循环地右移k 位，这里1≤k≤n</p>\n<p>以下为自写解决方案，写了挺久的，太久没有摸C了，底下的可能不够高明：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;移位函数，实现移位操作&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint changeLocation(int a[],int n,int k)&#123;\n    int temp;\n    for (size_t i &#x3D; 0; i &lt; n-k; i++)    &#x2F;&#x2F;把a[k]-a[n]作为交换空间，把每k个数组元素与交换空间交换位置\n    &#123;\n        temp &#x3D; a[i];\n        a[i] &#x3D; a[n-k+(i%k)];\n        a[n-k+(i%k)] &#x3D; temp;\n    &#125;\n    return a[n];\n&#125;\n\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;输出打印函数，用于打印移位结果&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nvoid PrintResult(int a[],int size)&#123;\n    for (size_t i &#x3D; 0; i &lt; size; i++)\n    &#123;\n        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n    &#125;\n    cout&lt;&lt;endl;\n    \n&#125;\n\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;数组写入函数，用于向数组写入用户输入数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint Write(int a[],int size)&#123;\n    for (size_t i &#x3D; 0; i &lt; size; i++)\n    &#123;\n        cin&gt;&gt;a[i];  &#x2F;&#x2F;把数据写入数组\n    &#125;\n    return a[size];\n&#125;\n\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;主程序&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint main()&#123;\n    int num,k;\n    cin&gt;&gt;num&gt;&gt;k;    &#x2F;&#x2F;输入数据依次输入数组长度num和移位长度k\n    int a[num];\n    a[num] &#x3D; Write( a, num );\n    a[num] &#x3D; changeLocation( a, num ,k );\n    PrintResult( a, num );\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"另一种方案\"><a href=\"#另一种方案\" class=\"headerlink\" title=\"另一种方案\"></a>另一种方案</h3><p>算法描述如下：</p>\n<p>步骤1） 将数组分成两段，左段长为n-k，右段长为k。</p>\n<p>步骤2） 分别将两段逆转（即元素排列次序与原次序相反）。</p>\n<p>步骤3） 再数组元素整体逆转。</p>\n<p>（1）用C 语言编程实现（不能使用辅助数组）。</p>\n<p>（2）求元素移动次数T(n)。要求出准确的解析式（不是大O 记号）。</p>\n<p>（3）试证明算法是正确的。</p>\n<p>提示，任一数组元素a[i]经算法处理后，其下标变成：(i+k)% n。</p>\n<p>下面是我按照算法描述，写出的程序：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nconst \n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;对前size-k部分做倒序&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint rev1(int a[],int size,int k)&#123;\n    int temp;\n    for (size_t i &#x3D; 0; i &lt; (size-k)&#x2F;2; i++)\n    &#123;\n        temp &#x3D; a[size-k-1-i];\n        a[size-k-1-i] &#x3D; a[i];\n        a[i] &#x3D; temp;\n    &#125;\n    return a[size];\n&#125;\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;对后k部分做倒序&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint rev2(int a[],int size,int k)&#123;\n    int temp;\n    for (size_t i &#x3D; 0; i &lt; k&#x2F;2; i++)\n    &#123;\n        temp &#x3D; a[size-1-i];\n        a[size-1-i] &#x3D; a[size-k+i];\n        a[size-k+i] &#x3D; temp;\n    &#125;\n    return a[size];\n&#125;\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;对整个数组做倒序&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint allrev(int a[], int size)&#123;\n    int temp;\n    for (size_t i &#x3D; 0; i &lt; size&#x2F;2; i++)\n    &#123;\n        temp &#x3D; a[size-1-i];\n        a[size-1-i] &#x3D; a[i];\n        a[i] &#x3D; temp;\n    &#125;\n    return a[size];\n&#125;\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;写数组元素&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint Write(int a[], int size)&#123;\n    for (size_t i &#x3D; 0; i &lt; size; i++)\n    &#123;\n        cin&gt;&gt;a[i];\n    &#125;\n    return a[size];\n&#125;\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印数组&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nvoid Print(int a[], int size)&#123;\n    for (size_t i &#x3D; 0; i &lt; size; i++)\n    &#123;\n        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n    &#125;\n    cout&lt;&lt;endl;\n&#125;\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;主函数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint main()&#123;\n    int n,k;\n    cin&gt;&gt;n&gt;&gt;k;\n    int a[n];\n    a[n] &#x3D; Write( a, n);\n    a[n] &#x3D; rev1( a, n, k);\n    a[n] &#x3D; rev2( a, n, k);\n    a[n] &#x3D; allrev( a, n);\n    Print( a, n);\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这种写法运行需要的次数比我少，所以效率比我高。算法是个好东西啊。</p>\n","text":"问题内容用来将数组a[n]的每个元素都循环地右移k 位，这里1≤k≤n 以下为自写解决方案，写了挺久的，太久没有摸C了，底下的可能不够高明： #include &lt;iostream&gt; using namespace std; &#x2F;*&#x3D;&#x3D;&#x...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"C++","slug":"C","count":1,"path":"api/categories/C.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":3,"path":"api/tags/数据结构.json"},{"name":"C++","slug":"C","count":2,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">问题内容</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">另一种方案</span></a></li></ol>","author":{"name":"A1andNS","slug":"blog-author","avatar":"/svg/head.png","link":"/","description":"爱你所爱，行你所行，听从你心，无问西东","socials":{"github":"https://github.com/A1andNS","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"PHP学习(四)","uid":"0e6a582945fdbc93fa2d76153b4ed629","slug":"PHP学习-四","date":"2020-08-31T13:11:18.000Z","updated":"2020-09-01T09:09:54.000Z","comments":true,"path":"api/articles/PHP学习-四.json","keywords":"A1andNS","cover":null,"text":"今天继续 PHP数据类型String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。 PHP字符串可以把任何文本放在单引号和双引号，一个字符串就是一串字符的序列，”Hell...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"PHP","slug":"PHP","count":7,"path":"api/categories/PHP.json"}],"tags":[{"name":"PHP","slug":"PHP","count":8,"path":"api/tags/PHP.json"}],"author":{"name":"A1andNS","slug":"blog-author","avatar":"/svg/head.png","link":"/","description":"爱你所爱，行你所行，听从你心，无问西东","socials":{"github":"https://github.com/A1andNS","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"数据结构初学","uid":"6e0b8c18e7066f45b525fe746b5eeb37","slug":"数据结构初学","date":"2020-08-30T14:33:01.000Z","updated":"2020-09-06T14:11:44.000Z","comments":true,"path":"api/articles/数据结构初学.json","keywords":"A1andNS","cover":"https://edu-image.nosdn.127.net/8A2FD753FE609F6F62064E95F74432E6.jpg?imageView&thumbnail=426y240&quality=100","text":"数据结构是程序设计的灵魂啊！盘他！ 常见数据结构应用车载导航仪——–图结构 文件管理器——–树结构 成绩管理器——–表结构 问题与模型定量模型：可以用数值方程表示的，方程式等等。 定性模型：非数值性的数据结构及其运算，数据结构主要研究非数值性。 研究对象 数据元素的集合 数据元素...","link":"","photos":[],"count_time":{"symbolsCount":747,"symbolsTime":"1 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":35,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"学习笔记","slug":"学习笔记","count":3,"path":"api/tags/学习笔记.json"},{"name":"数据结构","slug":"数据结构","count":3,"path":"api/tags/数据结构.json"}],"author":{"name":"A1andNS","slug":"blog-author","avatar":"/svg/head.png","link":"/","description":"爱你所爱，行你所行，听从你心，无问西东","socials":{"github":"https://github.com/A1andNS","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}